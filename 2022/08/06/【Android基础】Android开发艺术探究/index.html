<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Anroid开发艺术探究 - 简则易从的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="简则易从的博客"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="简则易从的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？  onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别 2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B"><meta property="og:type" content="blog"><meta property="og:title" content="简则易从"><meta property="og:url" content="https://moruoyiming.github.io/"><meta property="og:site_name" content="简则易从"><meta property="og:description" content="1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？  onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别 2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moruoyiming.github.io/img/favicon.jpg"><meta property="article:published_time" content="2022-08-06T14:29:31.663Z"><meta property="article:modified_time" content="2022-08-09T13:02:14.651Z"><meta property="article:author" content="Jian"><meta property="article:tag" content="Android"><meta property="article:tag" content="ActivityManagerNative"><meta property="article:tag" content="Zygote"><meta property="article:tag" content="SystemServer"><meta property="article:tag" content="安装流程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/favicon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://moruoyiming.github.io/2022/08/06/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/"},"headline":"简则易从的博客","image":["https://moruoyiming.github.io/gallery/thumbnails/plant.jpg"],"datePublished":"2022-08-06T14:29:31.663Z","dateModified":"2022-08-09T13:02:14.651Z","author":{"@type":"Person","name":"Brigitte Jian"},"description":"1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？  onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别 2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B"}</script><link rel="canonical" href="https://moruoyiming.github.io/2022/08/06/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8241795889030186" crossOrigin="anonymous"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/media">电影</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/thumbnails/plant.jpg" alt="Anroid开发艺术探究"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/#comment-container"><span class="display-none-class">210a42db6c618854d687f80f2855d9ab</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="210a42db6c618854d687f80f2855d9ab">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>15.1 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Anroid开发艺术探究</h1><div class="content"><p>1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？<br>  onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别</p>
<p>2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B 的onResume()和 A 的onPaus()哪个先执行呢？<br>  启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内的Activvity的状态，AMS通过<br>  ActivityThread去同步Activity的状态从而完成生命周期方法的调用。在ActivityStack中的resumeTopActivityInnerLocked方法中，在新Acctivity启动之前，<br>  栈顶的Activity需要先onPause()后，新Activity才能启动。最终在ActivityStackSupervisor中的realStartActivityLocked方法会调用scheduleLaunchActivity，<br>  接着完成新Activity的onCreate、onStart、onResume的调用过程。因此，可以得到结论，是旧Activity先onPause，然后新Activity再启动。</p>
<p>3.Activity被销毁并重建后，我们去获取之前的存储字符串，接受的位置可以是onRestoreInstanceState 或者 onCreate 方法，两者区别是？<br>  onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的拍断是否为空；<br>  但是onCreate不行，onCreate如果正常启动的话，其参数Bundle savedInstanceState为null, 所以必须要额外判断。</p>
<p>4.onSaveInstanceState和onRestoreInstanceState，在正常流程下会出发么？<br>  系统只在Activity异常种植的时候才会调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，其他情况不会出发这个过程。</p>
<p>5.比如目前任务栈S1中的情况为ABC，这个时候Activity D 以singleTask模式请求启动，其所需要的任务栈为 S2，由于S2和D的实例均不存在，所以系统会先创建<br>  任务栈S2，然后在创建D的实例并将其入栈到S2.</p>
<p>6.TaskAffinity任务相关性。<br>  这个参数标识一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。可以为每个Activity都单独制定TaskAffinity属性，<br>  这个属性必须不能和包名相同，否则就相当于没有制定。TaskAffinity属性主要和singleTask启动模式或者allTaskReparenting属性配对使用。当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity回运行在名字和TaskAffinity相同的任务栈中。<br>  当TaskAffinity和allowTaskReparenting结合的时候，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allTaskReparenting属性为true的话，那么当应用B被启动后，词Activity回直接从应用A的任务栈转移到应用B的任务栈中。</p>
<p>7.SharedPerences是否安全？<br>  SharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，因为SharedPreferences底层是通过读&#x2F;写XML文件来实现的，并发会出问题。<br>  每个应用的SharedPreferences文件都在当前包所在的data目录下查看到，目录位于 &#x2F;data&#x2F;data&#x2F;pacakage name&#x2F;shared_prefs目录下。<br>  SharedPreferences也属于文件的一种，但是由于系统对他的读&#x2F;写有一定的缓存策略，即在内存中有一份ShareePreferences文件的缓存，因此在多进程下，系统对它的读写诗不可靠的，当面对高并发的读&#x2F;写访问，有很大几率丢失文件。</p>
<p>8.Serializable接口的原理及serialVersionUID作用？<br>  想让一个对象实现序列化，只需要这个类实现Serializable接口并声明一个serialVersionUID即可。实际上，甚至连这个serialVersionUID也不是必须的。如何进行对象的序列化和反序列化也很简单，只需要采用ObjectOutputStream和ObjectInputStream，readObject()writeObject()函数。<br>  serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的数据中的serialVersionUID只有和当前累的serialVersionUID相同时才能够正常的被反序列化。<br>  serialVersionUID的详细工作机制时这样的：序列化的时候系统把当前类的serialVersionUID写入序列化文件中，当反序列化时候系统回去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本时相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候时无法正常反序列化的。</p>
<p>9.Parcelable接口原理？<br>  Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并通过Intent和Binder传递。<br>  Parcel内部包装了可序列化的数据，可以在Binder中自由传输。<br>  序列化的功能由writeToParcel方法来完成，最终时通过Parcel的一系列write方法来完成的；<br>  反序列化功能由CREATOR来完成，其内部表明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化过程。</p>
<span id="more"></span>
<p>10.Parcelable和Serializable的区别？<br>  Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I&#x2F;O操作。<br>  Parcelable是Android中的序列化方式，操作复杂，效率很高。<br>  Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但是<br>  这个过程会稍显复杂，因此这两种情况建议使用Serializable。</p>
<p>11.AIDL流程及原理<br>  1.创建aidl文件，声明函数及接口<br>  2.系统根据IBookManager.aidl生成IBookManager.jar类，继承了IInterface接口，本身也是接口。在Binder中传输的接口都需要继承<br>    IInterface接口。<br>  3.该类声明aidl中的方法，同时声明了两个正形的id分别用于标识这两个方法，这两个id用于表示在transact过程中客户端所追求的到底是哪个方法。它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成。<br>  核心实现就是它的内部类Stub和Stub的内部代理类Proxy。<br>  DESCRIPTOR：Binder的唯一标识，一半用单钱Binder的类名表示。<br>  asInterface(android.os.IBinder obj):用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的数据，这种转换过程是区分进程的，如果客户端和服务端位于统一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。<br>  asBindeeer：此方法用于返回当前Binder对象。<br>  onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层疯转后交由此方法处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值，onTransact方法执行过程是这样的。<br>  需要注意的是，如果此方法返回false，那么客户端的请求会失败。<br>  Proxy#geetBookList：这个方法运行在客户端，当客户端远程调用此方法时，，首先创建该方法所需要的输入型Parceel对象_data、输出型Parcel对象_reply和返回值对象List，然后把该方法的参数信息写入_data中；接着调用transact方法来发起RPC请求，同时当前线程刮起；然后服务端的onTransact方法会呗调用，知道RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_replay中的数据。<br>  Proxy#addBook:这个方法运行在客户端，它的执行过程和getBookList是一样的。<br>  注意点:1.当客户端发起远程请求时，由于当前线程会呗挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起此次远程请求<br>        2.由于服务端的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。</p>
<p>12.Binder包含两个重要的方法linkToDeath和unlinkToDeath。Binder运行在服务端进程，如果服务端进程由于某种原因异常终止，这时到服务<br>  端的Binder链接端礼，导致远程调用失败。为了解决这个问题，Binder中提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath可以给Binder设置一个死亡代理，当Linder死亡时，会收到通知，这时可以重新发起连接请求从而恢复连接。<br>  可通过isBinderAlive可以判断BInder是否死亡。<br>  1.声明DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法binderDied，我们需要实现这个方法，当Binder死亡的时候，系统就会毁掉binderDied方法</p>
<p>13.跨进程通讯Messenger原理？<br>  通过Messenger在不同进程中传递Message对象。Messenger底层是AIDL。<br>  1.服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回一个Messenger对象顶层的Binder即可<br>  2.客户端进程中，首先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger,通过这个Messenger就可以向服务端发送消息，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一样，还需要创建一个Handler并创建一个新的Messenger，并把这个Messengeer对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<p>14.AIDL中能够使用的List只有ArrayList，但是使用了CopyOnWriteArrayList(注意它不是继承自ArrayList)，为什么能够正常工作？<br>  因为AIDL中所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但是在Binder中会按照List的规范去访问数据并最终形成一个新的ArrayList传递给客户端。所以，在服务端采用CopyOnWriteArrayList是完全可以的。</p>
<p>15.RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口。RemoteCallbackList是一个范型，支持管理任意的AIDL接口，这点从它的生命可以看出，因为所有  的AIDL接口都继承自IInterface接口。原理是它的内部有一个Map结构专门用来保存所有的AIDL回调，这个Map的key是IBinder类型，value是Callback类型。<br>  RemoteCallbackList内部自动实现了线程同步的功能，所以使用它来注册和解注册时，不需要做额外的线程同步工作。</p>
<ol start="16">
<li></li>
</ol>
<p>17.Sockeet套接字，氛围流式套接字和用户数据套接字两种，分别对应于网络的传输控制层中的TCP和UDP。TCP时面向连接的协议，提供稳定的双向通讯功能，TCP连接的建立<br>   需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，具有很高的稳定性。而UDP时无连接的，提供不稳定的单向通讯功能，当然UDP也可以实现双向通讯功能。UDP具有更好的效率，确定是不保证数据一定能够正确传输，尤其在网络拥塞的情况下。</p>
<p>18.TouchSlop时系统所能识别出的被认为是滑动的最小距离，当手指在屏幕滑动时，如果两次滑动指尖的距离小于这个常量，系统就不认为是在进行滑动操作。<br>   ViewConfiguration.get(getContext()).getScaleedTouchSlop().</p>
<p>19.VelocityTracker速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。<br>   GestureDetector手势检测，用于辅助检测用护的点击、滑动、长安、双击等行为。创建GestrueDetector对象并实现OnGestureListener接口。<br>   Scroller弹性滑动对象，用于实现View的弹性滑动。</p>
<p>20.View的滑动方式<br>   1.通过View本身提供的scrollTo&#x2F;scrollBy方法来实现滑动<br>   2.通过动画给View施加平移效果实现滑动<br>   3.改变View的LayoutParams使得View重新布局从而实现滑动</p>
<p>21.scrollTo和scrollBy区别<br>   scrollBy实际上也是调用了scrollTo方法，它实现了基于当前位置的相对滑动，而scrollTo则实现了基于所传递参数的绝对滑动。</p>
<p>22.View滑动过程中，view内部的两个属性mScrollX和mScrollY的改变规则，这两个属性可以通过getScrollX和getScrollY方法分别得到。<br>   在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元呢在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在水平方向的距离。<br>   scrollTo和scrollBy只能改变View的内容的位置，而不能改变View在布局中的位置。</p>
<p>23.三种滑动对比<br>   1.scrollTo&#x2F;scrollBy:操作简单呢，适合对View内容的滑动。缺点只能滑动View的内容，不能滑动View本身。<br>   2.动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果。<br>   3.改变布局参数：操作稍微复杂，适用于有交互的View。</p>
<p>24.Scroller原理？<br>   首先构造一个Scroller对象并调用它的startScroll方法，内部其实什么也没做，只是保存了我们传递的几个参数startScroll(int startx,int starty,int dx,int dy ,in duration),滑动指View内容的滑动而非View本身位置的改变。startScroll方法下面的invalidate方法。invalidate方法会导致View重绘，在View的draw方法中又会去调用computeScroll方法，computeScroll方法在View中是一个空实现，因此需要我们去实现，上面的代码实现了computeScroll方法。<br>   当View冲毁后会在draw方法中调用computeScroll,而computeScroll又会去想Scroller获取当前的scrollX和scrollY，然后通过scrollTo方法实现滑动，接着又调用postInvalidate方法来进行第二次重绘。这一次重绘的过程和第一次重绘一样，还是会导致computeScroll方法被调用，然后继续向Scroller获取当前的scrollX和scrollY，并通过scrollTo方法滑动到最新的位置。<br>   概括：Scroller本身并不能实现View的滑动，它需要配合View的computeScroll方法才能完成弹性滑动的效果，他不断的让View重绘，二每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得到View当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成Vieew滑动。就这样，Vieew的每一次重绘都会导致View进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动。</p>
<p>25.点击事件的分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生之后，系统需要把这个事件传递给一个具体的View，这个传递的过程就是分发过程。<br>   分发过程主要由三个方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。<br>   1.dispatchToucherEveent(MotionEvent ev)<br>   用来进行事件的分发，如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。<br>   2.onInterceptTouchEvent(MotionEvent ev)<br>   在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。<br>   3.onTouchEvent(MotionEvent event)<br>   在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则同一事件序列中，当前View无法再次接收到事件。<br>   public boolean dispatchTouchEvent(MotionEvent ev){<br>        boolean consume &#x3D; false<br>        if(onInterceptTouchEvent(ev)){<br>             consume &#x3D; onTouchEvent(ev)<br>        }else{<br>             consume &#x3D; child.dispatchTouchEvent(ev)<br>        }<br>        return consume;<br>   }</p>
<p>26.事件传递规则<br>   对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法会被调用，如此反复知道事件被最终处理。</p>
<p>27.事件传递的优先级别 OnTouchListener &gt; onTouchEvent -&gt; OnCLickListener<br>   当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高.在onTouchEvent方法中，如果当前设置的有OnClickListeneer，那么它的onClick方法会被调用。可以看出，OnCLickListener，其优先级最低，即处于事件传递的尾端。</p>
<p>28.事件传递的顺序<br>   当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View，即事件总是先传递给Activity，Activity在传递给Window，最后Window在传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依次类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。</p>
<p>29.关于事件传递的机制，一些结论<br>   1.同一个事件序列是从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。<br>   2.正常情况下，一个序列事件只能被一个View拦截且消耗。因为一旦一个元素拦截了某个事件，那么同一事件序列内的所有事件都会直接全交给它处理，那么同一事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onToucheEvent强行传递给其他View处理。<br>   3.某个View一旦决定拦截，那么这一个事件序列都只能由它来处理(如果事件序列能够传递给它的话)，并且它的onInterceptTouchEveent不会再被调用。当一个View决定拦截一个事件后，那么系统会把同一事件序列内的其他方法都直接交给它来处理，那么就不用再调用这个View的onInterceptTouchEevent去询问它是否要拦截了。<br>   4.某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新由它的父元素去处理，即父元素的onTouchEvent会被调用，意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。<br>   5.如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。<br>   6.ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false。<br>   7.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。<br>   8.View的onTouchEvent默认都会消耗事件(返回true),除非它是不可点击的(clickable和longClickable同时为false)。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。<br>   9.View的enable属性不影响onTouchEvent的默认值。哪怕一个View是diable状态的，只要他的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。<br>   10.onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。<br>   11.事件传递过程是由外向内的，即时间总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以再子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
<p>30.事件分发源码解析<br>  1.Activity点击事件的分发过程<br>   点击事件用MotionEvent来表示，当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件派发，具体的工作是由Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow.getDecorView()可以获得。我们先从Activity的dispatchTouchEvent开始分析。<br>   public boolean dispatchTouchEvent(MotionEvent ev){<br>          if(ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN){<br>              onUserInteraction();<br>          }<br>          if(getView().superDispatchTouchEvent(ev)){<br>              return true;<br>          }</p>
<pre><code>      return onTouchEvent(ev);
</code></pre>
<p>   }<br>   首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。<br>   接下来看Window是如何将事件传递给ViewGroup的。Window是个抽象类，而Window的superDispatchTouchEEvent方法也是个抽象方法，因此我们必须找到Window的实现类才行。Window的实现类是PhoneWindow。window的superDispatchTouchEvent 最后调用的是mDecor.superDIspatchTouchEvent方法。通过((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0)这种方式就可以获取Activity所设置的View，这个mDecor显然就是getWindow().getDecorView（）返回的View，而我们通过setContentViewe设置的View是它的一个子View。目前事件传递到了DecorView这里，由于DecorView继承自FrameLayout且是父View，所以最终事件会传递给View。换句话说，事件肯定会传递到View,不然应用如何响应点击事件呢。从这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。</p>
<p>  3.顶级View对点击事件的分发过程<br>   点击事件达到顶级View以后，会调用ViewGroup的dispatchTouchEvent方法，如果顶级ViewGroup拦截事件即onInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的mOnTouchEvent被设置，则onTouch方法会被调用，否则onTouchEvent会呗调用。也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvent方法。在onTouchEvent中，如果设置了mOnClickListener，则onClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此为止，事件已经从顶级View传递到了下一层View，接下来的传递过程和顶级View是一致的，如此循环，完成整个事件的分发。<br>   首先看ViewGroup对点击事件的分发过程，其主要实现在ViewGroup的dispatchTouchEvent方法中，它描述的是当前View是否拦截点击事件这个逻辑。<br>   final boolean intercepted;<br>   if(actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN || mFirstTouchTarget !&#x3D;null){<br>      final boolean disallowIntercept &#x3D; (mGroupFlags &amp; FLAG_DISALLOWINTERCEPT !&#x3D; 0 )<br>      if(!disallowIntercept){<br>         intercepted &#x3D; onInterceptTouchEvent(ev);<br>         ev.setAction(action)<br>      }else{<br>         intercepted &#x3D; false;<br>      }<br>   }else{<br>         intercepted &#x3D; true;<br>   }</p>
<p>   从代码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类型为ACTION_DOWN或者mFirstTouchTarget！&#x3D;null。ACTION_DOWN事件好理解，那么mFirstTouchTarget！&#x3D;null是什么意思呢？当事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向子元素，当ViewGroup不拦截事件并将事件交给子元素处理时mFirstTouchTarget！&#x3D;null。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget！&#x3D;null就不成立。那么当ACTION_MOVE和ACTION_UP事件到来时，由于(actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN || mFirstTouchTarget！&#x3D;null)这个条件为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其他事件就会默认交给它处理。<br>   当然，这里有一种特殊情况，那就是FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceceptTouchEvent方法来设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN意外的恶其他点击事件。为什么说是除了ACTION_DOWN以外的其他事件呢？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会充值FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。因此，当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onIntercept方法来询问自己是否要拦截事件。<br>     if(actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN){<br>        cancelAndClearTouchTargets(ev);<br>        resetTouchState();<br>     }<br>   ViewGroup会在ACTION_DOWN事件到来时做重制状态的操作，而在resetTOuchState方法中会对FLAG_DISALLOW_INTERCEPT进行充值，因此子View调用request-DisallowInterceptTouchEvent方法并不影响ViewGroup对ACTION_DOWN事件的处理。<br>   得出结论:当ViewGroup决定拦截事件后，后续的点击事件将会默认交给它处理并且不在调用它的onInterceptTouchEvent方法。<br>           FLAG_DISALLOW_INTERCEPT这个标志的作用时让ViewGroup不在拦截事件，当然前提是ViewGroup不拦截ACTION_DOWN事件。<br>      价值:第一点，onInterceptToucheEvent不是每次事件都会被调用的，如果想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用，当然前提是事件能够传递到当前的ViewGroup；<br>          第二点，FLAG_DISALLOW_INTERCEPT标记位的作用给提供了一个思路，当面对滑动冲突时，我们可以考虑用这种方法解决问题。</p>
<p>  接着再看当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View进行处理<br>      final View[] children &#x3D; mChildren;<br>      for(int i &#x3D; childrenCount - 1; i &gt;&#x3D; 0 ; i –){<br>          final int childIndex &#x3D; customOrder ? getChildDrawingOrder(chilrenCount, i) : i ;<br>          final View child &#x3D; (preorderedList &#x3D;&#x3D; null) ? children[childIndex] : preorderedList.get(childIndex);<br>          if(!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)){<br>              continue;<br>          }<br>          newTouchTarget &#x3D; getTouchTarget(child);<br>          if(newTouchTarget !&#x3D; null){<br>              newTouchTarget.pointerIdBits !&#x3D; idBitsToAssign;<br>              break;<br>          }</p>
<pre><code>  &#125;
  resetCancelNextUpFlag(child);
  if(dispatchTransformedTouchEvent(ev,false,child,idBitsToAssign))&#123;
      mLastTouchDownTime = ev.getDownTime();
      if(preorderedList != null)&#123;
         for(int j=0;j&lt;childrenCOunt ; j++)&#123;
             if(children[childIndex]==mChildren[j])&#123;
                mLastTouchDownIndex = j ;
                break;
             &#125;
         &#125;
      &#125;else&#123;
          mLastTouchDownIndex = childIndex;
      &#125;
      mLastTouchDownX = ev.getX();
      mLastTouchDownY = ev.getY();
      newTouchTarget = addTouchTarget(child, idBitsToAssign);
      alreadyDispatchedToNewTouchTarget = true ;
      break;
  &#125;
</code></pre>
<p>  上方代码逻辑：首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接受到点击事件。是否能够接受点击事件主要由两点来衡量：子元素是否在播放动画和点击事件的坐标是否落在子元素的区域内。如果某个子元素满足这两个条件，那么事件就会传递给它来处理。dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，在它的内部有如下一段内容，而在上面的恶代码中传递的不是null，因此它会直接调用子元素的dispatchTouchEvent方法，这样事件就交由子元素处理，从而完成了一轮事件分发。</p>
<pre><code>      if(child == null)&#123;
          handled = super.dispatchTouchEvent(event);
      &#125;else&#123;
          handled = child.dispatchTouchEvent(event);
      &#125;
</code></pre>
<p>   如果子元素的dipatchTouchEvent返回true，这是我们暂时不用考虑事件在子元素内部时怎么分发的，那么mFirstTouchTarget就会被赋值同时跳出for循环，<br>          newTouchTarget &#x3D; addTouchTarget(child,idBitsToAssign);<br>          alreadyDispatchedToNewTouchTarget &#x3D; true;<br>          break;<br>   这几行代码完成了mFirstTouchTarget的肤质并终止对子元素的遍历。如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素(如果还有下一个子元素的话)。<br>   其实mFirstTouchTarget真正的赋值过程是在addTouchEvent内部完成的，从下面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截测恶略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件。<br>        private TouchTarget addTouchTarget(View child,int pointerIdBits){<br>            TouchTarget target &#x3D; TouchTarget.obtain(child,pointerIdBits);<br>            target.next &#x3D; mFirstTouchTargeet;<br>        }<br>  如果遍历所有的子元素后事件都没有被合适的处理，那包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。着两种情况下，ViewGroup会自己处理点击事件。<br>        if(mFirstTouchTarget &#x3D;&#x3D; null){<br>          handled &#x3D; dispatchTransformedTouchEvent(ev,canceled,null,TouchTarget.ALL_POINTER_IDS)<br>        }<br>  这里第三个参数child为null，他会调用super.dispatchTouchEvent(event),很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理。</p>
<p>  4.View对点击事件的处理过程<br>    View对点击事件的处理过程稍微简单，注意这里的View不包含ViewGroup。<br>    public boolean dispatchTouchEvent(MotionEvent event){<br>      boolean result &#x3D; false;<br>      if(onFilterTouchEventForSecurity(event)){<br>        ListeneerInfo li &#x3D; mListenerInfo;<br>        if(li !&#x3D; null &amp;&amp; li.mOnTouchListener !&#x3D; null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) &#x3D;&#x3D; ENABLED &amp;&amp; li.mOnTOuchListener.onTouch(this,event)){<br>          result &#x3D; true;<br>        }<br>      }<br>      if(!result &amp;&amp; onTouchEvent(event)){<br>          result &#x3D; true;<br>      }<br>      return result;<br>    }<br>   View对点击事件的处理过程比较简单，因为View是一个单独的元素，他没有子元素因此无法向下传递事件，所以它只能自己处理事件。View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可以OnTouchListener的优先级高于onTouchEevent，方便在外界处理点击事件。</p>
<p>   在分析OnTouchEEveent的实现。先看当View处于不可用状态下点击事件的处理过程。不可用状态下的View照样会消耗点击事件，接管它看起来不可用。<br>      if((viewFlags &amp; ENABLE_MASK) &#x3D;&#x3D; DISABLED){<br>          if(event.getAction() &#x3D;&#x3D; MotionEveent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) !&#x3D; 0){<br>              setPressed(false);<br>          }<br>          return (((vieewFlags &amp; CLICKABLEE) &#x3D;&#x3D; CLICKABLE || (viewFlags &amp; LONG_CLICKABLE)&#x3D;&#x3D; LONG_CLICKABLE));<br>      }<br>   如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个onTouchEvent的工作机制看起来和OnTouchListener类似。<br>      if(mTouchDelegate !&#x3D; null){<br>          if(mTouchDelegate.onTouchEvent(eevent)){<br>            return true;<br>          }<br>      } </p>
<p>   下面看一下onTouchEvent中对点击事件的具体处理<br>     if(((viewFlags &amp; CLICKABLE) &#x3D;&#x3D; CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) &#x3D;&#x3D; LONG_CLICKABLE)){<br>        switch(event.getAction()){<br>          case MotionEvent.ACTION_UP:<br>            boolean prepressed &#x3D; (mPrivateFlags &amp; PFLAG_PREPRESSED) !&#x3D; 0;<br>            if((mPrivateFlags &amp; PFLAG_PRESSED) !&#x3D; 0 || prepressed){<br>                if(!mHasPerformedLongPress){<br>                  removeLongPressCallback();<br>                }<br>                if(!focusTaken){<br>                  if(mPerformClick &#x3D;&#x3D; null){<br>                    mPerformClick &#x3D; new PerformClick();<br>                  }<br>                  if(!post(mPerformClick)){<br>                    performClick();<br>                  }<br>                }<br>            }<br>        }</p>
<pre><code> &#125;

 从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEEvent方法返回true，不管它是不是DISABLEE状态，然后就是当ACTION_UP事件发生时，会出发performClick方法，如果View设置了OnClickListener，那么performClick方法回调用它的onClick方法，如下所示。
 public boolean performClick()&#123;
    final boolean result;
    final ListeenerInfo li = mListenerInfo;
    if(li != null &amp;&amp; li.mOnClickListeener != null)&#123;
      playSoundEffect(SoundEffectConstants.CLICK);
      li.mOnClickListener.onClick(this);
      result = true;
    &#125;else&#123;
      result =false;
    &#125;
    sendAccessibilityEvent(Access)
    return result;
 &#125;

View的LONG_CLICKABLE属性默认认为false，而CLICKABLE属性是否为false和具体的View有关，确切来说是可点击的Viewe其CLICKABLE为true，不可点击的View其CLICKABLE为false，比如Button是可点击的，TextView是不可点击的。通过setClickable和setLongClickable可以分别改变View的恶CLICKABLE和LONG_CLICKABLE属性。另外，setOnClickListener会自动将View的CLICKABLE设为true，setOnLongClickListener则会自动将View的LONG_CLICKABLE设为true，如下所示：
public void setOnClickListener(OnClickListener l)&#123;
    if(!isClickable())&#123;
        setClickable(true);
    &#125;
    getListenerInfo().mOnClickListener = 1;
&#125;

public void setOnLongClickListenr(OnLongClickListener l)&#123;
    if(!isLongClickable)&#123;
      setLongClickable(true);
    &#125;
    getListenerInfo().mOnLongClickListener = l;
&#125;
</code></pre>
<p>31.滑动冲突时如何产生的呢？如何解决滑动冲突呢？<br>  其实在解饿面中只要内外两层同时可以滑动，这个时候就会产生滑动冲突。</p>
<p>32.常见的滑动冲突场景<br>场景1:外部滑动方向和内部滑动方向不一致<br>场景2:外部滑动方向和内部滑动方向一致<br>场景3:上面两种情况的嵌套。<br>解决场景1:当用户左右滑动时，需要让外部的View拦截点击事件，当用户上下滑动时，需要让内部View拦截点事件。这个事件我们就可以根据它们的特征来解决滑动冲突，具体来说时：根据滑动时水平滑动还是竖直滑动来判断到底由谁来拦截事件，根据滑动过程中两个点之间的坐标就可以得出到底时水平滑动还是竖直滑动。<br>解决场景2:无法根据滑动的角度、距离差以及速度差来做判断。可以从业务上规定：当处于某种状态时需要外部View响应用户的滑动，而处于另外一种状态时则需要内部View来响应View的滑动，根据这种业务上的需求我们也能得到响应的处理规则，有了处理规则同样可以进行下一步处理。<br>解决场景3:无法直接根据滑动角度、距离差以及速度差来做判断。</p>
<p>33.如果根据坐标来得到滑动的方向？<br>   可以依据滑动路径和水平方向所形成的夹角，也可以依据水平方向和竖直方向上的距离差来判断，某些特殊时候还可以依据水平和竖直方向的速度差来做判断。</p>
<p>34.两种解决滑动冲突的方式：外部拦截法和内部拦截法。<br>  1.外部拦截法：所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题，这种方法比较符合点击事件的分发机制。外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可。</p>
<p>  public boolean onInterceptTouchEvent(MotionEveent event){<br>      boolean intercepted &#x3D; false;<br>      int x &#x3D; (int) event.getX();<br>      int y &#x3D; (int) event.getY();<br>      switch(event.getAction()){<br>        case MotionEvent.ACTION_DOWN:{<br>          intercepted &#x3D; false;<br>          break;<br>        }<br>        case MotionEvent.ACTION_DOWN:{<br>          if(父容器需要当前点击事件){<br>            intercepted &#x3D; true;<br>          }else{<br>            intercepted &#x3D; false;<br>          }<br>          break;<br>        }<br>      }<br>      mLastXInterecept &#x3D; x;<br>      mLastYInterecept &#x3D; y;<br>      return intercepted;<br>  }<br>  上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不要做修改并且也不能修改。这里对上述代码再描述一下，在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件,设置因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件无法再次传递给子元素。其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false;最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。<br>  考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接受到ACTION_UP事件，这个时候子元素中的onClick事件就无法出发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。<br>    2.内部拦截法是指父容器不拦截任何事件，所有的时间都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，使用起来较外部拦截.稍显复杂。伪代码如下，需要重写子元素的dispatchTouchEvent方法：<br>   public boolean dispatchTouchEvent(){<br>      int x &#x3D; (int) event.getX();<br>      int y &#x3D; (int) event.getY();<br>      switch(event.getAction()){<br>          case MotionEvent.ACTION_DOWN:{<br>            parent.requestDisallowInterceptTouchEvent(true);<br>            break;<br>          }<br>          case MotinoEvent.ACTION_MOVE:{<br>            int deltaX &#x3D; x - mLastX;<br>            int deltaY &#x3D; y - mLastY;<br>            if(父容器需要此类点击事件){<br>              parent.requestDisallowInterceptTouchEvent(false);<br>            }<br>            break;<br>          }<br>          case MotionEvent.ACTION_UP:{<br>            break;<br>          }<br>      }<br>      mLastX &#x3D; x;<br>      mLastY &#x3D; y;<br>      return super.dispatchTouchEvent(event);<br>   }<br>   上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面的条件即可，其他不需要做改动而且也不能有改动。除了子元素需要做处理以外，父元素也要默认拦截了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。</p>
<p> 35.为什么父容器不能拦截ACTION_DOWN事件？<br>   因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截法就无法起作用了。<br>   父元素所作的修改如下：<br>   public boolean onInterceptTouchEvent(MotionEvent event){<br>      int action &#x3D; event.getAction();<br>      if(action &#x3D;&#x3D; MotionEvent.ACTION_DOWN){<br>        return false;<br>      }else{<br>        return true;<br>      }<br>   }</p>
<p> 36.ViewRoot和DecorView的概念<br>   ViewRoot对应于ViewRootImpl类，它是链接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，代码如下：<br>    root &#x3D; new ViewRootImpl(view.getContext(),display);<br>    root.setView(view,wparams,panelParentView);</p>
<p> 37.View的绘制流程？<br>   View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽度和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制到屏幕上。<br>                    performTraversals<br>                    ViewGroup                                             View<br>                    performMeasure -&gt; measure -&gt; onMeasure               measure<br>                    performLayout -&gt; layout -&gt; onLayout                  layout<br>                    performDraw -&gt; draw -&gt; onDraw                        draw<br>   performTraversals会一次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中在performMeasure中会调用measure方法，在measure方法中会调用onMeasure方法，在onMeasure方法中则会对所有子元素进行measure过程，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程。接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的。<br>   measure过程决定了View的宽高，Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight方法来获取到View测量后的宽高，在几乎所有的情况下它都等同于View最终的宽高，但是特殊情况除外。Layout过程决定了View的四个顶点的坐标和实际的View的宽高，完成以后，可以通过getTop、getBottom、getLeft和getRight来拿到View的四个顶点位置，并可以通过getWidth和getHeight方法来拿到View额最终宽高。Draw过程则决定View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。<br>   DecorView作为顶级View，一般情况下它内部会包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分，上面是标题栏，下面是内容栏。在Activity中通过setContextView所设置的布局文件被加到内容栏中，而内容栏的id是content，因此可以链接为Activity指定布局的方法不叫setView而叫setContentView,因此布局的确加到了id为content的FrameLayout中。通过ViewGroup content &#x3D; findViewById(R.android.id.content)。通过content.getChaildAt(0)可以获取到设置的View。DecorView是一个FrameLayout，View层的事件都先经过DecorView，然后才传递给我们的View。</p>
<p> 38.理解MeasureSpec<br>   MeasureSpec参与了View的mesasure过程，很大成都上决定了一个View的尺寸规格，这个过程还受父容器的影响，因此父容器影响View的MeasureSpec的创建过程。在测量过程中，系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec，然后在根据这个measureSpec来测量出View的宽高。<br>   MeasureSpec代表一个32位int值，高2为代表SpecMode，低30位代表SpecSize,SpecMode是值测量模式，而SpecSize是指在某种测量模式下的规格大小。<br>    private static final int MODE_SHIFT &#x3D; 30;<br>    private static final int MODE_MASK &#x3D; 0x3 &lt;&lt; MODE_SHIFT;<br>    public static final int UNSPECIFIED &#x3D; 0 &lt;&lt; MODE_SHIFT;<br>    public static final int EXACTLY &#x3D; 1 &lt;&lt; MODE_SHIFT;<br>    public static fianl int AT_MOST &#x3D; 2 &lt;&lt; MODE_SHIFT;</p>
<pre><code>public static int makeMeasureSpec(int size, int mode)&#123;
      if(sUseBrokenMakeMeasureSpec)&#123;
        return size + mode;
      &#125;else &#123;
        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);
      &#125;
&#125;

public static int getMode(int measureSpecc)&#123;
  return (measureSpec &amp; MODE_MASK);
&#125;

public static int getSize(int measureSpec)&#123;
  return (measureSpec &amp; ~MODE_MASK);
&#125;

MeasureSpec通过SpecMode 和 SpecSize打包成一个int值来避免过的多的对象内存分配，为了方便操作，其提供了打包和解包方法。SpecMode和SpecSize也是一个int值，一组SpecMode和SpecSize可以打包为一个MeasureSpec，而一个MeasureSpec可以通过解包的形式来得出其原始的SpecMode和SpecSize，需要注意的是这里提到的MeasureSpec是指MeasureSpec所代表的int值，而并非MeasureSpec本身。

UNSPECIFIED： 父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。
ExACTLY：父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。
AT_MOST：父容器指定了一个可用大小即SpecSize,View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。
</code></pre>
<p> 39.MeasureSpec和LayoutParams的对应关系<br>    系统内部是通过MeasureSpec来进行View的测量，但是正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParams。在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应额MeasureSpec，然后在根据这个MeasureSpec来确定View测量后的宽高。需注意，MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽高。对于顶级View(即DecorView)和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同决定，对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽高。<br>    对于DecorView来说，在ViewRootImpl中的measureHierarchy方法中有如下代码，它展示了DecorView的MeasureSpec的创建过程，其中desiredWindowWidth和desiredWindowHeight是屏幕的尺寸：<br>    childWidthMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowWidth, lp.width);<br>    childHeightMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowHeight, lp.height);<br>    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<br>    接着看一下getRootMeasureSpec方法的实现：<br>    private static int getRootMeasureSpec(int windowSize,int rootDimension){<br>      int measureSpec;<br>      switch(rootDimension){<br>        case ViewGroup.LayoutParams.MATCH_PARENT:<br>        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);<br>        case ViewGroup.LayoutParams.WRAP_CONTENT:<br>        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);<br>        default:<br>        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);<br>      }<br>      return measureSpec;<br>    }<br>    通过上述代码，DecorView的MeasureSpec的产生过程就很明确了，具体来说其遵守如下规则，根据它的LayoutParms中额宽高的参数来划分。<br>    LayoutParams.MATCH_PARENT:精确模式，大小就是窗口的大小。<br>    LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小。<br>    固定大小:精确模式，大小为LayoutParams中指定的大小。<br>    对于普通View来说，这里是指我们布局中的View，View的measure过程由ViewGroup传递而来，看下ViewGroup的measureChildWithMargins方法：<br>    public static int getChildMeasureSpec(int spec, int padding, int chaildDimension){<br>        int specMode &#x3D; MeasureSpec.getMode(spec);<br>        int specSize &#x3D; MeasureSpec.getSize(spec);<br>        int size &#x3D; Math.max(0,specSize - padding);<br>        int resultSize &#x3D; 0 ;<br>        int resultMode &#x3D; 0 ;<br>        switch(specMode){<br>          case MeasureSpec.EXACTLY:<br>            if(childDimension &gt;&#x3D; 0){<br>              resultSize &#x3D; childDimension;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimensiong &#x3D;&#x3D; LayoutParams.MATCH_PARENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.AT_MOST;<br>            }<br>          break;<br>          case MeasureSpec.AT_MOST:<br>             if(childDimension &gt;&#x3D; 0){<br>              resultSize &#x3D; childDimension;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimensiong &#x3D;&#x3D; LayoutParams.MATCH_PARENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.AT_MOST;<br>            }else if(childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.AT_MOST;<br>            }<br>          break;<br>          case MeasureSpec.UNSPECIFIED:<br>             if(childDimension &gt;&#x3D; 0){<br>              resultSize &#x3D; childDimension;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimensiong &#x3D;&#x3D; LayoutParams.MATCH_PARENT){<br>              resultSize &#x3D; 0;<br>              resultMode &#x3D; MeasureSpec.UNSPECIFIED;<br>            }else if(childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT){<br>              resultSize &#x3D; 0;<br>              resultMode &#x3D; MeasureSpec.UNSPECIFIED;<br>            }<br>          break;<br>        }<br>        return MeasureSpec.makeMeasureSpecc(resultSize, resultMode);<br>    }<br>    它的作用是根据父容器的MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，此参数中的padding是指父容器中已占用的空间大小，因此子元素可用的大小为父容器的尺寸减去padding，代码如下：<br>    int specSize &#x3D; MeasureSpec.getSize(spec);<br>    int size &#x3D; Math.max(0, specSize - padding);</p>
<p>  40.View的工作流程？<br>     View的工作流程主要是指measure、layout、draw这三大的流程，即测量、布局和绘制，其中measure确定View的测量宽高，layout确定View的最终宽高的四个顶点的位置，而draw则将View绘制到屏幕上。<br>     measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子元素的measure方法，各个子元素在递归去执行这个流程。<br>     1.View的measure过程<br>       view的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这个方法子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，onMeasure方法如下：<br>       protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){<br>          setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec, getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)));<br>       }<br>       setMeasuredDimension方法会设置View宽高的测量值，因此需要看getDefaultSize这个方法即可：<br>       public static int getDefaultSize(int size, int measureSpec){<br>        int result &#x3D; size;<br>        int specMode &#x3D; MeasureSpec.getMode(measureSpec);<br>        int specSize &#x3D; MeasureSPec.getSize(measureSpec);<br>        switch(sspecMode){<br>            case MeasureSpec.UNSPECIFIED:<br>            result &#x3D; size;<br>            break;<br>            case MeasureSpec.AT_MOST:<br>            case MeasureSpec.EXACTLY:<br>            rersult &#x3D; specSize；<br>            break;<br>            rerturn result;<br>        }<br>       }<br>        可以看出，getDefaultSize这个方法逻辑很简单，我们只需要看AT_MOST和.EXACTLY这种情况。简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。<br>    View的宽高由specSize决定，所以我们可以得出如下结论，直接继承View的自定义空间需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。</p>
<p>  41.getSuggestedMinimumWidth大的逻辑？<br>     如果View没有设置背景那么返回android:minWidth这个属性所指定的值，这个值可以为0，如果View设置了背景，则返回android：minWidth和背景的最小宽度这两者中的最大值，getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值就是View的UNSPECIFIED情况下的测量宽高。   </p>
<p>  42.ViewGroup的measure过程<br>     对于ViewGroup来说，除了完成自己的measure过程外，还会遍历去调用所有子元素的measure方法，各个子元素在递归去执行这个过程。和View不同的时，ViewGroup时一个抽象类，因此它没有重写View的onMeasure方法，但是它提供了一个较measureChildren的方法<br>     protected void measureChildren(int widthMeasureSpec,int heightMeasureSpec){<br>      final int size &#x3D; mChildrenCount;<br>      final View[] children &#x3D; mChildren;<br>      for(int i &#x3D; 0; i &lt; size ; ++i){<br>         final View child &#x3D; children[i];<br>         if((child.mViewFilags &amp; VISIBILITY_MASK) !&#x3D; GONE){<br>            measureChild(child,widthMeasureSpec,heightMeasureSpec);<br>         }<br>      }<br>     }<br>     从上述代码来看，ViewGroup在measure时，会对每一个子元素进行measure，measureChild这个方法的实现也很好理解，<br>     protected void measureChild(View child,int parentWidthMeasureSpec, int parentHeightMeasureSpec){<br>      final LayoutParams lp &#x3D; child.getLayoutParams();<br>      final int childWidthMeasureSpec &#x3D; getChildMeasureSpec(parentWidth-MeasureSpec,mPaddingLeft+mPaddingRight,lp.width);<br>      final int childHeightMeasureSpec &#x3D; getChildMeasureSpec(parentHeight - MeasureSpec,mPaddingTop + mPaddingBottom , lp.height);<br>      child.measure(childWidthMeasureSpec , childHeightMeasureSpec);<br>     }<br>     measureChild 的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量。getChildMeasureSpec的工作已经再上面进行了详细分析。<br>     ViewGroup并没有定义其测量的具体过程，这是因为ViewGroup时一个抽象类，其测量过程的onMeasure方法需要哥哥子类去具体实现，比如LinearLayout、RelativeLayout等，为什么ViewGroup不像View一样对其onMeasure方法做同意的实现呢？那是因为不同的ViewGroup子类有不同的布局特征，这导致他们的测量细节各不相同，比如LinearLayout、RelativeLayout这两者布局特性显然不同，因此ViewGroup无法做统一实现。</p>
<p>  43.比如我们想再Activity已启动的时候做一件任务，但是这个一件任务需要获取某个View的宽高，再onCreate或者onResume里面获取这个View的宽高可以么？<br>     实际上onCreate、onStart、onResume中均无法正确得到某个View的宽高信息，这是因为View的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证Activity执行了onCreate、onStart、onResume时某个View已经测量完毕了，如果View还没有测量完毕，那么获取到的宽高就是0.<br>     1.Activity&#x2F;View#onWindowFocusChanged<br>       onWindowFocusChanged这个方法的含义是：View已经初始化完毕了，宽高已经准备好了，这个时候去获取宽高是没问题的。需要注意的是，onWindowFocusChanged会被调用多次，当Activity的窗口地道道焦点和失去焦点时均会被调用一次。具体来说，当Activity继续执行和暂停执行时，onWindowFocusChanged均会被调用，如果频繁的进行onResume和onPause，那么onWindowFousChanged也会被频繁地调用。<br>       public void onWindowFocusChanged(boolean hasFocus){<br>          super.onWindowFocusChanged(hasFocus);<br>          if(hasFous){<br>            int widht &#x3D; view.getMeasuredWidth();<br>            int height &#x3D; view.getMeasuredHeight();<br>          }<br>       }<br>     2.view.post(runnable)<br>      通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View也已经初始化好了。<br>       protected void onStart(){<br>         super.onStart();<br>         view.post(new Runnable(){</p>
<pre><code>          public void run()&#123;
            int widht = view.getMeasuredWidth();
            int height = view.getMeasureHeight();
          &#125;

      &#125;);
   &#125;
 3.ViewTreeObserver。
  使用ViewTreeObserver的众多回调可以完成这个功能，比如使用OnGlobalLayoutListener这个几口，当View树的状态发生改变或者View树内部的View的可见性发生改变时，onGlobalLayout方法将被回调，因此这是获取View的宽高一个很好的实际。需要注意的是，伴随着View树的状态改变等。onGlobalLayout会被调用多次。
   protected void onStart()&#123;
        super.onStart();
        ViewTreeObserver observer = view.getViewTreeObserver();
        observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener()&#123;
                  public void onGlobalLyout()&#123;
                    view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                    int width = view.getMeasuredWidht();
                    itn height = view.getMeasuredHeight();
                  &#125;
          &#125;);

   &#125;

 4.view.measeure(int widthMeasureSpec, int heightMeasureSpec).
   通过手动对View进行measure来得到View的宽高。这种方法比较复杂，这里要分情况处理，根据View的LayoutParams来分：
   match_parent:
    直接放弃，无法measure出具体的宽高。原因很简单，根据View的measure过程，构造此种MeasureSpec需要知道parentSize，即父容器的剩余空间，而这个时候我们无法知道parentSize的大小，所以理论上不可能测量出View的大小。
   具体的数值：
    比如宽高都是100px，如下measure：
    int widthMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);
    int heightMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);
    view.measure(widthMeasureSpec, heightMeasureSpec);
   wrap_content:
    int widthMeasureSpec = MeasureSpec.makeMeasureSpec((1&lt;&lt;30) - 1, MeasureSPec.AT_MOST);
    int heightMeasureSpec = MeasureSpec.makeMeasureSpec((1&lt;&lt;30) - 1, MeasureSPec.AT_MOST);
</code></pre>
<p>  44.layout过程<br>    Layout的作用时ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它再onLayout中会遍历所有的子元素并调用其layout方法，再layout方法中onLayout方法会被调用。Layout过程和measure过程相比就简单多了，layout方法确定View本省的位置，而onLayout方法则会确定所有子元素的位置，先看View的layout方法，如下所示：<br>      public void layout(int l, int t, int r ,int b){<br>          if((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0){<br>              onMeasure(mOldWidthMeasureSpec , mOldHeightMeasureSpec);<br>              mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>          }<br>        int oldL &#x3D; mLeft;<br>        int oldT &#x3D; mTop;<br>        int oldB &#x3D; mBotytom;<br>        int oldR &#x3D; mRight;<br>        boolean changed &#x3D; isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l,t,r,b);<br>        if(changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED)){<br>            onLayout(changed, l, t, r, b);</p>
<pre><code>    &#125;
  &#125;
layout方法的大致流程如下：时首先会通过setFrame方法来设定View的四个顶点的位置，即初始化mLeft、mRight、mTop和mBottom这四个值，View的四个顶点一旦确定，那么View在父容器中的位置也就确定了，接着会调用onLayout方法，这个方法的用途时父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正实现onLayout方法。
  protected void onLayout(boolean changed, int l,int t, int r, int b)&#123;
        if(mOrientation == VERTICAL)&#123;
          layoutVertical(l, t, r, b);
        &#125;else&#123;
          layoutHorizontal(l, t, r, b);
        &#125;
  &#125;
LinearLyout中onLayout的实现逻辑和onMeasure的实现逻辑类似，这里选择layoutVertical继续讲解
  void layoutVertical(int left, int top, int right, int bottom)&#123;
      final int count = getVirtualChildCount();
      for(int i = 0; i &lt; count; i++)&#123;
          final View child = getVirtualChildAt(i);
          if(child == null)&#123;
              childTop += measureNullChild(i);
          &#125;else if(child.getVisibility() != GONE)&#123;
              final int childWidth = child.getMeasuredWidth();
              final int childHeight = child.getMeasuredHeight();
              final LinearLayout.LayoutParams lp = (LinearLayout.LayoutPaarams) child.getLayoutParams();
              if(hasDividerBeforeChildAt(i))&#123;
                  childTop += mDividerHeight;
              &#125;
              childTop += lp.topMargin;
              setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);
              childTop += childHeight + lp.bottomMargin + getNextLocation - Offset(child);
              i += getChildrenSkipCount(child,i);
          &#125;
      &#125;
  &#125;
 这里分析一下layoutVertical的代码逻辑，可以看到，此方法会遍历所有子元素并调用setChildFrame方法来为子元素指定相应的位置，其中childTop会逐渐增大，这就意味着后面的子元素会被放置靠下的位置，这刚好符合竖直防线的LinearLayout的特性。至于setChildFrame，它仅仅时调用子元素的layout方法而已，这样父元素在layout方法中完成自己的定位以后，就通过onLayout方法去调用子元素的layout方法，子元素会通过自己的layout方法来确定自己的位置，这样一层一层地传递下去就完成了整个View树的layout过程。setChildFrame方法的实现如下所示。
  private void setChildFrame(View child, int left, int top, int width, int height)&#123;
      child.layout(left, top, width, height);
  &#125;
 setChildFrame中的width和height实际上就是子元素的测量宽高，从下面的代码可以看出这一点：
 final int childWidth = child.getMeasuredWidth();
 final int childHeight = child.getMeasuredHeight();
 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);
 而在layout方法中会通过setFrame去设置子元素的四个顶点的位置，在setFrame中有如下几句赋值语句，这样以来子元素的位置就确定了：
 mLeft = left;
 mTop = top;
 mRight = right;
 mBottom = bottom;
</code></pre>
<p>   45.View的测量宽高和最终宽高有什么区别？View的getMeasuredWidth 和 getWidth这两个方法有什么区别？<br>     看一下getWidth 和 getHeight 这两个方法的具体实现:</p>
<pre><code>   public final int getWidth()&#123;
      return mRight - mLeft;
   &#125;  

   public final int getHeight()&#123;
      return mBottom - mTop;
   &#125;
  从getWidth和getHeight的源码在结合mLeft、mRight、mTop和mBottom这四个变量的复制过程来看，getWidth方法的返回值刚好就是View的测量宽度，而getHeight方法的返回值也刚好就是View的测量高度。经过上述分析，在View的默认实现中，View的测量高度和最终的宽高时相等的，只不过测量宽高形成于View的measure过程，而最终的宽高形成于View的layout过程，即两者复制实际不同，测量宽高的复制时机稍微早一些。可以认为View的测量宽高就等于最终宽高，但是的却存在有些特殊情况下会导致两者不一致。
  如果重写View的layout方法，代码如下：
     public void layout(int l ,int t, int r, int b)&#123;
        supre.layout(l, t, r + 100, b + 100);
     &#125;
  上述代码会导致任何情况下View的最终宽高总是比测量宽高大100px，虽然这样做会导致View显示不正常并且也没有实际意义，但是这证明了测量宽高的确可以不等于最终宽高。另外一种情况是在某些情况下，View需要多次measure才能确定自己的测量宽高，在前几次的从测量过程中，其得到的测量宽高有可能和最终宽高不一致，但最终来说，测量宽高还是和最终宽高相同。

46.draw过程
  Draw过程就比较简单了，它的作用是将View会知道屏幕上面。View的绘制过程遵循如下几步：
  1.绘制背景background.draw(canvas)
  2.绘制自己onDraw
  3.绘制children(dispatchDraw)
  4.绘制装饰(onDrawScrollBars)
  这一点通过draw方法的源码可以明显看出来
  public void draw(Canvas canvas)&#123;
    final int privateFlags = mPrivateFlags ;
    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PGLAG_DRAWN;
    //Step1. draw the backgroud ,if needed
    int saveCount;
    if(!dirtyOpaque)&#123;
        drawBackgroud(canvas);
    &#125; 
    final int viewFlags = mViewFLags;
    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges =  (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
    if(!verticalEdges &amp;&amp; !horizontalEdges)&#123;
      //Step 3 draw the content
      if(!dirtyOpaque) onDraw(canvas);
      //Step 4 draw decorations(scrollbars)
      onDrawScrollBars(canvas);
      if(mOverlay != null &amp;&amp; !mOverlay.isEmpty())&#123;
          mOverlay.getOverlayView().dispatchDraw(canvas);
      &#125;
      return;
    &#125;

  &#125;
 View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会便利调用所有子元素的draw方法，如此draw时间就一层层地传递了下去。View有一个特殊地方法setWillNotDraw，如下：
 public void setWillNotDraw(boolean willNotDraw)&#123;
    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);
 &#125;
 从setWillNotDraw这个方法地注释中可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启动这个优化标记位。这个标记位对实际开发的意义是：当我们的自定义控制继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显示的关闭WILL_NOT_DRAW这个标记位。

47.自定义VIew的分类
  1.继承View重写onDraw方法
    这种方法主要用于实现一些不规则的效果，即这种效果不方便通过布局的组合方式来达到，往往需要静态或者动态的显示一些不规则的图形。很显然需要通过绘制的方式来实现，即重写onDraw方法。采用这种方式需要自己支持wrap_content，并且padding也需要自己处理。
  2.继承ViewGroup派生特殊的Layout
    这种方式主要用于实现自定义的布局，即除了LinearLayout、RelativeLayout、FrameLayout这种系统的布局之外，我们重新定义一种新布局，当某种效果看起来很像集中View组合在一起的时候，可以采用这种方法来实现。采用这种方式稍微复杂一些，需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。
  3.继承特定的View                                   
    一般时用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现。这种方法不需要自己支持wrap_content和padding等。
  4.继承特定的ViewGroup
    这种方法也比较常见，当某种效果看起来很像集中View组合在一起的时候，可以采用这种方法来实现。采用这种方法不需要自己处理ViewGroup的测量和布局这两个过程。需要注意这种方法和方法2的区别，一般来说方法2能实现的效果方法4也都能实现，两者的主要差别在于方法2更接近View的底层。

 48.自定义View过程中的一些注意事项
    1.让View支持wrap_content
      支持因为支持继承View或者ViewGroup的控制，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。
    2.如果有必要，让你的View支持padding
      这是因为支持继承View的控件，如果不在draw方法中处理padding，那么padding属性时无法起作用的。直接继承自ViewGroup的控制需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。
    3.尽量不要在View中使用Handler,没必要
      这是因为View内部本身就提供了post系列的方法，完全可以替代Hanlder的作用。
    4.View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow
      如果有线程或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。当包含此View的Activity退出或者当前View被remove 时，View的onDetachedFromWindow方法会被调用，和此方法对应的时onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄露。
    5.View带有华东嵌套情形时，需要处理好滑动冲突
      如果有滑动冲突的话，那么要合适的处理华东冲突，否则将会严重影响View的效果。 
  
</code></pre>
<p>  49.AppWidgetProvider是Android中提供的用于实现桌面小部件的类，其本质是一个广播，即BroadcastReceiver。</p>
<p>  50.PendingIntent和Intent的区别是什么？<br>     PendingIntent表示一种处于pending状态的意图，而pending状态表示的是一种待定、等待、即将发生的意思，就是说接下来有一个Intent将在某个待定时刻发生。PendingIntent和Intent的区别在于，PendingIntent是在将来的某个不确定的时刻发生，而Intent是立刻发生。</p>
<p>  51.PendingIntent匹配规则？<br>     如果两个PendingIntent他们内部的Intent相同并且requestCode也相同，那么这两个PendingIntent就是相同的。requestCode相同比较好理解，那么什么情况下Intent相同呢？Intent的匹配规则是：如果两个Intent的ComponentName和intent-filter都相同，那么这两个Intent就是相同的。需要注意的是Extras不参与Intent的匹配过程，只要Intent之间的ComponentName和intent-filter相同，即使他们的Extras不同，那么这两个Intent样式相同的。</p>
<p>  52.PendingIntent中flags参数的含义？<br>     1.FLAG_ONE_SHOT：当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel，如果后续还有相同的PendingIntent，那么他们的send方法就会调用失败。对于通知栏消息来说，如果采用此标记位，那么同类的通知只能使用一次，后续的通知点击后将无法打开。<br>     2.FLAG_NO_CREATE：当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity、getService和getBroadcast方法会直接返回null，即获取PendingIntent失败。这个标记位很少见，它无法单独使用。<br>     3.FLAG_CANCEL_CURRENT：当前描述的PendingIntent如果已经存在，那么他们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些被cancel的消息单机后 将无法打开。<br>     4.FLAG_UPDATE_CURRENT：当前描述的PendingIntent如果已经存在，那么他们都会被更新，即他们的Intent中的Extras会被替换成最新的。</p>
<p>  53.通知栏和桌面小部件分别由NotificationManager和AppWidgetManager管理，而NotificationManager和AppWidgetManager通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetService进行通讯。因此可见，通知栏和桌面小部件中的布局文件实际上是在NotificationManagerService以及AppWidgetService中被加载的，而他们运行在系统的SystemServer中，这就和我们的进程构成了跨进成通讯的场景。</p>
<p>  54.RemoteViews的apply以及reapply方法来家在活着更新界面的，apply和reApply的却别在与：apply会家在布局并更新界面，而reApply则只会更新界面。通知栏和桌面小插件在初始化界面时会调用apply方法，而在后续的更新界面时则会调用reapply方法。</p>
<p>WindowManager所提供的功能很简单，常用的只有三个方法，即添加View、更行View和删除View，这三个方法定义在ViewManager中，而WindowManager继承了ViewManager<br>public interfacce ViewManager{<br>  public void addView(View view, ViewGroup.LayoutParams params);<br>  public void updateViewLayout(View view,ViewGroup.LayoutParams params);<br>  public void removeView(View view);<br>}</p>
<p>Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此此Window并不是实际存在的，它是以View的形式存在。</p>
<p>Window的添加过程<br>  Window的添加过程需要通过WindowManager的addView来实现，WindowManager是一个接口，它的真正实现是WindowManagerImpl类。在WindowManagerImpl中Window的三大操作的实现如下：<br>  public void addView(View view, ViewGroup.LayoutParams params){<br>    mGlobal.addView(view, params, mDisplay, mParentWindow);<br>  }</p>
<p>  public void updateViewLayout(View view, ViewGroup.LayoutParams params){<br>    mGlobal.updateViewLayout(view, params);<br>  }</p>
<p>  public void remoteView(View view){<br>    mGlobal.removeView(view, false);<br>  }<br>  WindowManagerImpl并没有直接实现Window的三大操作，二十交割WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实力，在WindowManagerGlobal中有以下代码：private final WindowManagerGLobal mGlobal &#x3D; WindowManagerGlobal。getInstance()。WindowManagerImpl这种工作模式是典型的桥接模式，将所有的操作全部委托给WindowMangerGlobal来实现。WindowManagerGlobal的addView方法主要分为如下几步。<br>  1.检查参数是否合法，如果是子Window那么还需要调整一些布局参数<br>    if(view &#x3D;&#x3D; null){<br>      throw new IllegalArgumentException(“view must not be null”);<br>    }<br>    if(display &#x3D;&#x3D; null){<br>      throw new IllegalArgumentException(“display must not be null”);<br>    }<br>    if(!(params instanceof WindowManager.LayoutParams)){<br>      throw new IllegalArgumentException(“Params must be WindowManager.LayoutParams”);<br>    }<br>    final WindowManager.LayoutParams wparams &#x3D; (WindowManger.LayoutParams)params;<br>    if(parentWindow !&#x3D; null){<br>      parentWindow.adjustLayoutParamsForSubWindow(wparams);<br>    }<br>   2.创建ViewRootImpl并将View添加到列表中<br>   在WindowMangerGlobal内部有如下几个列表比较重要：<br>   private final ArrayList<View> mViews &#x3D; new ArrayList<View>();<br>   private final ArrayList<ViewRootImpl> mRoots &#x3D; new ArrayList<ViewRootImpl>();<br>   private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams &#x3D; new ArrayList&lt;WindowManager.LayoutParams&gt;();<br>   private final ArraySet<View> mDyingViews &#x3D; new ArraySet<View>();</p>
<p>   在上面生命中，mViews存储的是所有Window所对应的View，mRoots存储的是所有Window所对应的ViewRootImpol，mParams存储的是素有Window所对应的布局参数，而mDyingViews则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象。在addView中通过如下方式将Window的乙烯利列对象添加到列表中：<br>    root &#x3D; new ViewRootImpl(view.getContext(), display);<br>    view.setLayoutParams(wparams);<br>    mViews.add(view);<br>    mRoots.add(root);<br>    mParams.add(wparams);<br>   3.通过ViewRootImpl来更新界面并完成Window的添加过程<br>    这个步骤由ViewRootImpl的setView方法来完成，View的绘制过程是由ViewRootImpl来完成的。在setView内部会通过requestLayout来完成异步刷新请求。scheduleTraversals实际是View绘制的入口：<br>    public void requestLayout(){<br>      if(!mHandlingLayoutInLayoutRequest){<br>        checkThread();<br>        mLayoutRequested &#x3D; true;<br>        scheduleTraversals();<br>      }<br>    }</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Anroid开发艺术探究</p><p><a href="https://moruoyiming.github.io/2022/08/06/【Android基础】Android开发艺术探究/">https://moruoyiming.github.io/2022/08/06/【Android基础】Android开发艺术探究/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://moruoyiming.github.io"><p>Brigitte Jian</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-08-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2023/02/28/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6MD5%E5%80%BC/" target="_blank">获取签名文件MD5</a><br></span><span>  2.<a class="is-size-6" href="/2023/02/21/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91android%20EditText%20%E9%99%90%E5%AE%9A%E4%B8%AD%E6%96%87%E4%B8%AA%E6%95%B0%E4%B8%8E%E8%8B%B1%E6%96%87%E4%B8%AA%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/" target="_blank">android EditText 限定中文个数与英文个数的解决方式</a><br></span><span>  3.<a class="is-size-6" href="/2023/02/21/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E4%BD%BF%E7%94%A8adb%E5%AF%BC%E5%87%BA%E6%9F%90%E4%B8%AAapp/" target="_blank">使用adb导出某个app</a><br></span><span>  4.<a class="is-size-6" href="/2022/08/11/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E6%9F%A5%E7%9C%8B%20Android%20%E6%89%8B%E6%9C%BA%E7%9A%84%20CPU%20%E6%9E%B6%E6%9E%84/" target="_blank">查看 Android 手机的 CPU 架构</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/11/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/" target="_blank">Android 事件分发流程</a><br></span><span>  6.<a class="is-size-6" href="/2022/08/06/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E5%AE%89%E8%A3%85apk%E6%8F%90%E7%A4%BAFailure%20%5BINSTALL_FAILED_TEST_ONLY%20%20installPackageL/" target="_blank">安装apk提示Failure [INSTALL_FAILED_TEST_ONLY/ installPackageL</a><br></span><span>  7.<a class="is-size-6" href="/2022/08/06/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91Gradle%E7%BC%96%E8%AF%91%20Build%20output%20%E4%B9%B1%E7%A0%81/" target="_blank">Gradle编译Build output乱码</a><br></span><span>  8.<a class="is-size-6" href="/2022/08/06/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91CoordinatorLayout%20%E4%B8%8Eviewpage%20%E4%BD%BF%E7%94%A8%20viewpager%20%E5%86%85%E5%A6%82%E4%BD%95%E7%A9%BA%E5%87%BA%20%E9%AB%98%E5%BA%A6/" target="_blank">CoordinatorLayout 与viewpage 使用 viewpager 内如何空出子布局高度</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay-reward-image.jpeg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat-reward-image.jpeg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/08/06/%E3%80%90%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF%E3%80%91Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">git常用命令</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/08/06/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"><span class="level-item">应用程序返回按键执行流程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '210a42db6c618854d687f80f2855d9ab',
            repo: 'blog_comment',
            owner: 'moruoyiming',
            clientID: '0a38ab32555c76be3797',
            clientSecret: '7cb234d7b83231df989dd8eac82fadef6d150a7f',
            admin: ["moruoyiming"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/favicon.jpg" alt="简则易从"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">简则易从</p><p class="is-size-6 is-block">书山有路勤为径，学海无涯苦作舟</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">108</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">223</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/moruoyiming" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Youtube" href="https://www.youtube.com/channel/UCemLDs1nqPnjHN04JCNtmbg"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/accounts/login/?next=/jianzeyicong/"><i class="fab fa-instagram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="500px" href="https://500px.com/p/moruoyiming123?view=photos"><i class="fab fa-500px"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://zhs.center/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">狗急跳墙</span></span><span class="level-right"><span class="level-item tag">zhs.center</span></span></a></li><li><a class="level is-mobile" href="https://www.androiddevtools.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓工具</span></span><span class="level-right"><span class="level-item tag">www.androiddevtools.cn</span></span></a></li><li><a class="level is-mobile" href="http://androidxref.com/6.0.0_r1/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓源码</span></span><span class="level-right"><span class="level-item tag">androidxref.com</span></span></a></li><li><a class="level is-mobile" href="http://idea.lanyus.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">IDEA破解</span></span><span class="level-right"><span class="level-item tag">idea.lanyus.com</span></span></a></li><li><a class="level is-mobile" href="https://www.atool99.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线接口</span></span><span class="level-right"><span class="level-item tag">www.atool99.com</span></span></a></li><li><a class="level is-mobile" href="http://www.bejson.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线解析</span></span><span class="level-right"><span class="level-item tag">www.bejson.com</span></span></a></li><li><a class="level is-mobile" href="https://tinypng.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">图片压缩</span></span><span class="level-right"><span class="level-item tag">tinypng.com</span></span></a></li><li><a class="level is-mobile" href="https://wallpapershome.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">高清壁纸</span></span><span class="level-right"><span class="level-item tag">wallpapershome.com</span></span></a></li><li><a class="level is-mobile" href="https://www.nunuyy2.org/dianying/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线电影</span></span><span class="level-right"><span class="level-item tag">www.nunuyy2.org</span></span></a></li><li><a class="level is-mobile" href="https://www.4ksj.com/forum-2-1.html" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">4K电影</span></span><span class="level-right"><span class="level-item tag">www.4ksj.com</span></span></a></li><li><a class="level is-mobile" href="https://cli.im/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">草料二维码</span></span><span class="level-right"><span class="level-item tag">cli.im</span></span></a></li><li><a class="level is-mobile" href="https://www.waitsun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MAC应用</span></span><span class="level-right"><span class="level-item tag">www.waitsun.com</span></span></a></li><li><a class="level is-mobile" href="https://file.wikileaks.org/file/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">暗网</span></span><span class="level-right"><span class="level-item tag">file.wikileaks.org</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%A4%A9%E5%B9%B2%E5%9C%B0%E6%94%AF/"><img src="/gallery/thumbnails/plant.jpg" alt="天干"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-02T13:55:59.218Z">2024-03-02</time></p><p class="title"><a href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%A4%A9%E5%B9%B2%E5%9C%B0%E6%94%AF/">天干</a></p><p class="categories"><a href="/categories/%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4/">阴阳风水</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%90%84%E8%B7%AF%E4%BB%99%E5%AE%B6%E4%BD%93%E6%84%9F/"><img src="/gallery/thumbnails/plant.jpg" alt="各路仙家体感"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-02T13:55:04.868Z">2024-03-02</time></p><p class="title"><a href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%90%84%E8%B7%AF%E4%BB%99%E5%AE%B6%E4%BD%93%E6%84%9F/">各路仙家体感</a></p><p class="categories"><a href="/categories/%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4/">阴阳风水</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/02/28/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6MD5%E5%80%BC/"><img src="/gallery/thumbnails/image1.jpg" alt="获取签名文件MD5"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-28T13:22:29.194Z">2023-02-28</time></p><p class="title"><a href="/2023/02/28/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6MD5%E5%80%BC/">获取签名文件MD5</a></p><p class="categories"><a href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/02/28/%E3%80%90%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86%E3%80%91%E8%B6%8A%E7%8B%B1%E7%AC%AC%E4%B8%80%E5%AD%A3/"><img src="/gallery/thumbnails/image1.jpg" alt="越狱 第一季 Prison Break Season 1"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-28T13:22:19.654Z">2023-02-28</time></p><p class="title"><a href="/2023/02/28/%E3%80%90%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86%E3%80%91%E8%B6%8A%E7%8B%B1%E7%AC%AC%E4%B8%80%E5%AD%A3/">越狱 第一季 Prison Break Season 1</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86/">经典影视</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/02/21/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91android%20EditText%20%E9%99%90%E5%AE%9A%E4%B8%AD%E6%96%87%E4%B8%AA%E6%95%B0%E4%B8%8E%E8%8B%B1%E6%96%87%E4%B8%AA%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"><img src="/gallery/thumbnails/desert.jpg" alt="android EditText 限定中文个数与英文个数的解决方式"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-21T12:26:14.508Z">2023-02-21</time></p><p class="title"><a href="/2023/02/21/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91android%20EditText%20%E9%99%90%E5%AE%9A%E4%B8%AD%E6%96%87%E4%B8%AA%E6%95%B0%E4%B8%8E%E8%8B%B1%E6%96%87%E4%B8%AA%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/">android EditText 限定中文个数与英文个数的解决方式</a></p><p class="categories"><a href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Android基础</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/"><span class="level-start"><span class="level-item">应用软件</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"><span class="level-start"><span class="level-item">知识积累</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"><span class="level-start"><span class="level-item">科学上网</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%88%E8%BA%AB%E6%88%90%E9%95%BF/"><span class="level-start"><span class="level-item">终身成长</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86/"><span class="level-start"><span class="level-item">经典影视</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"><span class="level-start"><span class="level-item">经典电影</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">结构算法</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4/"><span class="level-start"><span class="level-item">阴阳风水</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"><span class="level-start"><span class="level-item">面试宝典</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">90</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">45</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zygote/"><span class="tag">Zygote</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gradle/"><span class="tag">gradle</span><span class="tag is-grey-lightest">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SystemServer/"><span class="tag">SystemServer</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mac%E7%B3%BB%E7%BB%9F/"><span class="tag">Mac系统</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"><span class="tag">冒泡排序</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="tag">面试题</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ActivityManagerNative/"><span class="tag">ActivityManagerNative</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bt/"><span class="tag">bt</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"><span class="tag">史茅革</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%92%95%E5%99%9C/"><span class="tag">咕噜</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"><span class="tag">壁纸路径</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"><span class="tag">意外之旅</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%92%E7%81%B5/"><span class="tag">戒灵</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"><span class="tag">指环王</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"><span class="tag">比尔博·巴金斯</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%82%8E%E9%AD%94/"><span class="tag">炎魔</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%98%E9%81%93%E5%A4%AB/"><span class="tag">甘道夫</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E7%81%B5/"><span class="tag">精灵</span><span class="tag is-grey-lightest">6</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a><p class="size-small"><span>&copy; 2024 Brigitte Jian</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备681653568号-8</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2016/06/18 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a38ab32555c76be3797','7cb234d7b83231df989dd8eac82fadef6d150a7f','moruoyiming','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a38ab32555c76be3797','7cb234d7b83231df989dd8eac82fadef6d150a7f','moruoyiming','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>
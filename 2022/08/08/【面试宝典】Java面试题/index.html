<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java基础知识面试题 - 简则易从的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="简则易从的博客"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="简则易从的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="Java语言有啥特点？    简单易学    面向对象（封装、继承、多态、抽象）    跨平台（JVM实现跨平台）    可靠性    安全性    支持多线程    支持网络编程    编译和解析并存JVM是什么？    JVM（Java虚拟机）：是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。    字节码：JVM可以理解的代码，扩"><meta property="og:type" content="blog"><meta property="og:title" content="简则易从"><meta property="og:url" content="https://moruoyiming.github.io/"><meta property="og:site_name" content="简则易从"><meta property="og:description" content="Java语言有啥特点？    简单易学    面向对象（封装、继承、多态、抽象）    跨平台（JVM实现跨平台）    可靠性    安全性    支持多线程    支持网络编程    编译和解析并存JVM是什么？    JVM（Java虚拟机）：是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。    字节码：JVM可以理解的代码，扩"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moruoyiming.github.io/img/favicon.jpg"><meta property="article:published_time" content="2022-08-08T14:18:40.879Z"><meta property="article:modified_time" content="2022-08-10T14:09:31.558Z"><meta property="article:author" content="Jian"><meta property="article:tag" content="面试题"><meta property="article:tag" content="AI"><meta property="article:tag" content="Java"><meta property="article:tag" content="GC算法"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/favicon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://moruoyiming.github.io/2022/08/08/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91Java%E9%9D%A2%E8%AF%95%E9%A2%98/"},"headline":"简则易从的博客","image":["https://moruoyiming.github.io/gallery/thumbnails/plant.jpg"],"datePublished":"2022-08-08T14:18:40.879Z","dateModified":"2022-08-10T14:09:31.558Z","author":{"@type":"Person","name":"Brigitte Jian"},"description":"Java语言有啥特点？    简单易学    面向对象（封装、继承、多态、抽象）    跨平台（JVM实现跨平台）    可靠性    安全性    支持多线程    支持网络编程    编译和解析并存JVM是什么？    JVM（Java虚拟机）：是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。    字节码：JVM可以理解的代码，扩"}</script><link rel="canonical" href="https://moruoyiming.github.io/2022/08/08/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91Java%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8241795889030186" crossOrigin="anonymous"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/media">电影</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/thumbnails/plant.jpg" alt="Java基础知识面试题"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-08  <a class="commentCountImg" href="/2022/08/08/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91Java%E9%9D%A2%E8%AF%95%E9%A2%98/#comment-container"><span class="display-none-class">0581e40326873a115f4a1ad670b439ca</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="0581e40326873a115f4a1ad670b439ca">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>12.1 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java基础知识面试题</h1><div class="content"><p>Java语言有啥特点？<br>    简单易学<br>    面向对象（封装、继承、多态、抽象）<br>    跨平台（JVM实现跨平台）<br>    可靠性<br>    安全性<br>    支持多线程<br>    支持网络编程<br>    编译和解析并存<br>JVM是什么？<br>    JVM（Java虚拟机）：是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。<br>    字节码：JVM可以理解的代码，扩展名为 .class 的文件。它不面向任何特定的处理器，只面向虚拟机。Java通过字节码的方式，在一定程度上解决了传统解析型语言执行效率低的问题，同时又保留了解析型语言可移植的特定。所以Java程序运行比较高效。<br>    字节码和不同系统的JVM的实现是Java语言“一次编译，随处可运行”的关键。<br>    Java 程序运行过程<br>OracleJDK 和 OpenJDK 的对比？<br>    OpenJDK是一个参考模型并且是完全开源的；而OracleJDK是基于OpenJDK7构建的，并不是完全开源的。<br>    OracleJDK比OpenJDK更稳定。两者代码几乎相同，但OracleJDK有更多的类和一些错误的修复。<br>    在响应性和JVM性能方面，OracleJDK更出色一些。<br>import java 和 javax 有什么区别？<br>    刚开始Java API所必需的包是java开头的包，javax是扩展API包来使用。<br>    后来 javax 逐渐成为 Java API 的组成部分。<br>字符型常量 和 字符串常量的区别？<br>    形式上：字符型常量是单引号引起的一个字符；字符串常量是双引号引起的0个或若干个字符；<br>    含义上：字符型常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（在内存中的存放位置）；<br>    内存大小：字符型常量只占2个字节；字符串常量占若干个字节；<br>标识符和关键字的区别？<br>    标识符：是一个名字，类、变量、方法的名字都是标识符。<br>    关键字：被Java语言赋予了特殊含义的标识符。例如：private &#x2F; public &#x2F; class &#x2F; new 等。<br>Java泛型？类型擦除？常用的通配符？<br>    Java泛型：JDK5引入的一个新特性，提供了编译时类型安全检测的机制。表现为：将类型当作参数传递给一个类或者方法。<br>        泛型类<br>        泛型接口<br>        泛型方法<br>    类型擦除：Java泛型是伪泛型，Java在编译期间，所有的泛型信息都会被擦除掉。<br>    常用通配符<br>        ？ 表示不确定的java类型<br>        T 表示具体的一个java类型<br>        K &#x2F; V 分别表示Java键值对的 key value<br>        E 表示 Element</p>
<span id="more"></span>
<p>&#x3D;&#x3D; 和 equals 的区别？<br>    &#x3D;&#x3D; ： 基本数据类型 比较的是值是否相等； 引用类型 比较的是内存地址是否一样（即两个对象是否同一个对象）；<br>    ｜ 因为Java只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。<br>    equals：判断两个对象是否相等，不能用于比较基本数据类型的变量。<br>    ｜ equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。<br>        类没有覆盖equals方法：等价于“&#x3D;&#x3D;”，使用的默认是Object类的equals方法。<br>        类覆盖了equals方法：一般都会覆盖equals方法，来比较两个对象的内容是否相等。<br>为什么重写equals方法时，必须重写hashCode方法？<br>    hashCode()方法介绍<br>    ｜ 在Object类中的一个本地方法，作用是获取哈希码（散列码），它是一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。<br>    为什么要有 hashCode()方法？<br>    ｜ 以“HashSet 如何检查重复”为例子说明。<br>    ｜ 当把对象添加到HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值做比较，如果没有相同的hashCode，则认为没有重复的对象。如果有相同的hashCode（发生碰撞），则会调用equals()方法来判断对象是否相同。如果相同，则不会让其加入成功。如果不同，则重新散列到其他位置。这样就减少使用equals的次数，提高了执行速度。<br>    重写equals方法，必须重写hashCode方法<br>    ｜ hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()方法，则两个对象是永远不相等的（即使有同样的数据）。<br>        如果两个对象相等（equals返回true），则它们的hashCode也一定相等。<br>        如果两个对象的hashCode相等，但它们不一定相等（equals不一定返回true）。<br>为什么说Java中只有值传递？<br>    按值调用（call by value）：方法接收的是调用者提供的值。<br>    按引用调用（call by reference）：方法接收的是调用者提供的变量地址。<br>    一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。<br>    Java才用按值调用，方法得到的是参数值的一个拷贝。<br>深拷贝、浅拷贝？<br>    浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递。<br>    ｜ 引用类型未新建对象，仍指向同一个对象（引用地址值）。<br>    深拷贝：对基本数据类型进行值传递，对引用类型，创建一个新的对象，并复制其内容。<br>    ｜ 引用类型新建了对象，引用地址值不相等。<br>定义一个不做事且无参的构造函数的作用？<br>    Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则默认会调用父类中“无参构造方法”。因此，如果父类中没有定义“无参构造方法”，而子类构造方法又没有用super()去调用父类特定的构造方法，则编译会发生错误。<br>成员变量 与 局部变量 的区别？<br>    成员变量属于类的；局部变量是在代码块或方法中定义的变量或方法的参数；<br>    成员变量可以被private、public、static 等修饰符所修饰；局部变量不能被访问控制修饰符及static修饰；<br>    成员变量和局部变量都可以被 final修饰；<br>    成员变量存在于堆内存；局部变量存在于栈内存；<br>    static修饰的成员变量属于类的，随着类的初始化而存在；没有static修饰的成员变量是对象的一部分，随着对象的创建而存在；局部变量随着方法的调用而存在和自动消失；<br>    成员变量如果没有被赋初值，则会自动以类型的默认值赋值（被final修饰的例外，需要显示赋值）；局部变量不会自动赋值；<br>对象实例和对象引用的关系？<br>    对象实例存在堆内存中；对象引用存在栈内存中；<br>    一个对象实例可以有若干个对象引用指向它；一个对象引用指向0个或1个对象实例；<br>类的构造方法？<br>    作用是：完成对类对象的初始化工作。<br>    一个类没有显示声明构造方法也可以执行，因为Java会给它一个默认的无参构造方法；如果显示声明了构造方法，那Java不会给它再添加默认的构造方法。<br>    特性<br>        名字与类名相同；<br>        没有返回值，并且不能用void声明；<br>        生成类的对象时自动执行，无需调用。<br>    子类在构造方法里调用父类的无参构造方法的目的是？<br>        帮助子类完成初始化工作。<br>面向对象的特征？<br>    抽象<br>    ｜ 将一些事物的共性和相似点抽离出来，并将这些属性归为一个类。<br>    封装<br>    ｜ 指把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但可以通过对象提供的一些可以被外界访问的方法来操作属性。<br>    继承<br>    ｜ 使用已存在的类（父类）作为基础建立新的类（子类），新类拥有父类的属性和方法，并可以增加新的属性和方法。通过继承，可以快速创建新类，提高代码的重用和程序的可维护性。<br>        子类拥有父类的所有属性和方法（包括私有的），但无法访问父类私有的属性和方法，仅仅是拥有。<br>        子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。<br>        子类可以覆盖父类的方法。<br>    多态<br>    ｜ 一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。<br>        对象类型和引用类型之间，具有继承（类）或实现（接口）的关系；<br>        引用类型变量发出的方法调用到底是哪个类中的方法，必须在运行期间才能确定；<br>        多态不能调用“只在子类存在但父类不存在”的方法；<br>        如果子类重写了父类的方法，执行的是子类覆盖的方法，否则是父类的方法；<br>String、StringBuffer、StringBuilder 的区别？<br>    可变性<br>        String类中使用final关键字修饰字符数组来保存字符串（private final char value[]），所以String对象是不可变的。<br>        StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在该类中也是使用字符数组（char[] value）来保存字符串，但没有用final关键字修饰，所以这两种对象都是可变的。<br>    线程安全性<br>        String 对象是不可变的，可以理解成常量，所以线程安全。<br>        AbstractStringBuilder 是StringBuffer、StringBuilder的父类，定义了一些字符串的基本操作方法，如：append、indexOf等公共方法。StringBuffer对方法加了同步锁（public synchronized StringBuffer append(String str)），所以是线程安全的。StringBuilder没有对方法进行加同步锁，所以是非线程安全。<br>    性能<br>        String 类型进行改变的时候，会生成一个新的String对象，然后将指针指向新的String对象；<br>        StringBuffer 进行改变时，会对StringBuffer对象本身进行操作；<br>        StringBuilder与StringBuffer操作一样，但因为没有加同步锁，性能更好一些；<br>    总结<br>        操作少量的数据：适用 String<br>        单线程操作字符串缓存区下大量的数据：适用 StringBuilder<br>        多线程操作字符串缓存区下大量的数据：适用 StringBuffer<br>Object类常见的方法有哪些？<br>    public final native Class getClass()<br>    ｜ 本地方法，返回当前运行时对象的Class对象，final关键字修饰，子类不可重写。<br>    public native int hashCode()<br>    ｜ 本地方法，返回对象的哈希码，主要使用在哈希表中，如：HashMap。<br>    public boolean equals(Object obj)<br>    ｜ 用于比较两个对象内存地址是否相等，String类对该方法重写后用于比较字符串的值是否相等。<br>    protected native Object clone() throws CloneNotSupportedException<br>    ｜ 本地方法，用于创建并返回当前对象的一份拷贝。<br>    public String toString()<br>    ｜ 返回 类名@实例的哈希码的16进制字符串。<br>    public final native void notify()<br>    ｜ 本地方法，并且不能重写。唤醒一个在此对象监视器（锁）上等待的线程。如果有多个线程在等待，只会唤醒一个。<br>    public final native void notifyAll()<br>    ｜ 跟notify()一样，区别在于会唤醒所有在此对象监视器等待的线程。<br>    public final native void wait(long timeout) throws InterruptedException<br>    ｜ 暂停线程的执行。等待时间（timeout）到了会释放锁，sleep()方法没有释放锁。<br>    public final void wait(long timeout, int nanos) throws InterruptedException<br>    ｜ nanos参数：表示额外时间（单位：纳秒，范围：0-999999， 1纳秒 &#x3D; 十亿分之一秒）。超时的时间需要加上nanos纳秒（过去式）。查看源码，只要 nanos 在0-999999范围内，则 timeout++；<br>    public final void wait() throws InterruptedException<br>    ｜ 暂停线程的执行，并且没有超时概念，一直等待。<br>    protected void finalize() throws Throwable { }<br>    ｜ 实例被垃圾回收器回收的时候触发。<br>Java序列化中如果有些字段不想被序列化，怎么办？<br>    对于不想被序列化的变量，使用 transient 关键字修饰。<br>    transient 关键字：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。<br>获取键盘输入常用的两种方法？<br>    通过 Scanner 类<br>    通过 BufferReader 类<br>反射机制？<br>    什么是反射机制？<br>    ｜ 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息和动态调用对象的方法的功能称为反射机制。<br>    静态编译 VS 动态编译<br>        静态编译：编译时确定类型，绑定对象；<br>        动态编译：运行时确定类型，绑定对象；<br>    反射机制的优缺点<br>        优点：运行期类型的判断、动态加载类、提高代码灵活度。<br>        缺点<br>            性能问题：反射相当于一系列解析操作，通知JVM要做的事情，比直接的java代码要慢很多。<br>            安全问题：动态操作改变类的属性，增加了安全隐患。<br>    反射技术的应用<br>        JDBC连接数据库时使用Class.forName() 通过反射加载数据库的驱动程序；<br>        Spring 的IOC创建对象（动态加载管理Bean）、AOP（动态代理）功能；<br>        动态配置实例的属性；<br>    获取Class 对象的两种方式<br>        知道具体类的情况<br>        ｜ Class clazz &#x3D; TargetObject.class;<br>        通过 Class.forName() 传入类的路径获取；<br>        ｜ 一般是不知道具体类的，基本都是通过便利包下面的类来获取Class对象<br>        ｜ Class clazz &#x3D; Class.forName(“com.xxx.TargetObject”);<br>Java异常有哪些？<br>    所有的异常都有一个共同的祖先：java.lang.Throwable类，Throwable类有两个重要的子类Exception（异常）和Error（错误）。Exception 能被程序本身处理（try-catch），Error是无法处理的。<br>    Exception ： 程序本身可以处理的异常，可以通过 catch 捕获。<br>        受检异常（必须处理的）<br>        ｜ 在编译过程中，如果没有被 catch &#x2F; throw 处理，则无法通过编译。除了RuntimeException及其子类之外，其他的Exception类及其子类都属于受检异常。<br>            IOException<br>            ClassNotFoundException<br>            SQLException<br>        不受检异常（可以不处理）<br>        ｜ 在编译过程中，即使不处理也可以正常编译通过。RuntimeException及其子类统称为非受检异常。<br>            NullPointException<br>            NumberFormatException<br>            ArrayIndexOutBoundsException<br>            ArithmeticException<br>    Error：程序无法处理的错误。JVM会选择终止线程。<br>        Virtual MachineError （Java虚拟机运行错误）<br>        OutOfMemoryError （虚拟机内存不够错误）<br>        NoClassDefFoundError （类定义错误）<br>        StackOverflowError （栈溢出错误）<br>try-catch-finally<br>    try 块：用于捕获异常。其后可以接零个或多个catch块，如果没有catch块，则必须跟一个finally块。<br>    catch 块：用于处理try捕获到的异常。<br>    finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当try块或catch块中遇到return语句时，finally块的语句将在方法返回之前被执行，并且finally语句返回值将覆盖原始返回值。<br>    以下3种情况下，finally块不会被执行<br>        在try或finally块中用 System.exit(int)退出程序。并且这句要在异常语句之前。<br>        程序所在的线程死亡。<br>        关闭CPU。<br>try-with-resources<br>    适用范围：任何实现 java.lang.AutoCloseable 或 java.io.Closeable的对象。<br>    面对需要关闭的资源，我们总是应该优先使用 try-with-resources，而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources 语句让我们更容易编写必须要关闭的资源代码，若采用try-finally 则几乎做不到这点。—《Effective Java》<br>    InputStream、Scanner等资源都需要调用close()方法手动关闭。<br>        try-catch-finally实现方式<br>        使用Java 7 之后的try-with-resources 语句改造上面的代码：<br>        当多个资源需要关闭的时候，通过使用分号分隔。<br>Java中IO流分为几种？<br>    按照流的流向分：分为输入流和输出流；<br>    按照流的操作单元分：分为字节流和字符流；<br>    按照流的角色分：分为节点流和处理流；<br>    Java IO流有40多个类，都是从以下4个抽象类基类中派生出来的。<br>        InputStream &#x2F; Reader ：所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>        OutputStream &#x2F; Writer ：所有输出流的基类，前者是字节输出流，后者是字符输出流。<br>        按操作方式<br>        按操作对象<br>既然有了字节流，为什么还要有字符流？<br>    不管是文件读写还是网络传输，信息的最小存储单元都是字节，那为什么I&#x2F;O流操作要分为字节流和字符流？<br>    字符流是由于Java虚拟机将字节转换得到的，这个过程比较复杂耗时，并且，如果不知道编码类型很容易出现乱码问题。所以，I&#x2F;O流提供了一个直接操作字符的接口，方便对字符进行流操作。<br>怎么解决浮点数进度丢失？<br>    使用BigDecimal<br>        浮点数之间的等值判断，基本数据类型不能用“&#x3D;&#x3D;”来比较，包装类型不能用“equals”来判断。（具体原理与浮点数的编码方式有关，精度丢失）<br>        使用BigDecimal来定义浮点数，再进行运算操作<br>    在使用BigDecimal时，为防止精度丢失，推荐使用它的BigDecimal(String) 构造方法或者BigDecimal.valueOf方法来创建对象，禁止使用构造方法BigDecimal(double)的方式把double值转化为BigDecimal对象。<br>        BigDecimal a &#x3D; new BigDecimal(0.1f); 实际存储值为：0.10000000149<br>        BigDecimal a &#x3D; new BigDecimal(“0.1”);    正解<br>        BigDecimal a &#x3D; new BigDecimal.valueOf(0.1);    正解<br>工具类Arrays.asList() 使用注意事项？<br>    Arrays.asList() 将数组转换为集合后，底层其实还是数组，不能使用其修改集合相关的方法，它的add&#x2F;remove&#x2F;clear方法会抛出UpsupportedOperationException异常。<br>    Arrays.asList() 的返回对象是一个Arrays 的内部类，并没有实现集合的修改方法。体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>    传递的数组必须是对象数组，而不是基本类型。（Arrays.asList()是泛型方法，传入的对象必须是对象数组）<br>    ｜ 当传入一个基本类型的数组时，Arrays.asList()的得到的参数不是数组中的元素，而是数组本身。此时List的唯一元素就是这个数组。<br>如何将数组转换为ArrayList？<br>    自定义方法实现<br>    结合Arrays.asList()实现（推荐）<br>    使用Java 8 的Stream（推荐）<br>    使用Java 9 的List.of()方法<br>不要在 foreach 循环里进行元素的 remove &#x2F; add 操作？<br>    fail-fast（快速失败） 机制：java集合（Collection）中的一种错误机制。<br>        当多个线程对同一个集合内容进行操作时，就可能会产生fail-fast事件。<br>        ｜ 例如：当某一个线程A通过iterator便利某集合的过程中，若该集合内容被其他线程所改变了，那么线程A访问该集合时，就会抛出ConcurrentModificationException异常。<br>        单线程下，在foreach循环里调用集合类的remove方法，将抛出ConcurrentModificationException异常。<br>    解决方案一：Java 8 开始可以使用Collection#removeIf()方法删除满足条件的元素。<br>    解决方案二：使用Iterator方式。（如果并发，需要对Iterator对象加锁）<br>    fail-safe（安全失败）机制：采用安全失败机制的容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所做的修改并不能被迭代器检测到，故不会抛ConcurrentModificationException异常。<br>创建对象的方式有哪几种？<br>    new 方法。<br>    clone()：使用Object的clone方法。<br>    反射<br>        调用public无参构造函数，若没有，则会报异常。<br>        ｜ Object obj &#x3D; clazz.newInstance();<br>        调用带有参数的构造函数，先获取到其构造对象，再通过构造方法类获取实例。<br>        ｜ &#x2F;&#x2F; 获取构造函数类的对象<br>        ｜ Constructor constructor &#x3D; User.class.getConstructor(String.class);<br>        ｜ &#x2F;&#x2F; 使用构造对象的newInstance方法初始化对象<br>        ｜ Object obj &#x3D; constructor.newInstance(“name”);<br>    发序列化创建对象。（被创建实例的类需实现Serializable接口）<br>如何实现静态代理？优缺点？<br>    实现方式<br>        1. 为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口。<br>        2. 在创建对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法。<br>    优点<br>        在客户端和目标对象之间充当中介的作用，保护目标对象；<br>        可以扩展目标对象的功能；（在调用目标对象方法的前后增加其他一些方法。）比如：打印日志<br>    缺点<br>        需要为每一个目标类编写对应的代理类，产生的类太多，工作量大。<br>        相比直接调用目标对象的方法，效率低一些。<br>了解动态代理？在哪些地方用到？<br>    作用<br>        为其它对象提供一种代理以控制对这个对象的访问。<br>    JDK动态代理的实现<br>        在运行运行时，通过反射机制动态生成代理对象；<br>        调用程序必须实现InvocationHandler接口；<br>        使用Proxy类中的newProxyInstance方法动态的创建代理类。<br>    在哪些地方应用到？<br>        AOP、RPC 框架中都有用到。<br>    JDK的动态代理与CGLIB的区别<br>        JDK动态代理只能代理实现了接口的类；而CGLIB可以代理未实现任何接口的类。<br>        JDK动态代理是通过反射的方式创建代理类；而CGLIB动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能将代理类声明为final类型的类和方法；<br>        JDK动态代理的效率更优。<br>对Java注解的理解，解决声明问题？<br>    Java语言中的类、方法、变量、参数和包等都可以注解标记，在程序运行期间可以获取到相应的注解以及注解中定义的内容。<br>    注解极大地简化了代码，通过注解可以帮助我们简单地完成一些事情；比如：Spring中如果检测到你的类被 @Component 注解标记的话，Spring容器在启动的时候就会把这个类进行管理，我们可以通过 @Autowired 注解注入类的实例。<br>内存泄漏和内存溢出？<br>    内存泄漏<br>        定义：是指不再使用的对象持续占用内存或者它们占用的内存得不到及时释放，从而造成内存空间的浪费。<br>        根本原因：长生命周期的对象持有短生命周期对象的引用；<br>        内存泄漏场景<br>            静态集合类引起：静态成员的生命周期是整个程序运行期间。<br>            ｜ 例如Map是在堆上动态分配对象，正常情况下使用完毕后，就会被gc回收。而如果Map被static修饰，且没有删除机制，静态成员是不会被回收的，所以导致很大的Map一直停留在堆内存中。懒初始化static变量，尽量避免使用。<br>            当集合里的对象属性被修改后，再调用remove()方法是不起作用的。<br>            ｜ 当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了。<br>            各种连接对象（IO流对象、数据库连接对象、网络连接对象）使用后未关闭。<br>            ｜ 因为每个流在操作系统层面都对应了打开的文件句柄，流没有关闭，会导致操作系统的文件句柄一直处于打开状态，而JVM会消耗内存来跟踪操作系统打开的文件句柄。<br>            监听器的使用。<br>            ｜ 在释放对象的同时，没有相应删除监听器的时候，也可能导致内存泄露。<br>            不正确使用单例模式。<br>            ｜ 单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么被持有的对象将不能被JVM正常回收。<br>        解决措施<br>            尽量减少使用静态变量，类的静态变量的生命周期是和类同步的。<br>            声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员变量改写为方法内 的局部变量。<br>            减少长生命周期的对象持有短生命周期的引用。<br>            使用StringBuilder和StringBuffer替换String进行字符串连接。避免产生大量临时字符串。<br>            对于不需要使用的对象，手动设置null值，不管GC何时会开始清理，我们都应该及时的将无用的对象标记为可被清理的对象。<br>            各种连接（数据库连接、网络连接、IO连接）操作，操作结束都务必显式调用close关闭。<br>    内存溢出<br>        指程序运行过程中无法申请到足够的内存而导致的一种错误。<br>        通常发生在OLD段或perm段垃圾回收后，仍然无内存空间容纳新的对象的情况。<br>        内存溢出场景<br>            JVM Heap(堆)溢出：（java.lang.OutOfMemoryError：java heap space）<br>            ｜ 发生这种问题的原因是java虚拟机创建的对象太多了，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了。<br>            ｜<br>                解决方法<br>                ｜ JVM在启动的时候，会自动设置JVM Heap的值，可以利用JVM提供的 -Xmn -Xms -Xmx 等选项进展设置。Heap的大小是新生代和老年代之和。<br>                    手动设置JVM Heap的大小；<br>                    检查程序，看是否有死循环或不必要地创建大量对象；<br>            Metaspace溢出：（java.lang.OutOfMemoryError:Metaspace）<br>            ｜ 原因：程序中使用了大量的jar或class，使java虚拟机装载类的空间不够。<br>            ｜<br>                解决方法<br>                ｜ ​方法区用于存放java类型的相关信息。在类装载器加载class文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储信息而方法区的内存占用又已经达到 -XX:MaxMetaspaceSize设置的最大值，将会抛出此异常。测试基本思路：运行时产生大量的类去填满方法区，直到溢出。<br>                    通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。<br>            栈溢出：（java.lang.OutOfMemoryError:Thread Stack space）<br>            ｜ 线程的方法嵌套调用层次太多（如：递归调用），以致把栈区溢出了。<br>                解决方法<br>                    修改程序；<br>                    通过 -Xss：来设置每个线程的Stack 大小；<br>BIO、NIO、AIO<br>    BIO （Blocking I&#x2F;O）<br>    ｜ 同步阻塞I&#x2F;O模式，数据的读写必须阻塞在一个线程内等待其完成。<br>    NIO （Non-Blocking&#x2F;New I&#x2F;O）<br>    ｜ 是一种同步非阻塞的I&#x2F;O模型，对应java.nio包，提供了Channel、Selector、Buffer 等抽象。<br>    ｜ 单线程从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。非阻塞写数据也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程可以同时去做别的事情。JDK的NIO底层由epoll实现。<br>        NIO中所有I&#x2F;O操作都是从Channel（通道）开始的。<br>            从通道进行数据读取，创建一个缓存区，然后请求通道读取数据。<br>            从通道进行数据写入，创建一个缓冲区，填充数据，并请求通道写入数据。<br>    AIO （Asynchronous I&#x2F;O）<br>    ｜ 异步非阻塞I&#x2F;O模型，异步I&#x2F;O是基于事件和回调机制实现的。应用操作之后会直接返回，不会阻塞，当后台处理完成，操作系统会通知相应的线程进行后续的操作。<br>Java中finalize()方法的使用？<br>    finalize() 是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。<br>    finalize() 方法中一般用于释放非Java资源（如：打开的文件资源、数据库连接等），或是调用非Java方法（native方法）时分配的内存。<br>    避免使用的原因<br>        finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到finalize()方法被执行，所花费的时间是任意长的。我们不能依赖finalize()方法能及时的回收占用的资源，可能在资源耗尽之前，gc仍为触发。因此通常的做法是提供显式的close()方法供客户端手动调用。<br>        finalize() 方法意味着回收对象时需要进行更多的操作，从而延长了对象回收的时间。<br>Java中Class.forName 和 ClassLoader的区别？<br>    Class.forName() 和 ClassLoader 都可以对类进行加载；<br>    ClassLoader 遵循双亲委派模型，实现的功能是通过一个类的全限定名来获取描述此类的二进制字节流，获取到二进制流后放到JVM中。ClassLoader只做一件事，就是将.class文件加载到JVM中，不会只想static中的内容。<br>    Class.forName()方法实际上也是调用ClassLoader来实现的，不同的是除了将类的.class文件加载到JVM中之外，还会对类进行初始化，执行类中的static块。<br>讲一下CopyOnWriteArrayList和CopyOnWriteArraySet？<br>    CopyOnWrite 容器：写时复制的容器。往一个容器添加元素时，不是直接往当前容器添加，而是先将当前容器进行copy，复制出一个新的容器，然后往新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。<br>        添加元素的时候需要加锁，否则多线程写的时候会copy出N个副本<br>        读的时候不需要加锁，多线程读写时，读到的可能还是旧数据，因为读的时候不会对当前容器加锁<br>    CopyOnWrite 并发容器主要用于读多写少的并发场景。<br>    优点：可以对CopyOnWrite容器进行并发读，而不需要加锁，因为当前容器不会添加任何元素。<br>    ｜ CopyOnWrite容器是一种读写分离的思想，读和写不同的容器。<br>    缺点<br>        内存占用问题<br>        ｜ 因为CopyOnWrite是写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存。如果这些对象占用的内存比较大，那么有可能会造成频繁的Yong GC 和 Full GC。<br>            针对内存占用问题，可以通过压缩容器中的元素来减少大对象的内存消耗，如元素全是10进制的数字，可考虑把它压缩成36进制或者64进制。或者不使用CopyOnWrite容器，而使用其他并发容器，如：ConcurrentHashMap。<br>        数据一致性问题<br>        ｜ CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。<br>HashMap了解多少？<br>    HashMap底层实现<br>        HashMap 是用数组 + 链表 + 红黑树（JDK1.8开始增加了红黑树）进行实现的，当添加一个元素（key-value）时，首先计算元素key的hash值，并根据hash值来确定插入数组的位置，如果发生碰撞（存在其他元素已经被放在数组同一位置），这个时候便使用链表来解决哈希冲突，当链表长度太长的时候，便将链表转为红黑树来提高搜索的效率。<br>            数组的容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。<br>            数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组，这个0.75就是默认的负载因子，可由构造函数传入。<br>            为了解决碰撞，数组中的元素是单向链表类型。当链表长度达一个阈值时（&gt;&#x3D;8），会将链表转换为红黑树提高性能。而当链表长度缩小到另一个阈值（&lt;&#x3D;6）时，又会将红黑树转换回单向链表提高性能。<br>    HashMap的put方法执行流程&#x2F;步骤<br>        1. 判断数组table是否为null，若为null则执行resize()扩容操作。<br>        2. 根据键key的值计算hash值得到插入的数组索引i，若table[i] &#x3D;&#x3D; nulll，则直接新建节点插入，进入步骤6；若table[i]非null，则继续执行下一步。<br>        3. 判断table[i]的首个元素key是否和当前key相同（hashCode和equals均相同），若相同则直接覆盖value，进入步骤6，反之继续执行下一步。<br>        4. 判断table[i]是否为treeNode，若是红黑树，则直接在树中插入键值对并进入步骤6，反之继续执行下一步。<br>        5. 遍历table[i]，判断链表长度是否大于8，若&gt;8，则把链表转换为红黑树，在红黑树中执行插入操作；若&lt;8，则进行链表的插入操作；遍历过程中若发现key已存在则会直接覆盖该key的value值。<br>        6. 插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold，若超过则进行扩容。<br>    HashMap的get方法执行流程&#x2F;步骤<br>        1. 首先定位到键所在的数组的下标，并获取对应节点n。<br>        2. 判断n是否为null，若n为null，则返回null并结束；反之，继续下一步。<br>        3. 判断n的key和要查找的key是否相同(key相同指的是hashCode和equals均相同)，若相同则返回n并结束；反之，继续下一步。<br>        4. 判断是否有后续节点m，若没有则结束；反之，继续下一步。<br>        5. 判断m是否为红黑树，若为红黑树则遍历红黑树，在遍历过程中如果存在某一个节点的key与要找的key相同，则返回该节点；反之，返回null；若非红黑树则继续下一步。<br>        6. 遍历链表，若存在某一个节点的key与要找的key相同，则返回该节点；反之，返回null。<br>    HashMap的扩容机制<br>        扩容是为了防止HashMap中的元素个数超过了阀值，从而影响性能所服务的。而数组是无法自动扩容的，HashMap的扩容是申请一个容量为原数组大小两倍的新数组，然后遍历旧数组，重新计算每个元素的索引位置，并复制到新数组中；又因为HashMap的哈希桶数组大小总是为2的幂次方，所以重新计算后的索引位置要么在原来位置不变，要么就是“原位置+旧数组长度”。其中，threshold和loadFactor两个属性决定着是否扩容。threshold&#x3D;Length<em>loadFactor，Length表示table数组的长度（默认值为16），loadFactor为负载因子（默认值为0.75）；阀值threshold表示当table数组中存储的元素个数超过该阀值时，即需要扩容。<br>        HashMap的扩容使用新的数组代替旧数组，然后将旧数组中的元素重新计算索引位置并放到新数组中，对旧数组中的元素如何重新映射到新数组中？<br>            HashMap的哈希算法数组扩容<br>            ｜ （a）为扩容前，key1和key2两个key确定索引的位置；（b）为扩容后，key1和key2两个key确定索引的位置；hash1和hash2分别是key1与key2对应的哈希“与高位运算”结果。<br>            ｜ (a)中数组的高位bit为“1111”，1</em>20 + 1<em>21 + 1</em>22 + 1<em>23 &#x3D; 15，而 n-1 &#x3D;15，所以扩容前table的长度n为16；<br>            ｜ (b)中n扩大为原来的两倍，其数组大小的高位bit为“1 1111”，1</em>20 + 1<em>21 + 1</em>22 + 1<em>23 + 1</em>24 &#x3D; 15+16&#x3D;31，而 n-1&#x3D;31，所以扩容后table的长度n为32；<br>            ｜ (a)中的n为16，(b)中扩大两倍n为32，相当于(n-1)这部分的高位多了一个1，然后和原hash码作与操作，最后元素在新数组中映射的位置要么不变，要么向后移动16个位置。<br>            HashMap中数组扩容两倍后位置的变化<br>            ｜ 因此，在扩充HashMap，复制数组元素及确定索引位置时不需要重新计算hash值，只需要判断原来的hash值新增的那个bit是1，还是0；若为0，则索引未改变；若为1，则索引变为“原索引+oldCap”<br>            HashMap中数组16扩容至32<br>            ｜ JDK1.7中扩容时，旧链表迁移到新链表的时候，若出现在新链表的数组索引位置相同情况，则链表元素会倒置，但从上图中看出JKD1.8的扩容并不会颠倒相同索引的链表元素。<br>        扩容机制设计的优点<br>            1. 省去了重新计算hash值的时间(由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快)，只需判断新增的一位是0或1；<br>            2. 由于新增的1位可以认为是随机的0或1，因此扩容过程中会均匀的把之前有冲突的节点分散到新的位置(bucket槽)，并且位置的先后顺序不会颠倒；<br>            3. JDK1.7中扩容时，旧链表迁移到新链表的时候，若出现在新链表的数组索引位置相同情况，则链表元素会倒置，但JKD1.8的扩容并不会颠倒相同索引的链表元素。<br>    HashMap 和 Hashtable 的区别<br>        线程安全<br>            HashMap是非线程安全的；<br>            Hashtable是线程安全的，方法被synchronized修饰；<br>        是否允许NULL值<br>            HashMap允许有一个key是NULL，允许值为NULL；<br>            Hashtable无论是key还是value都不允许为NULL；<br>        继承的父类<br>            HashMap和Hashtable都实现了Map接口；<br>            HashMap继承的父类是AbstractMap；<br>            Hashtable继承的父类是Dictionary；<br>        contains()方法<br>            HashMap没有contains()方法，但有containsValue和containsKey方法；<br>            Hashtable保留了contains方法，也有containsValue和containsKey方法；contains方法与containsValue方法效果一样（containsValue方法里调用contains方法）。<br>        计算hash值的方式不同<br>    二叉树<br>        某节点的左子树节点值仅包含小于该节点值<br>        某节点的右子树节点值仅包含大于该节点值<br>        左右子树每个也必须是二叉查找树<br>        图示<br>    红黑树<br>        每个节点都有红色或黑色<br>        树的根始终是黑色的<br>        没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）<br>        从节点（包括根）到其任何后代NULL节点（叶子结点下方挂的两个空节点，并且认为他们是黑色的）的每条路径都具有相同数量的黑色节点。<br>ConcurrentHashMap的底层实现？<br>    底层数据结构<br>        JDK 1.7 的ConcurrentHashMap底层采用 分段的数组+链表 实现；<br>        JDK 1.8 采用的数据结构跟HashMap 1.8 一致：数组 + 链表 | 红黑二叉树；<br>    实现线程安全的方式<br>        JDK 1.7 ，ConcurrentHashMap（分段锁）对整个桶数据进行了分割分段（Segment），每一把锁只锁容器其中一部分的数据，多线程访问容器中不同数据段的数据，就不会存在锁竞争，提高并发访问率；<br>        JDK 1.8，开始摒弃Segment的概念，并发控制使用 synchronized 和 CAS 来操作，像是优化过且线程安全的HashMap。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率非常高。<br>    ConcurrentHashMap的读操作为什么不需要加锁？<br>        get操作全程不需要加锁是因为Node的成员val是用volatile修饰的，和数组用volatile修饰无关；<br>        数组用volatile修饰主要是保证在数组扩容的时候保证可见性；<br>        总结：定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，而不会读到过期值。由于get操作只需读不需要写共享变量，所以不用加锁。之所以不会读到过期值，依据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，get总能拿到最新值。<br>HashMap、LinkedHashMap、TreeMap 有什么区别？各自的使用场景？<br>    LinkedHashMap 保存了记录的插入顺序，在用Iterator遍历时，先取到的记录是先插入的，遍历比HashMap慢；<br>    TreeMap 实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序，也可以指定排序的比较器）。<br>    使用场景<br>        HashMap：一般情况下，使用最多的；适用于Map的插入、删除和定位元素；<br>        TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；<br>        LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下；<br>HashMap 多线程操作死循环问题<br>    由于多线程并发下进行扩容（调用rehash()方法）造成元素之间形成一个循环链表。<br>        正常Rehash过程<br>        ｜ 1. 假设了hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。<br>        ｜ 2. 最上面的是old hash表，其中的Hash表的size&#x3D;2, 所以key &#x3D; 3, 7, 5，在mod 2以后都冲突在table1这里了。<br>        ｜ 3. 接下来的三个步骤是Hash表 resize成4，然后所有的元素重新rehash的过程。<br>        并发的Rehash过程<br>        ｜ 假设有两个线程：线程一和线程二，假设出现以下过程：<br>        ｜ 1. 线程一执行到 next &#x3D; e.next; 的时候，被CPU挂起； （当前元素e &#x3D; 3, next &#x3D; 7;）<br>        ｜ 2. 线程二执行完成，完成了扩容操作，链表被改变，元素被翻转；（元素 7 的next元素变为 3）<br>        ｜ 3. 线程一重新获得CPU，继续执行，由于链表已经被线程二改了，原来元素3的next元素是7，现在发现7的next元素居然是3，一脸闷逼，进入死循环疯狂操作！！！<br>    JDK 1.8 已经解决了该问题，但是由于HashMap是非线程安全的，多线程下使用还是会存在其他问题，比如：数据丢失。所以多线程下如果需要更新操作的，建议改用 ConcurrentHashMap。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java基础知识面试题</p><p><a href="https://moruoyiming.github.io/2022/08/08/【面试宝典】Java面试题/">https://moruoyiming.github.io/2022/08/08/【面试宝典】Java面试题/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://moruoyiming.github.io"><p>Brigitte Jian</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-08-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2022/09/22/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91Flutter%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank">Flutter面试题</a><br></span><span>  2.<a class="is-size-6" href="/2022/08/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91%E6%98%93%E8%BD%A6%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank">易车一面面试题</a><br></span><span>  3.<a class="is-size-6" href="/2022/08/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91oppo%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank">oppo的面试题</a><br></span><span>  4.<a class="is-size-6" href="/2022/08/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/" target="_blank">Android 基础知识总结</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%91%E7%99%BE%E5%BA%A6%E4%BA%8C%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank">百度二面面试题</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay-reward-image.jpeg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat-reward-image.jpeg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/08/10/%E3%80%90%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">位运算</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/08/08/%E3%80%90%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E3%80%912021%20IntellJ%20IDEA%20%E6%BF%80%E6%B4%BB%E7%A0%81%E3%80%82IntellJ%20IDEA%20%E6%BF%80%E6%B4%BB%E7%A0%81/"><span class="level-item">2021 IntellJ IDEA 激活码。IntellJ IDEA 激活码</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '0581e40326873a115f4a1ad670b439ca',
            repo: 'blog_comment',
            owner: 'moruoyiming',
            clientID: '0a38ab32555c76be3797',
            clientSecret: '7cb234d7b83231df989dd8eac82fadef6d150a7f',
            admin: ["moruoyiming"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/favicon.jpg" alt="简则易从"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">简则易从</p><p class="is-size-6 is-block">书山有路勤为径，学海无涯苦作舟</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">108</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">222</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/moruoyiming" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Youtube" href="https://www.youtube.com/channel/UCemLDs1nqPnjHN04JCNtmbg"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/accounts/login/?next=/jianzeyicong/"><i class="fab fa-instagram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="500px" href="https://500px.com/p/moruoyiming123?view=photos"><i class="fab fa-500px"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://zhs.center/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">狗急跳墙</span></span><span class="level-right"><span class="level-item tag">zhs.center</span></span></a></li><li><a class="level is-mobile" href="https://www.androiddevtools.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓工具</span></span><span class="level-right"><span class="level-item tag">www.androiddevtools.cn</span></span></a></li><li><a class="level is-mobile" href="http://androidxref.com/6.0.0_r1/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓源码</span></span><span class="level-right"><span class="level-item tag">androidxref.com</span></span></a></li><li><a class="level is-mobile" href="http://idea.lanyus.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">IDEA破解</span></span><span class="level-right"><span class="level-item tag">idea.lanyus.com</span></span></a></li><li><a class="level is-mobile" href="https://www.atool99.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线接口</span></span><span class="level-right"><span class="level-item tag">www.atool99.com</span></span></a></li><li><a class="level is-mobile" href="http://www.bejson.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线解析</span></span><span class="level-right"><span class="level-item tag">www.bejson.com</span></span></a></li><li><a class="level is-mobile" href="https://tinypng.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">图片压缩</span></span><span class="level-right"><span class="level-item tag">tinypng.com</span></span></a></li><li><a class="level is-mobile" href="https://wallpapershome.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">高清壁纸</span></span><span class="level-right"><span class="level-item tag">wallpapershome.com</span></span></a></li><li><a class="level is-mobile" href="https://www.nunuyy2.org/dianying/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线电影</span></span><span class="level-right"><span class="level-item tag">www.nunuyy2.org</span></span></a></li><li><a class="level is-mobile" href="https://www.4ksj.com/forum-2-1.html" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">4K电影</span></span><span class="level-right"><span class="level-item tag">www.4ksj.com</span></span></a></li><li><a class="level is-mobile" href="https://cli.im/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">草料二维码</span></span><span class="level-right"><span class="level-item tag">cli.im</span></span></a></li><li><a class="level is-mobile" href="https://www.waitsun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MAC应用</span></span><span class="level-right"><span class="level-item tag">www.waitsun.com</span></span></a></li><li><a class="level is-mobile" href="https://file.wikileaks.org/file/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">暗网</span></span><span class="level-right"><span class="level-item tag">file.wikileaks.org</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%8D%81%E5%A4%A9%E5%B9%B2%E5%90%AB%E4%B9%89/"><img src="/gallery/thumbnails/plant.jpg" alt="Java应该掌握的知识"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-02T13:55:59.218Z">2024-03-02</time></p><p class="title"><a href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%8D%81%E5%A4%A9%E5%B9%B2%E5%90%AB%E4%B9%89/">Java应该掌握的知识</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">知识积累</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%90%84%E8%B7%AF%E4%BB%99%E5%AE%B6%E4%BD%93%E6%84%9F/"><img src="/gallery/thumbnails/plant.jpg" alt="各路仙家体感"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-02T13:55:04.868Z">2024-03-02</time></p><p class="title"><a href="/2024/03/02/%E3%80%90%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4%E3%80%91%E5%90%84%E8%B7%AF%E4%BB%99%E5%AE%B6%E4%BD%93%E6%84%9F/">各路仙家体感</a></p><p class="categories"><a href="/categories/%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4/">阴阳风水</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/02/28/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6MD5%E5%80%BC/"><img src="/gallery/thumbnails/image1.jpg" alt="获取签名文件MD5"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-28T13:22:29.194Z">2023-02-28</time></p><p class="title"><a href="/2023/02/28/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6MD5%E5%80%BC/">获取签名文件MD5</a></p><p class="categories"><a href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/02/28/%E3%80%90%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86%E3%80%91%E8%B6%8A%E7%8B%B1%E7%AC%AC%E4%B8%80%E5%AD%A3/"><img src="/gallery/thumbnails/image1.jpg" alt="越狱 第一季 Prison Break Season 1"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-28T13:22:19.654Z">2023-02-28</time></p><p class="title"><a href="/2023/02/28/%E3%80%90%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86%E3%80%91%E8%B6%8A%E7%8B%B1%E7%AC%AC%E4%B8%80%E5%AD%A3/">越狱 第一季 Prison Break Season 1</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86/">经典影视</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/02/21/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91android%20EditText%20%E9%99%90%E5%AE%9A%E4%B8%AD%E6%96%87%E4%B8%AA%E6%95%B0%E4%B8%8E%E8%8B%B1%E6%96%87%E4%B8%AA%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"><img src="/gallery/thumbnails/desert.jpg" alt="android EditText 限定中文个数与英文个数的解决方式"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-21T12:26:14.508Z">2023-02-21</time></p><p class="title"><a href="/2023/02/21/%E3%80%90Android%E5%9F%BA%E7%A1%80%E3%80%91android%20EditText%20%E9%99%90%E5%AE%9A%E4%B8%AD%E6%96%87%E4%B8%AA%E6%95%B0%E4%B8%8E%E8%8B%B1%E6%96%87%E4%B8%AA%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/">android EditText 限定中文个数与英文个数的解决方式</a></p><p class="categories"><a href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Android基础</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/"><span class="level-start"><span class="level-item">应用软件</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"><span class="level-start"><span class="level-item">知识积累</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"><span class="level-start"><span class="level-item">科学上网</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%88%E8%BA%AB%E6%88%90%E9%95%BF/"><span class="level-start"><span class="level-item">终身成长</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%8F%E5%85%B8%E5%BD%B1%E8%A7%86/"><span class="level-start"><span class="level-item">经典影视</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"><span class="level-start"><span class="level-item">经典电影</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">结构算法</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%98%B4%E9%98%B3%E9%A3%8E%E6%B0%B4/"><span class="level-start"><span class="level-item">阴阳风水</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"><span class="level-start"><span class="level-item">面试宝典</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">90</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">45</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zygote/"><span class="tag">Zygote</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gradle/"><span class="tag">gradle</span><span class="tag is-grey-lightest">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SystemServer/"><span class="tag">SystemServer</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mac%E7%B3%BB%E7%BB%9F/"><span class="tag">Mac系统</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"><span class="tag">冒泡排序</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="tag">面试题</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ActivityManagerNative/"><span class="tag">ActivityManagerNative</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bt/"><span class="tag">bt</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"><span class="tag">史茅革</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%92%95%E5%99%9C/"><span class="tag">咕噜</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"><span class="tag">壁纸路径</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"><span class="tag">意外之旅</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%92%E7%81%B5/"><span class="tag">戒灵</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"><span class="tag">指环王</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"><span class="tag">比尔博·巴金斯</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%82%8E%E9%AD%94/"><span class="tag">炎魔</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%98%E9%81%93%E5%A4%AB/"><span class="tag">甘道夫</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E7%81%B5/"><span class="tag">精灵</span><span class="tag is-grey-lightest">6</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a><p class="size-small"><span>&copy; 2024 Brigitte Jian</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备681653568号-8</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2016/06/18 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a38ab32555c76be3797','7cb234d7b83231df989dd8eac82fadef6d150a7f','moruoyiming','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a38ab32555c76be3797','7cb234d7b83231df989dd8eac82fadef6d150a7f','moruoyiming','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>
{"pages":[{"title":"","text":"个人简介 分享很喜欢的**老罗**的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 个人信息：90后计算机网络技术专业从事Android开发，坚信代码改变世界摄影爱好者QQ: 798774875Email: moruoyiming123@gmail.comJianShu: jianzeyicongGithub: moruoyimingYouTube: Jean RilenInstagram: jianzeyicong500px: moruoyiming 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志： –2020.09.29：增加相册、视频功能–2020.09.18：增加AdSense广告–2020.08.22：改版部分显示，优化速度–2020.06.18：icarus3.0主题适配–2019.12.16：增加不蒜子统计–2019.10.16：文章列表加上评论数显示–2019.03.13：改版评论–2017.12.16：icarus1.0主题适配–2017.08.12：搭建个人博客 本站推荐索引 技术知识点 Java教程 Python3教程 JavaScript教程 剑指Offer 免费学习资料 常用工具 图片压缩 在线转换工具 贝塞尔弧曲线 ProcessOn流程图 Youtube视频下载 免费翻墙 free-ss free-ss.site ss.pythonic.life 免费节点 软件下载 萌新网 麦氪派 福利 电影天堂 高清电影 BD电影 剧迷 高速车 持续更新~","link":"/about/index.html"},{"title":"categories","text":"(adsbygoogle = window.adsbygoogle || []).push({});","link":"/categories/index.html"},{"title":"","text":"风光 人像 动物 图片均为本人拍摄，有共同爱好的小伙伴可以约起来哦~~~ 留言 😊 😊 😊。","link":"/album/index.html"},{"title":"电影","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"13道数据结构和算法题总结","text":"Q1：什么是 AVL 树？AVL 树 是平衡二叉查找树，增加和删除节点后通过树形旋转重新达到平衡。右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转。同理左旋是以某个节点为中心，将它沉入当前左子节点的位置，而让当前的右子节点作为新树的根节点，也称为逆时针旋转。 Q2：什么是红黑树？红黑树 是 1972 年发明的，称为对称二叉 B 树，1978 年正式命名红黑树。主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。红黑树和 AVL 树 类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。与 AVL 树 相比，红黑树不追求所有递归子树的高度差不超过 1，保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 O(logn)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。 红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件：① 节点只能是红色或黑色。② 根节点必须是黑色。③ 所有 NIL 节点都是黑色的。④ 一条路径上不能出现相邻的两个红色节点。⑤ 在任何递归子树中，根节点到叶子节点的所有路径上包含相同数目的黑色节点。 这五个约束条件保证了红黑树的新增、删除、查找的最坏时间复杂度均为 O(logn)。如果一个树的左子节点或右子节点不存在，则均认定为黑色。红黑树的任何旋转在 3 次之内均可完成。 Q3：AVL 树和红黑树的区别？红黑树的平衡性不如 AVL 树，它维持的只是一种大致的平衡，不严格保证左右子树的高度差不超过 1。这导致节点数相同的情况下，红黑树的高度可能更高，也就是说平均查找次数会高于相同情况的 AVL 树。 在插入时，红黑树和 AVL 树都能在至多两次旋转内恢复平衡，在删除时由于红黑树只追求大致平衡，因此红黑树至多三次旋转可以恢复平衡，而 AVL 树最多需要 O(logn) 次。AVL 树在插入和删除时，将向上回溯确定是否需要旋转，这个回溯的时间成本最差为 O(logn)，而红黑树每次向上回溯的步长为 2，回溯成本低。因此面对频繁地插入与删除红黑树更加合适。 Q4：B 树和B+ 树的区别？B 树中每个节点同时存储 key 和 data，而 B+ 树中只有叶子节点才存储 data，非叶子节点只存储 key。InnoDB 对 B+ 树进行了优化，在每个叶子节点上增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的 B+ 树，提高区间访问的性能。 B+ 树的优点在于： ① 由于 B+ 树在非叶子节点上不含数据信息，因此在内存页中能够存放更多的 key，数据存放得更加紧密，具有更好的空间利用率，访问叶子节点上关联的数据也具有更好的缓存命中率。 ② B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而 B 树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有 B+树好。但是 B 树也有优点，由于每个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，访问也更迅速。 Q5：排序有哪些分类？排序可以分为内部排序和外部排序，在内存中进行的称为内部排序，当数据量很大时无法全部拷贝到内存需要使用外存，称为外部排序。 内部排序包括比较排序和非比较排序，比较排序包括插入/选择/交换/归并排序，非比较排序包括计数/基数/桶排序。 插入排序包括直接插入/希尔排序，选择排序包括直接选择/堆排序，交换排序包括冒泡/快速排序。 Q6：直接插入排序的原理？稳定，平均/最差时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。 每一趟将一个待排序记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。 public void insertionSort(int[] nums) {for (int i = 1; i &lt; nums.length; i++) {int insertNum = nums[i];int insertIndex;for (insertIndex = i - 1; insertIndex &gt;= 0 &amp;&amp; nums[insertIndex] &gt; insertNum; insertIndex–) {nums[insertIndex + 1] = nums[insertIndex];}nums[insertIndex + 1] = insertNum;}}直接插入没有利用到要插入的序列已有序的特点，插入第 i 个元素时可以通过二分查找找到插入位置 insertIndex，再把 i~insertIndex 之间的所有元素后移一位，把第 i 个元素放在插入位置上。 123456789101112131415161718192021222324public void binaryInsertionSort(int[] nums) { for (int i = 1; i &lt; nums.length; i++) { int insertNum = nums[i]; int insertIndex = -1; int start = 0; int end = i - 1; while (start &lt;= end) { int mid = start + (end - start) / 2; if (insertNum &gt; nums[mid]) start = mid + 1; else if (insertNum &lt; nums[mid]) end = mid - 1; else { insertIndex = mid + 1; break; } } if (insertIndex == -1) insertIndex = start; if (i - insertIndex &gt;= 0) System.arraycopy(nums, insertIndex, nums, insertIndex + 1, i - insertIndex); nums[insertIndex] = insertNum; }} Q7：希尔排序的原理？又称缩小增量排序，是对直接插入排序的改进，不稳定，平均时间复杂度 O(n^1.3^)，最差时间复杂度 O(n²)，最好时间复杂度 O(n)，空间复杂度 O(1)。 把记录按下标的一定增量分组，对每组进行直接插入排序，每次排序后减小增量，当增量减至 1 时排序完毕。 123456789101112public void shellSort(int[] nums) { for (int d = nums.length / 2; d &gt; 0 ; d /= 2) { for (int i = d; i &lt; nums.length; i++) { int insertNum = nums[i]; int insertIndex; for (insertIndex = i - d; insertIndex &gt;= 0 &amp;&amp; nums[insertIndex] &gt; insertNum; insertIndex -= d) { nums[insertIndex + d] = nums[insertIndex]; } nums[insertIndex + d] = insertNum; } }} Q8：直接选择排序的原理？不稳定，时间复杂度 O(n²)，空间复杂度 O(1)。 每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余未排序序列中重复该操作直到所有元素排序完毕。 12345678910111213public void selectSort(int[] nums) { int minIndex; for (int index = 0; index &lt; nums.length - 1; index++){ minIndex = index; for (int i = index + 1;i &lt; nums.length; i++){ if(nums[i] &lt; nums[minIndex]) minIndex = i; } if (index != minIndex){ swap(nums, index, minIndex); } }} Q9：堆排序的原理？是对直接选择排序的改进，不稳定，时间复杂度 O(nlogn)，空间复杂度 O(1)。 将待排序记录看作完全二叉树，可以建立大根堆或小根堆，大根堆中每个节点的值都不小于它的子节点值，小根堆中每个节点的值都不大于它的子节点值。 以大根堆为例，在建堆时首先将最后一个节点作为当前节点，如果当前节点存在父节点且值大于父节点，就将当前节点和父节点交换。在移除时首先暂存根节点的值，然后用最后一个节点代替根节点并作为当前节点，如果当前节点存在子节点且值小于子节点，就将其与值较大的子节点进行交换，调整完堆后返回暂存的值。 1234567891011public void add(int[] nums, int i, int num){ nums[i] = num; int curIndex = i; while (curIndex &gt; 0) { int parentIndex = (curIndex - 1) / 2; if (nums[parentIndex] &lt; nums[curIndex]) swap(nums, parentIndex, curIndex); else break; curIndex = parentIndex; }} 123456789101112131415161718public int remove(int[] nums, int size){ int result = nums[0]; nums[0] = nums[size - 1]; int curIndex = 0; while (true) { int leftIndex = curIndex * 2 + 1; int rightIndex = curIndex * 2 + 2; if (leftIndex &gt;= size) break; int maxIndex = leftIndex; if (rightIndex &lt; size &amp;&amp; nums[maxIndex] &lt; nums[rightIndex]) maxIndex = rightIndex; if (nums[curIndex] &lt; nums[maxIndex]) swap(nums, curIndex, maxIndex); else break; curIndex = maxIndex; } return result;} Q10：冒泡排序的原理？稳定，平均/最坏时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。 比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，每一轮排序后末尾元素都是有序的，针对 n 个元素重复以上步骤 n -1 次排序完毕。 12345678public void bubbleSort(int[] nums) { for (int i = 0; i &lt; nums.length - 1; i++) { for (int index = 0; index &lt; nums.length - 1 - i; index++) { if (nums[index] &gt; nums[index + 1]) swap(nums, index, index + 1) } }} 当序列已经有序时仍会进行不必要的比较，可以设置一个标志记录是否有元素交换，如果没有直接结束比较。 12345678910111213public void betterBubbleSort(int[] nums) { boolean swap; for (int i = 0; i &lt; nums.length - 1; i++) { swap = true; for (int index = 0; index &lt; nums.length - 1 - i; index++) { if (nums[index] &gt; nums[index + 1]) { swap(nums, index ,index + 1); swap = false; } } if (swap) break; }} Q11：快速排序的原理？是对冒泡排序的一种改进，不稳定，平均/最好时间复杂度 O(nlogn)，元素基本有序时最坏时间复杂度 O(n²)，空间复杂度 O(logn)。 首先选择一个基准元素，通过一趟排序将要排序的数据分割成独立的两部分，一部分全部小于等于基准元素，一部分全部大于等于基准元素，再按此方法递归对这两部分数据进行快速排序。 快速排序的一次划分从两头交替搜索，直到 low 和 high 指针重合，一趟时间复杂度 O(n)，整个算法的时间复杂度与划分趟数有关。 最好情况是每次划分选择的中间数恰好将当前序列等分，经过 log(n) 趟划分便可得到长度为 1 的子表，这样时间复杂度 O(nlogn)。 最坏情况是每次所选中间数是当前序列中的最大或最小元素，这使每次划分所得子表其中一个为空表 ，这样长度为 n 的数据表需要 n 趟划分，整个排序时间复杂度 O(n²)。 1234567891011121314151617181920212223public void quickSort(int[] nums, int start, int end) { if (start &lt; end) { int pivotIndex = getPivotIndex(nums, start, end); quickSort(nums, start, pivotIndex - 1); quickSort(nums, pivotIndex + 1, end); }}public int getPivotIndex(int[] nums, int start, int end) { int pivot = nums[start]; int low = start; int high = end; while (low &lt; high) { while (low &lt;= high &amp;&amp; nums[low] &lt;= pivot) low++; while (low &lt;= high &amp;&amp; nums[high] &gt; pivot) high--; if (low &lt; high) swap(nums, low, high); } swap(nums, start, high); return high;} Q12：归并排序的原理？归并排序基于归并操作，是一种稳定的排序算法，任何情况时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。 基本原理：应用分治法将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并，使用一个辅助空间并设定两个指针分别指向两个有序序列的起始元素，将指针对应的较小元素添加到辅助空间，重复该步骤到某一序列到达末尾，然后将另一序列剩余元素合并到辅助空间末尾。 适用场景：数据量大且对稳定性有要求的情况。 1234567891011121314151617181920212223242526272829int[] help;public void mergeSort(int[] arr) { int[] help = new int[arr.length]; sort(arr, 0, arr.length - 1);}public void sort(int[] arr, int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; sort(arr, start, mid); sort(arr, mid + 1, end); merge(arr, start, mid, end);}public void merge(int[] arr, int start, int mid, int end) { if (end + 1 - start &gt;= 0) System.arraycopy(arr, start, help, start, end + 1 - start); int p = start; int q = mid + 1; int index = start; while (p &lt;= mid &amp;&amp; q &lt;= end) { if (help[p] &lt; help[q]) arr[index++] = help[p++]; else arr[index++] = help[q++]; } while (p &lt;= mid) arr[index++] = help[p++]; while (q &lt;= end) arr[index++] = help[q++];} Q13：排序算法怎么选择？数据量规模较小，考虑直接插入或直接选择。当元素分布有序时直接插入将大大减少比较和移动记录的次数，如果不要求稳定性，可以使用直接选择，效率略高于直接插入。 数据量规模中等，选择希尔排序。 数据量规模较大，考虑堆排序（元素分布接近正序或逆序）、快速排序（元素分布随机）和归并排序（稳定性）。 一般不使用冒泡。","link":"/2022/08/10/13%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"2021 IntellJ IDEA 激活码。IntellJ IDEA 激活码","text":"激活步骤 1.打开Jetbrains软件，如：PHPstorm、IntelliJ IDEA、Golang、Pycharm等 2.点击activation code 3.复制粘贴如下激活码，点击OK 目前有效期到2021年10月份，本激活码会不断更新。 VHN8U3N26D-eyJsaWNlbnNlSWQiOiJWSE44VTNOMjZEIiwibGljZW5zZWVOYW1lIjoi5YWs5LyX5Y+377yaIOeMv+S6uue8lueoiyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNDIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNGIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTViIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJEUCIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQREIiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFdTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUFMiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUEdPIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQQyIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUkIiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjEwNDA4UFBBTTAwMDAwNSIsImhhc2giOiIyMzYzNTg4My8wOjMwMjk3OTUwMyIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-WvTIuske6tbpFPNY8GS517PXzWvwo4Gg1LoLNtMEjHbRiBISmEYI9Shd0XuP1OH2eRo8rurQARB0jSrKBZbxvrT+ZBF9U+9Pu7UY7FBzt0SjSGhoNlD1tpw8Usvg7JwwbHVdJUcGTUimVZWnmkvcf2LLA7VPBG1By7tpttR1Y7iBejUp+i17kn5wwVCW5Y/rN5XqTC1pMksKF50EN0G6aPQjnBqYIHZ8c07Sne9E45HWbpuaAT7Vhs+qC/16UCaiyykZVCq3/wuQk1WYw9Qjv9oJgMzBrfCcQxsFbZVcml+A2jffY6MBxFfyacvgztLRyp3WBUb84hmruc211NkrXg==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCP4uk4SlVdA5nuA3DQC+NsEnZS9npFnO0zrmMWcz1++q2UWJNuGTh0rwi+3fUJIArfvVh7gNtIp93rxjtrQAuf4/Fa6sySp4c32MeFACfC0q+oUoWebhOIaYTYUxm4LAZ355vzt8YeDPmvWKxA81udqEk4gU9NNAOz1Um5/8LyR8SGsSc4EDBRSjcMWMwMkYSauGqGcEUK8WhfplsyF61lKSOFA6VmfUmeDK15rUWWLbOMKgn2cxFA98A+s74T9Oo96CU7rp/umDXvhnyhAXSukw/qCGOVhwKR8B6aeDtoBWQgjnvMtPgOUPRTPkPGbwPwwDkvAHYiuKJ7Bd2wH7rAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/wi9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD","link":"/2022/08/08/2021%20IntellJ%20IDEA%20%E6%BF%80%E6%B4%BB%E7%A0%81%E3%80%82IntellJ%20IDEA%20%E6%BF%80%E6%B4%BB%E7%A0%81/"},{"title":"ADB命令大全(转)","text":"ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 Other languages: :gb: English 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 查看正在运行的 Services 查看应用详细信息 查看应用安装路径 与应用交互 启动应用/ 调起 Activity 调起 Service 停止 Service 发送广播 强制停止应用 收紧内存 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 IP 地址 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 修改设置 分辨率 屏幕密度 显示区域 关闭 USB 调试模式 允许/禁止访问非 SDK API 状态栏和导航栏的显示隐藏 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 安全相关命令 启用/禁用 SELinux 启用/禁用 dm_verity 更多 adb shell 命令 查看进程 查看实时资源占用情况 查看进程 UID 其它 常见问题 启动 adb server 失败 com.android.ddmlib.AdbCommandRejectedException adb 的非官方实现 相关命令 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 INSTALL_FAILED_TEST_ONLY APK 文件是使用 Android Studio 直接 RUN 编译出来的文件 通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42} 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看应用详细信息命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;packagename&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Activity Resolver Table: Non-Data Actions: android.intent.action.MAIN: 5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc Action: &quot;android.intent.action.MAIN&quot; Category: &quot;android.intent.category.LAUNCHER&quot; AutoVerify=falseRegistered ContentProviders: org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}ContentProvider Authorities: [org.mazhuang.guanggoo.fileProvider]: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider} applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}Key Set Manager: [org.mazhuang.guanggoo] Signing KeySets: 501Packages: Package [org.mazhuang.guanggoo] (c1d7f): userId=10394 pkg=Package{55f714c org.mazhuang.guanggoo} codePath=/data/app/org.mazhuang.guanggoo-2 resourcePath=/data/app/org.mazhuang.guanggoo-2 legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib primaryCpuAbi=null secondaryCpuAbi=null versionCode=74 minSdk=15 targetSdk=25 versionName=1.1.74 splits=[base] apkSigningVersion=2 applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo} flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ RESIZEABLE_ACTIVITIES ] dataDir=/data/user/0/org.mazhuang.guanggoo supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2017-10-22 23:50:53 firstInstallTime=2017-10-22 23:50:25 lastUpdateTime=2017-10-22 23:50:55 installerPackageName=com.miui.packageinstaller signatures=PackageSignatures{af09595 [53c7caa2]} installPermissionsFixed=true installStatus=1 pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.READ_PHONE_STATE android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.READ_LOGS android.permission.WRITE_EXTERNAL_STORAGE android.permission.READ_EXTERNAL_STORAGE install permissions: android.permission.INTERNET: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0 gids=[3003] runtime permissions: android.permission.READ_EXTERNAL_STORAGE: granted=true android.permission.READ_PHONE_STATE: granted=true android.permission.WRITE_EXTERNAL_STORAGE: granted=true User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0 gids=[3003] runtime permissions:Dexopt state: [org.mazhuang.guanggoo] Instruction Set: arm64 path: /data/app/org.mazhuang.guanggoo-2/base.apk status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa te] 查看应用安装路径命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es ` --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 启动应用/ 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot; 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个： 1adb shell am startservice -n com.android.systemui/.SystemUIService 停止 Service命令格式： 1adb shell am stopservice [options] &lt;INTENT&gt; 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存命令： 1adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 IDlevel: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： 1adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API允许访问非 SDK API： 12adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： 12adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 值 含义 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed &quot;s/\\r$//&quot; &gt; sc.png Mac OS X 1adb shell screencap -p | gsed &quot;s/\\r$//&quot; &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network={ ssid=&quot;TP-LINK_9DFC&quot; scan_ssid=1 psk=&quot;123456789&quot; key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893}network={ ssid=&quot;TP-LINK_F11E&quot; psk=&quot;987654321&quot; key_mgmt=WPA-PSK sim_num=1 priority=17293} ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 安全相关命令启用/禁用 SELinux启用 SELinux 12adb rootadb shell setenforce 1 禁用 SELinux 12adb rootadb shell setenforce 0 启用/禁用 dm_verity启用 dm_verity 12adb rootadb enable-verity 禁用 dm_verity 12adb rootadb disable-verity 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID有两种方案： adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： 12$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： 123456$ adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid: 10394 10394 10394 10394gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题启动 adb server 失败出错提示 1error: protocol fault (couldn't read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 com.android.ddmlib.AdbCommandRejectedException在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示： 1234com.android.ddmlib.AdbCommandRejectedException: device unauthorized.This adb server's $ADB_VENDOR_KEYS is not setTry 'adb kill-server' if that seems wrong.Otherwise check for a confirmation dialog on your device. 在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。 于是删除该模拟器后重新下载安装一次，这次就正常了。 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 相关命令 aapt am dumsys pm uiautomator 致谢感谢朋友们无私的分享与补充（排名不分先后）。 zxning，linhua55，codeskyblue，seasonyuu，fan123199，zhEdward，0x8BADFOOD，keith666666，shawnlinboy，s-xq，lucky9322。 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）","link":"/2022/08/04/ADB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"title":"Activity布局绘制流程(转)","text":"这篇文章是承接上一篇文章(Android布局加载流程：android源码解析（十七）–&gt;Activity布局加载流程)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Activity对象也就可以说是一个窗口对象，而Window只是控制着界面布局文件的加载过程，那么界面布局文件的绘制流程是如何的呢？这篇文章主要就是顺着上篇文章的思路，看一下在android系统中Activity的布局文件是如何绘制的。 顺便在这里多说几句，android中所有能显示的东西都是通过Window对象实现了，无论Activity，Dialog，PopupWindow，Toast等。后期我可能也会讲一下Dialog，PopupWindow，Toast等组件的显示过程。 前面有一篇文章中我们介绍过Activity的启动流程，可参考：android源码解析之（十四）–&gt;Activity启动流程在执行ActivityThread的handleLauncherActivity方法中通过Window对象控制了布局文件的加载流程，而Android体系在执行Activity的onResume方法之前会回调ActivityThread的handleResumeActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } ... // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } ... } 可以看到在在获取了Activity的Window相关参数之后执行了r.activity.makeVisible()方法，看样子这个就是Activity的显示方法，这里我们来具体看一下makeVisible方法的具体实现逻辑： 12345678void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE); } 首先判断成员变量mWindowAdded是否为true，可以发现mWindowAdded成员变量只有在执行之后才能赋值为true，所以这里的代码的主要逻辑是该if分支只能执行一次。 这里的ViewManager对象是通过getWindowManager()方法获取的，我们来看一下getWindowManager()方法的具体实现: 123public WindowManager getWindowManager() { return mWindowManager; } 好吧，原来就是返回的Activity的mWindowManager的成员变量，那么这个mWindowManager的成员变量是什么时候赋值的呢？上一篇文章我们在Activity的attach方法方法中初始化了Activity的相关成员变量，这里也包括了mWindowManager，我们来看一下mWindowManager的赋值过程： 1mWindowManager = mWindow.getWindowManager(); 好吧，这里的Window.getWindowManager()方法是具体如何实现的呢？ 123public WindowManager getWindowManager() { return mWindowManager; } 那么这里的Window对象的mWindowManager成员变量是具体如何赋值的？ 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 好吧，可以发现mWindowManager = ((WindowManagerImpl)vm).createLocalWindowManager(this)原来是在这里赋值的，所以一个Activity对应这一个新的Window，而这个Window对象内部会对应着一个新的WindowManager对象，我们接着往下看，那么createLoclWindowManager方法是如何实现的呢？ 123public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mDisplay, parentWindow); } 好吧，原来是new出了一个WindowManagerImpl对象，所以回到我们的Activity的makeVisible方法，ViewManager获取的是一个WindowManagerImpl对象，所以Window对象内部的WindowManager对象其实都是一个WindowManagerImpl的实例，都是而且从继承关系上可以看到： WindowManagerImpl –&gt; WindowManager –&gt; ViewManager; 继续往下看： 1wm.addView(mDecor, getWindow().getAttributes()); 这里的mDector成员变量，通过上一篇文章的介绍，我们知道，它是Activity的界面根View，而getWindow.getAttrbutes方法是windowManager中定义的Params内部类，该内部类定义了许多的Window类型，由于这里的vm是WindowManagerImpl的实例，我们来看一下这里的addView的具体实现： 12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow); } 然后我们具体看一下mGlobal.addView方法，这里的mGlobal是一个WindowManagerGlobal的单例对象，WindowManagerGlobal是Window处理的工具类，那么WindowManagerGlobal的addView具体是如何实现的呢? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // Start watching for system property changes. if (mSystemPropertyUpdater == null) { mSystemPropertyUpdater = new Runnable() { @Override public void run() { synchronized (mLock) { for (int i = mRoots.size() - 1; i &gt;= 0; --i) { mRoots.get(i).loadSystemProperties(); } } } }; SystemProperties.addChangeCallback(mSystemPropertyUpdater); } int index = findViewLocked(view, false); if (index &gt;= 0) { if (mDyingViews.contains(view)) { // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); } else { throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); } // The previous removeView() had not completed executing. Now it has. } // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) { final int count = mViews.size(); for (int i = 0; i &lt; count; i++) { if (mRoots.get(i).mWindow.asBinder() == wparams.token) { panelParentView = mViews.get(i); } } } root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); } // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) { final int index = findViewLocked(view, false); if (index &gt;= 0) { removeViewLocked(index, true); } } throw e; } } 可以发现在WindowManagerGlobal中存在着三个数据列表： 1234private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); 其中mViews主要用于保存Activity的mDector也就是Activity的根View，而mRoots主要用于保存ViewRootImpl，mParams主要用于保存Window的LayoutParams，WindowManagerGlobal主要作为WindowManagerImpl的辅助方法类，用于操作View组件。 最后我们调用了root.setView方法，这个方法很重要我们就是在这里实现了我们的root与ViewRootImpl的关联的，除了实现了mDector与ViewRootImpl的相互关联，我们还调用了requestLayout方法，这里我们看一下setView方法的具体实现： 12345public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { ... requestLayout(); ... } 可以看到，在方法体中又调用了requestLayout方法，这个方法其实就是调用执行重绘的请求，我们来看一下这个requestLayout方法具体实现： 12345678@Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); } } 可以看到这里有一个checkThread方法，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 相信大家平时在编程的过程中肯定会遇到过这个错误，ViewRootImpl是具体更新View的管理类，所有关于View的更新操作都是在这里执行的，自然而然的对于更新线程的检测是在这个类中添加的，一般在更新UI的时候都会调用这个方法用于检测当前执行更新UI的线程是否是UI线程，否则就会抛出这个异常。 继续回到我们的requestLayout方法，这里又调用了scheduleTraversales方法，我们来看一下这个方法的具体实现： 12345678910111213void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } 这里mChoreographer.postCallback，内部会调用一个异步消息，用于执行mTraversalRunnable的run方法，这个mTraversalRunnable是一个Runnable对象，我们来看一下mTraversalRunnable类的定义： 123456final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } 在TraversalRunnable类的run方法中调用了doTraversal方法，我们来看一下这个方法的具体实现逻辑： 1234567891011121314151617void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) { Debug.startMethodTracing(&quot;ViewAncestor&quot;); } performTraversals(); if (mProfile) { Debug.stopMethodTracing(); mProfile = false; } } } 好吧，其内部又回调了方法performTraversals方法，这个方法就是整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作之后就可以展示在界面中了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121private void performTraversals() { ... // 执行View组件的onMeasure方法，主要用于测量View if (!mStopped || mReportNextDraw) { boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) { int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed! mWidth=&quot; + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth() + &quot; mHeight=&quot; + mHeight + &quot; measuredHeight=&quot; + host.getMeasuredHeight() + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) { width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; } if (lp.verticalWeight &gt; 0.0f) { height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; } if (measureAgain) { if (DEBUG_LAYOUT) Log.v(TAG, &quot;And hey let's measure once more: width=&quot; + width + &quot; height=&quot; + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } layoutRequested = true; } } } ... // 主要用于测量View组件的位置 ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, desiredWindowWidth, desiredWindowHeight); // By this point all views have been sized and positioned // We can compute the transparent area if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) { // start out transparent // TODO: AVOID THAT CALL BY CACHING THE RESULT? host.getLocationInWindow(mTmpLocation); mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1], mTmpLocation[0] + host.mRight - host.mLeft, mTmpLocation[1] + host.mBottom - host.mTop); host.gatherTransparentRegion(mTransparentRegion); if (mTranslator != null) { mTranslator.translateRegionInWindowToScreen(mTransparentRegion); } if (!mTransparentRegion.equals(mPreviousTransparentRegion)) { mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try { mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); } catch (RemoteException e) { } } } if (DBG) { System.out.println(&quot;======================================&quot;); System.out.println(&quot;performTraversals -- after setFrame&quot;); host.debug(); } } ... // 主要用于View的绘制过程 ... if (!cancelDraw &amp;&amp; !newSurface) { if (!skipDraw || mReportNextDraw) { if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).startChangingAnimations(); } mPendingTransitions.clear(); } performDraw(); } } else { if (viewVisibility == View.VISIBLE) { // Try again scheduleTraversals(); } else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).endChangingAnimations(); } mPendingTransitions.clear(); } } mIsInTraversal = false; } 可以看到在方法performTraversals方法，我们调用了performMeasure，performLayout，performDraw三个方法，这几个方法主要用于测量View组件的大小，测量View组件的位置，绘制View组件； 即：测量大小 –&gt; 测量位置 –&gt; 绘制组件 好吧，这里我们调用了performMeasure方法，我们先看一下performMeasure方法的具体实现： 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 可以看到在performMeasure方法中我们又调用了mView的measure方法，这里的mView就是我们一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法： 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... } 在View的measure方法中，又调用了onMeasure方法，由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } } 可以看到这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法，这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法，我们来看一下View的onMeasure方法： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 可以看到这个方法中调用了setMeasuredDimension方法： 123456789101112protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } 好吧，方法体里面又调用了setMeasuredDimensionRaw方法： 123456private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } 这样把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中。 继续回到我们的performTransles方法，然后我们继续看performLayout方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) { Log.v(TAG, &quot;Laying out &quot; + host + &quot; to (&quot; + host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;); } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;); try { host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) { // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) { // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = validLayoutRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during layout: running second layout pass&quot;); view.requestLayout(); } measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) { final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() { @Override public void run() { int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = finalRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during second layout pass: posting in next frame&quot;); view.requestLayout(); } } }); } } } } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mInLayout = false; } 可以看到在方法体中，我们看到该方法执行了layout方法，我们看一下该layout方法的实现： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 可以看到这个方法体中执行了onLayout方法，这个方法就是具体执行测量位置的方法了，由于我们的mDector是一个FrameLayout，所以跟measure类似的，我们看一下FrameLayout的onLayout方法的实现： 我们看到我们定义了一个循环逻辑，获取所有的validLayoutRequesters也就是需要执行Layout方法的View的集合，通过循环执行view的requestLayout方法。这里我们来看一下requestLayout方法的具体实现： 1234@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false /* no force left gravity */); } 可以看到这里调用了layoutChildren方法，让我们来看一下layoutChildren方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) { gravity = DEFAULT_CHILD_GRAVITY; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) { childLeft = parentRight - width - lp.rightMargin; break; } case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; } switch (verticalGravity) { case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; } child.layout(childLeft, childTop, childLeft + width, childTop + height); } } } 跟measure类似的，这里也是遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法，好吧，我们看一下View的layout的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 这样经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中。 好吧，经过了测量大小与测量位置的逻辑之后，我们最后看一下performTraversals方法中的performDraw方法，这个方法的作用就是执行View组件的绘制逻辑了。 12345private void performDraw() { ... draw(fullRedrawNeeded); ... } 可以看到这里调用了ViewRootImpl的draw方法，然后我们看一下draw方法的实现： 1234567private void draw(boolean fullRedrawNeeded) { ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) { return; } ... } 可以看到这里又调用了drawSoftware方法，看名字这里应该就是调用执行绘制的方法： 12345678private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) { ... mView.draw(canvas); ... return true; } 可以看到这里调用了mView的draw方法，这里的mView是我们的mDector，好吧，看一下draw方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; } /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas' layers int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) { paddingLeft += getLeftPaddingOffset(); } int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) { right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); } final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) { length = (bottom - top) / 2; } // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) { length = (right - left) / 2; } if (verticalEdges) { topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; } if (horizontalEdges) { leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; } saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) { final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) { canvas.saveLayer(left, top, right, top + length, null, flags); } if (drawBottom) { canvas.saveLayer(left, bottom - length, right, bottom, null, flags); } if (drawLeft) { canvas.saveLayer(left, top, left + length, bottom, null, flags); } if (drawRight) { canvas.saveLayer(right - length, top, right, bottom, null, flags); } } else { scrollabilityCache.setFadeColor(solidColor); } // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) { matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); } if (drawBottom) { matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, bottom - length, right, bottom, p); } if (drawLeft) { matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, left + length, bottom, p); } if (drawRight) { matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(right - length, top, right, bottom, p); } canvas.restoreToCount(saveCount); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); } 整个View的绘制流程还是比较清楚的，整个执行逻辑还有相应的注释，一共大概需要六步，并且在执行draw方法的过程中，如果包含子View，那么也会执行子View的draw方法，好吧，经过这样一系列的执行逻辑之后，mDector以及子View就被绘制出来了。 总结： Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。 View的绘制流程包含了测量大小，测量位置，绘制三个流程； Activty的界面绘制是从mDector即根View开始的，也就是从mDector的测量大小，测量位置，绘制三个流程； View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的； View的测量大小流程:performMeasure –&gt; measure –&gt; onMeasure等方法; View的测量位置流程：performLayout –&gt; layout –&gt; onLayout等方法； View的绘制流程：onDraw等方法； View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑； Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程","link":"/2022/08/06/Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"Android异常处理流程","text":"前面的几篇文章都是讲解的android中的窗口显示机制，包括Activity窗口加载绘制流程，Dialog窗口加载绘制流程，PopupWindow窗口加载绘制流程，Toast窗口加载绘制流程等等。整个Android的界面显示的原理都是类似的，都是通过Window对象控制View组件，实现加载与绘制流程。 这篇文章休息一下，不在讲解Android的窗口绘制机制，穿插的讲解一下Android系统的异常处理流程。O(∩_∩)O哈哈~ 开发过android项目的童鞋对android系统中错误弹窗，force close应该不陌生了，当我们的App异常崩溃时，就会弹出一个force close的弹窗，告诉我们App崩溃，以及一下简易的错误信息： 那么这里的force close弹窗是如何弹出的呢？ 还有我们在开发App的过程中，经常会自定义Application，自定义UncaughtExceptionHandler实现App的全局异常处理，那么这里的UncaughtExceptionHandler是如何实现对异常的全局处理的呢？（可参考： 在Android中自定义捕获Application全局异常） 带着这两个问题，我们开始今天的异常流程分析。 在android应用进程的启动流程中我们在经过一系列的操作之后会调用RuntimeInit.zygoteInit方法（可参考：Android应用程序进程启动过程的源代码分析） 而我们也是从这里开始分析我们的Android系统异常处理流程，好了，让我们先来看一下zygoteInit方法的具体实现： 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller { if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader); } 可以看到在方法体中我们调用了commonInit方法，这个方法是用于初始化操作的，继续看一下commonInit方法的实现： 12345private static final void commonInit() { ... Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); ... } 可以看到在这里我们调用了Thread.setDefaultUncaughtExceptionHandler方法，这样当我们的进程出现异常的时候，异常信息就会被我们新创建的UncaughtHandler所捕获。 看过我们前面写过的关于Android全局异常处理文章的童鞋应该知道，我们实现对Android异常全局处理的操作也是通过设置Thread.setDefaultUncaughtExceptionHandler来实现的，具体可参考： 在Android中自定义捕获Application全局异常所以Android系统默认的异常信息都会被这里的UncaughtHandler所捕获并被其uncaughtException方法回调，所以若我们不重写Thread.setDefaultUncaughtExceptionHandler方法，那么这里的UncaughtHandler就是我们默认的异常处理操作 这样我们看一下UncaughtHandler的具体实现： 123456789101112131415161718192021222324252627282930313233343536private static class UncaughtHandler implements Thread.UncaughtExceptionHandler { public void uncaughtException(Thread t, Throwable e) { try { // Don't re-enter -- avoid infinite loops if crash-reporting crashes. if (mCrashing) return; mCrashing = true; if (mApplicationObject == null) { Clog_e(TAG, &quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot; + t.getName(), e); } else { StringBuilder message = new StringBuilder(); message.append(&quot;FATAL EXCEPTION: &quot;).append(t.getName()).append(&quot;\\n&quot;); final String processName = ActivityThread.currentProcessName(); if (processName != null) { message.append(&quot;Process: &quot;).append(processName).append(&quot;, &quot;); } message.append(&quot;PID: &quot;).append(Process.myPid()); Clog_e(TAG, message.toString(), e); } // Bring up crash dialog, wait for it to be dismissed ActivityManagerNative.getDefault().handleApplicationCrash( mApplicationObject, new ApplicationErrorReport.CrashInfo(e)); } catch (Throwable t2) { try { Clog_e(TAG, &quot;Error reporting crash&quot;, t2); } catch (Throwable t3) { // Even Clog_e() fails! Oh well. } } finally { // Try everything to make sure this process goes away. Process.killProcess(Process.myPid()); System.exit(10); } } } 这里uncaughtException方法最终会被执行异常信息的处理，我们看一下在这里我们调用了ActivityManagerNative.getDefault().handleApplicationCrash方法，看过我们前面Activity启动流程的童鞋应该知道这里的ActivityManagerNative其实是ActivityManagerService的Binder客户端，而这里的handleApplicationCrash方法最终会调用的是ActivityManagerService的handleApplicationCrash方法。最后在finally分之中，我们调用了Process.killProcess(Process.myPid)和System.exit(10)，这样我们的应用进程就会退出了。 然后我们在这里先简单的分析一下Binder的数据传输过程，看一下handleApplicationCrash方法具体做了哪些事，首先看一下ActivityManagerNative的getDefault方法是如何实现的？ 123static public IActivityManager getDefault() { return gDefault.get(); } 可以发现，其是一个静态方法，并执行了gDefault.get方法，我们在看一下gDefault.get方法的实现逻辑： 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现这里返回一个IActivityManager类型的am对象，而这个am对象是通过调用asInterface方法创建的，我们再来看一下这个asInterface方法的实现逻辑。 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 可以发现该方法最终返回的是一个ActivityManagerProxy对象，所以ActivityManagerNative.getDefault()方法最终返回的是一个ActivityManagerProxy对象，我们再来看一下ActivityManagerProxy的handleApplicationCrash方法。 12345678910111213public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app); crashInfo.writeToParcel(data, 0); mRemote.transact(HANDLE_APPLICATION_CRASH_TRANSACTION, data, reply, 0); reply.readException(); reply.recycle(); data.recycle(); } 这里就是具体的Binder传输数据的逻辑了，这里ActivityManagerNative最为Binder的clent端，而我们的ActivityManagerService同样是继承与ActivityManagerNative，最为Binder的server端，通过传输最终ActivityManagerService的handleApplicationCrash方法会被执行。 1234567public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) { ProcessRecord r = findAppProcess(app, &quot;Crash&quot;); final String processName = app == null ? &quot;system_server&quot; : (r == null ? &quot;unknown&quot; : r.processName); handleApplicationCrashInner(&quot;crash&quot;, r, processName, crashInfo); } 可以看到在ActivityManagerService的handleApplicationCrash方法中我们调用了handleApplicationCreashInner方法，这样我们继续看一下handleApplicationCrashInner方法的实现。 1234567891011121314void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) { EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber); addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo); crashApplication(r, crashInfo); } 可以发现在handleApplicationCrashInner方法中主要调用了两个方法addErrorToDropBox和crashApplication，我们首先看一下addErrorToDropBox方法的实现逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, final String report, final File logFile, final ApplicationErrorReport.CrashInfo crashInfo) { // NOTE -- this must never acquire the ActivityManagerService lock, // otherwise the watchdog may be prevented from resetting the system. final String dropboxTag = processClass(process) + &quot;_&quot; + eventType; final DropBoxManager dbox = (DropBoxManager) mContext.getSystemService(Context.DROPBOX_SERVICE); // Exit early if the dropbox isn't configured to accept this report type. if (dbox == null || !dbox.isTagEnabled(dropboxTag)) return; final StringBuilder sb = new StringBuilder(1024); appendDropBoxProcessHeaders(process, processName, sb); if (activity != null) { sb.append(&quot;Activity: &quot;).append(activity.shortComponentName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid != process.pid) { sb.append(&quot;Parent-Process: &quot;).append(parent.app.processName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent != activity) { sb.append(&quot;Parent-Activity: &quot;).append(parent.shortComponentName).append(&quot;\\n&quot;); } if (subject != null) { sb.append(&quot;Subject: &quot;).append(subject).append(&quot;\\n&quot;); } sb.append(&quot;Build: &quot;).append(Build.FINGERPRINT).append(&quot;\\n&quot;); if (Debug.isDebuggerConnected()) { sb.append(&quot;Debugger: Connected\\n&quot;); } sb.append(&quot;\\n&quot;); // Do the rest in a worker thread to avoid blocking the caller on I/O // (After this point, we shouldn't access AMS internal data structures.) Thread worker = new Thread(&quot;Error dump: &quot; + dropboxTag) { @Override public void run() { if (report != null) { sb.append(report); } if (logFile != null) { try { sb.append(FileUtils.readTextFile(logFile, DROPBOX_MAX_SIZE, &quot;\\n\\n[[TRUNCATED]]&quot;)); } catch (IOException e) { Slog.e(TAG, &quot;Error reading &quot; + logFile, e); } } if (crashInfo != null &amp;&amp; crashInfo.stackTrace != null) { sb.append(crashInfo.stackTrace); } String setting = Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag; int lines = Settings.Global.getInt(mContext.getContentResolver(), setting, 0); if (lines &gt; 0) { sb.append(&quot;\\n&quot;); // Merge several logcat streams, and take the last N lines InputStreamReader input = null; try { java.lang.Process logcat = new ProcessBuilder(&quot;/system/bin/logcat&quot;, &quot;-v&quot;, &quot;time&quot;, &quot;-b&quot;, &quot;events&quot;, &quot;-b&quot;, &quot;system&quot;, &quot;-b&quot;, &quot;main&quot;, &quot;-b&quot;, &quot;crash&quot;, &quot;-t&quot;, String.valueOf(lines)).redirectErrorStream(true).start(); try { logcat.getOutputStream().close(); } catch (IOException e) {} try { logcat.getErrorStream().close(); } catch (IOException e) {} input = new InputStreamReader(logcat.getInputStream()); int num; char[] buf = new char[8192]; while ((num = input.read(buf)) &gt; 0) sb.append(buf, 0, num); } catch (IOException e) { Slog.e(TAG, &quot;Error running logcat&quot;, e); } finally { if (input != null) try { input.close(); } catch (IOException e) {} } } dbox.addText(dropboxTag, sb.toString()); } }; if (process == null) { // If process is null, we are being called from some internal code // and may be about to die -- run this synchronously. worker.run(); } else { worker.start(); } } 可以看到方法体很长，但是逻辑比较简单，在方法体最后通过判断应用进程是否为空（是否被销毁）来执行worker.run方法或者是worker.start方法，这里的worker是一个Thread对象，而在我们的worker对象的run方法中主要的执行逻辑就是将崩溃信息写入系统log中，所以addErrorToDropBox方法的主要执行逻辑就是讲App的崩溃信息写入系统log中。。。。 继续回到我们的handleApplicationCrashInner方法中，看一下crashApplication方法是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) { long timeMillis = System.currentTimeMillis(); String shortMsg = crashInfo.exceptionClassName; String longMsg = crashInfo.exceptionMessage; String stackTrace = crashInfo.stackTrace; if (shortMsg != null &amp;&amp; longMsg != null) { longMsg = shortMsg + &quot;: &quot; + longMsg; } else if (shortMsg != null) { longMsg = shortMsg; } AppErrorResult result = new AppErrorResult(); synchronized (this) { if (mController != null) { try { String name = r != null ? r.processName : null; int pid = r != null ? r.pid : Binder.getCallingPid(); int uid = r != null ? r.info.uid : Binder.getCallingUid(); if (!mController.appCrashed(name, pid, shortMsg, longMsg, timeMillis, crashInfo.stackTrace)) { if (&quot;1&quot;.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, &quot;0&quot;)) &amp;&amp; &quot;Native crash&quot;.equals(crashInfo.exceptionClassName)) { Slog.w(TAG, &quot;Skip killing native crashed app &quot; + name + &quot;(&quot; + pid + &quot;) during testing&quot;); } else { Slog.w(TAG, &quot;Force-killing crashed app &quot; + name + &quot; at watcher's request&quot;); if (r != null) { r.kill(&quot;crash&quot;, true); } else { // Huh. Process.killProcess(pid); killProcessGroup(uid, pid); } } return; } } catch (RemoteException e) { mController = null; Watchdog.getInstance().setActivityController(null); } } final long origId = Binder.clearCallingIdentity(); // If this process is running instrumentation, finish it. if (r != null &amp;&amp; r.instrumentationClass != null) { Slog.w(TAG, &quot;Error in app &quot; + r.processName + &quot; running instrumentation &quot; + r.instrumentationClass + &quot;:&quot;); if (shortMsg != null) Slog.w(TAG, &quot; &quot; + shortMsg); if (longMsg != null) Slog.w(TAG, &quot; &quot; + longMsg); Bundle info = new Bundle(); info.putString(&quot;shortMsg&quot;, shortMsg); info.putString(&quot;longMsg&quot;, longMsg); finishInstrumentationLocked(r, Activity.RESULT_CANCELED, info); Binder.restoreCallingIdentity(origId); return; } // Log crash in battery stats. if (r != null) { mBatteryStatsService.noteProcessCrash(r.processName, r.uid); } // If we can't identify the process or it's already exceeded its crash quota, // quit right away without showing a crash dialog. if (r == null || !makeAppCrashingLocked(r, shortMsg, longMsg, stackTrace)) { Binder.restoreCallingIdentity(origId); return; } Message msg = Message.obtain(); msg.what = SHOW_ERROR_MSG; HashMap data = new HashMap(); data.put(&quot;result&quot;, result); data.put(&quot;app&quot;, r); msg.obj = data; mUiHandler.sendMessage(msg); Binder.restoreCallingIdentity(origId); } int res = result.get(); Intent appErrorIntent = null; synchronized (this) { if (r != null &amp;&amp; !r.isolated) { // XXX Can't keep track of crash time for isolated processes, // since they don't have a persistent identity. mProcessCrashTimes.put(r.info.processName, r.uid, SystemClock.uptimeMillis()); } if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) { appErrorIntent = createAppErrorIntentLocked(r, timeMillis, crashInfo); } } if (appErrorIntent != null) { try { mContext.startActivityAsUser(appErrorIntent, new UserHandle(r.userId)); } catch (ActivityNotFoundException e) { Slog.w(TAG, &quot;bug report receiver dissappeared&quot;, e); } } } 可以发现在方法体中我们调用了mUiHandler.sendMessage(msg)，其中mUiHandler是一个在主线程中创建的Handler对象，而这里的msg是一个what值为SHOW_ERROR_MSG的消息，这句话的本质就是向Ui线程中发送一个异步消息。我们来看一下mUiHander的处理逻辑。 在mUiHandler的handeMessage方法中，根据what值得不同，执行了如下逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243case SHOW_ERROR_MSG: { HashMap&lt;String, Object&gt; data = (HashMap&lt;String, Object&gt;) msg.obj; boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0; synchronized (ActivityManagerService.this) { ProcessRecord proc = (ProcessRecord)data.get(&quot;app&quot;); AppErrorResult res = (AppErrorResult) data.get(&quot;result&quot;); if (proc != null &amp;&amp; proc.crashDialog != null) { Slog.e(TAG, &quot;App already has crash dialog: &quot; + proc); if (res != null) { res.set(0); } return; } boolean isBackground = (UserHandle.getAppId(proc.uid) &gt;= Process.FIRST_APPLICATION_UID &amp;&amp; proc.pid != MY_PID); for (int userId : mCurrentProfileIds) { isBackground &amp;= (proc.userId != userId); } if (isBackground &amp;&amp; !showBackground) { Slog.w(TAG, &quot;Skipping crash dialog of &quot; + proc + &quot;: background&quot;); if (res != null) { res.set(0); } return; } if (mShowDialogs &amp;&amp; !mSleeping &amp;&amp; !mShuttingDown) { Dialog d = new AppErrorDialog(mContext, ActivityManagerService.this, res, proc); d.show(); proc.crashDialog = d; } else { // The device is asleep, so just pretend that the user // saw a crash dialog and hit &quot;force quit&quot;. if (res != null) { res.set(0); } } } ensureBootCompleted(); } 可以看到在方法体中我们创建了一个AppErrorDialog对象，并执行了show方法，这样该Dialog就会被显示出来。而这里的Dialog的显示内容就是：App already has crash dialog: …. O(∩_∩)O哈哈~，原来我们App崩溃的时候弹出昂的异常提示框就是在这里弹出来的。这里对AppErrorDialog不做过多的介绍，在其的构造方法中，调用了如下的代码： 1234// After the timeout, pretend the user clicked the quit button mHandler.sendMessageDelayed( mHandler.obtainMessage(FORCE_QUIT), DISMISS_TIMEOUT); 这里的常量DISMISS_TIME = 5 * 60 * 1000，也就是五分钟，相当于这里发送了一个延时异步消息五分钟之后取消崩溃弹窗的显示。所以我们的App若果崩溃之后不主动取消弹窗，崩溃弹窗也会默认在五分钟之后取消。 好吧，文章开头我们所提到的两个问题我们已经解决掉一个了，force close弹窗是如何弹出来的，相信大家已经有所了解了，其实第二个问题也已经说明了，我们知道系统默认的App异常处理流程就是从Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());开始的，并创建了自己的UncaughtHandler对象，那么我们接管系统默认的异常处理逻辑其实也就是从Thread.setDefaultUncaughtExceptionHandler开始的，并重写其uncaughtException方法，那么App异常信息就会被我们自定义的UncaughtHandler所捕获，捕获之后奔溃信息的记录与上报就可以做定制了。。。 这样我们就大概分析完成了Android系统的异常处理流程。O(∩_∩)O哈哈~ 总结： App应用进程启动时会经过一系列的调用，执行Thread.setDefaultUncaughtExceptionHandler方法，创建默认的UncaughtHandler异常处理对象。 默认的UncaughtHandler异常处理对象，在其回调方法uncaughtException方法中会执行弹窗异常弹窗的操作，这也就是我们原生的force close弹窗，并且弹窗如果不主动取消的话，会在五分钟内默认取消。 自定义App的全局异常处理逻辑，需要接管UncaughtHandler，也就是创建自身的UncaughtHandler对象，并调用Thread.setDefaultUncaughtExceptionHandler方法，接管默认的异常处理逻辑。 force close弹窗，弹窗的时候App应用可能已经退出，该弹窗的弹窗是SystemServer进程中的ActivityManagerService服务控制的。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程","link":"/2022/08/06/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"title":"Activity布局加载流程(转)","text":"好吧，终于要开始讲讲Activity的布局加载流程了，大家都知道在Android体系中Activity扮演了一个界面展示的角色，这也是它与android中另外一个很重要的组件Service最大的不同，但是这个展示的界面的功能是Activity直接控制的么？界面的布局文件是如何加载到内存并被Activity管理的？android中的View是一个怎样的概念？加载到内存中的布局文件是如何绘制出来的？ 要想回答这些问题，我们就需要对android的界面加载与绘制流程有所了解，这里我们先来学习一下Activity的布局加载的流程。而至于Acitivty的布局绘制流程我们在下一篇中在做介绍。 其实Activity对界面布局的管理是都是通过Window对象来实现的，Window对象，顾名思义就是一个窗口对象，而Activity从用户角度就是一个个的窗口实例，因此不难想象每个Activity中都对应着一个Window对象，而这个Window对象就是负责加载显示界面的。至于window对象是如何展示不同的界面的，那是通过定义不同的View组件实现不同的界面展示。 废话不多说了，不知道大家是否还记得我们讲过的Activity的启动流程么？不熟悉的童鞋可以参考： android源码解析之（十四）–&gt;Activity启动流程 ，在文章中我们介绍到当ActivityManagerService接收到启动Activity的请求之后会通过IApplicationThread进程间通讯告知ApplicationThread并执行handleLauncherActivity方法，这里我们可以下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) { mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); } // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, &quot;Handling launch of &quot; + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // The activity manager actually wants this one to start out // paused, because it needs to be visible but isn't in the // foreground. We accomplish this by going through the // normal startup (because activities expect to go through // onResume() the first time they run, before their window // is displayed), and then pausing it. However, in this case // we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just // retain the current state it has. try { r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); // We need to keep around the original state, in case // we need to be created again. But we only do this // for pre-Honeycomb apps, which always save their state // when pausing, so we can not have them save their state // when restarting from a paused state. For HC and later, // we want to (and can) let the state be saved as the normal // part of stopping the activity. if (r.isPreHoneycomb()) { r.state = oldState; } if (!r.activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPause()&quot;); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to pause activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.paused = true; } } else { // If there was an error, for any reason, tell the activity // manager to stop us. try { ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { // Ignore } } } 可以发现这里的handleLauncherActivity方法内部调用了performLaunchActivity方法，这个方法也是具体启动Activity的方法，我们来看一下它的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ... return activity; } 从代码中可以看到这里是通过反射的机制创建的Activity，并调用了Activity的attach方法，那么这里的attach方法是做什么的呢？我们继续来看一下attach方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 可以看到在attach方法这里初始化了一些Activity的成员变量，主要是mWindow对象，并且mWindow的成员实例是PhoneWindow实例，这样也从侧面说明了一个Activity对应着一个Window对象。除了window对象还初始化了一些Activity的其他成员变量，这里不再做讨论，继续回到我们的performLaunchActivity方法，在调用了Activity的attach方法之后又调用了： 1mInstrumentation.callActivityOnCreate(activity, r.state); 这里的mInstrumentation是类Instrumentation，每个应用进程对应着一个Instrumentation和一个ActivityThread，Instrumentation就是具体操作Activity回调其生命周期方法的，我们这里看一下它的callActivityOnCreate方法的实现： 12345public void callActivityOnCreate(Activity activity, Bundle icicle) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 这里代码比较简洁，preOerformCreate方法和postPerformCreate方法我们这里暂时不管，主要的执行逻辑是调用了activity.performCreate方法，我们来看一下Activity的performCreate方法的实现： 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } 原来onCreate的生命周期方法是在这里回调的，其实这里的逻辑在前面几篇文章中有讲述，也可以参考前面的文章。 至此我们就回调到了我们Activity的onCreate方法，大家平时在重写onCreate方法的时候，怎么加载布局文件的呢？这里看一下我们的onCreate方法的典型写法： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 无论我们怎么变化，我们的onCreate方法一般都是会调用这两句话的吧？那么这里的两段代码分辨是什么含义呢？我们首先看一下super.onCreate方法的实现逻辑，由于我们的Activity类继承与Activity，所以这里的super.onCreate方法，就是调用的Activity.onCreate方法，好吧，既然这样我们来看一下Activity的onCreate方法： 123456789101112131415161718192021222324protected void onCreate(@Nullable Bundle savedInstanceState) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (mLastNonConfigurationInstances != null) { mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); } if (mActivityInfo.parentActivityName != null) { if (mActionBar == null) { mEnableDefaultActionBarUp = true; } else { mActionBar.setDefaultDisplayHomeAsUpEnabled(true); } } if (savedInstanceState != null) { Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(this, savedInstanceState); if (mVoiceInteractor != null) { mVoiceInteractor.attachActivity(this); } mCalled = true; } 可以发现，Activity的onCreate方法主要是做了一些Acitivty的初始化操作，那么如果我们不在自己的Activity调用super.onCreate方法呢？好吧，尝试之后，AndroidStudio在打开的Acitivty的onCreate方法中如果不调用super.onCreate方法的话，会报错。。。有木有搞错。。。 1FATAL EXCEPTION: main Process: com.example.aaron.helloworld, PID: 18001 android.util.SuperNotCalledException: Activity {com.example.aaron.helloworld/com.example.aaron.helloworld.SecondActivity} did not call through to super.onCreate() at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2422) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2528) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5552) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 可以看到如果不调用super.onCreate方法的话，会在Activity的performLaunchActivity中报错，我们知道这里的performLaunchActivity方法就是我们启动Activity的时候回回调的方法，我们找找方法体实现中throws的Exception。。。 1234567891011activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } 在Activity的performLaunchActivity方法中，我们在调用了Activity的onCreate方法之后会执行一个判断逻辑，若Activity的mCalled为false，则会抛出我们刚刚捕获的异常，那么这个mCalled成员变量是在什么时候被赋值的呢？好吧，就是在Activity的onCreate方法赋值的，所以我们在实现自己的Activity的时候只有调用了super.onCreate方法才不会抛出这个异常，反过来说，我们实现自己的Actiivty，那么一定要在onCreate方法中调用super.onCreate方法。 然后我们在看一下onCreate中的setContentView方法，这里的参数就是一个Layout布局文件，可以发现这里的setContentView方法就是Acitivty中的setContentView，好吧我们来看一下Activity中setContentView的实现： 1234public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 这里的getWindow方法就是获取Acitivty的mWindow成员变量，从刚刚我们在Activity.attach方法我们知道这里的mWindow的实例是PhoneWindow，所以这里调用的其实是PhoneWindow的setConentView方法，然后我们看一下PhoneWindow的setContentView是如何实现的。 123456789101112131415161718192021222324@Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } } 这里的mContentParent对象是一个View对象，由于第一次mContentParent为空，所以执行installerDector方法，这里我们看一下installerDector方法的具体实现： 1234567891011private void installDecor() { if (mDecor == null) { mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } ... } 这里的mDector是一个DectorView对象，而DectorView继承与FrameLayout，所以这里的mDector其实就是一个FrameLayout对象，并通过调用generateDector()方法初始化，我们继续看一下generateDector方法的具体实现： 123protected DecorView generateDecor() { return new DecorView(getContext(), -1); } 好吧，就是通过new的方式创建了一个DectorView对象，然后我们继续看installDector方法： 12if (mContentParent == null) { mContentParent = generateLayout(mDecor); 这里初始化了mContentParent对象，这是一个View对象，我们调用了generateLayout方法，好吧，来看一下generateLayout方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122protected ViewGroup generateLayout(DecorView decor) { ... // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { layoutResource = R.layout.screen_swipe_dismiss; } else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) { if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_title_icons; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println(&quot;Title Icons!&quot;); } else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) { // Special case for a window with only a progress bar (and title). // XXX Need to have a no-title version of embedded windows. layoutResource = R.layout.screen_progress; // System.out.println(&quot;Progress!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) { // Special case for a window with a custom title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_custom_title; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) { // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) { layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); } else { layoutResource = R.layout.screen_title; } // System.out.println(&quot;Title!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) { layoutResource = R.layout.screen_simple_overlay_action_mode; } else { // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println(&quot;Simple!&quot;); } mDecor.startChanging(); View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) { throw new RuntimeException(&quot;Window couldn't find content container view&quot;); } if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) { ProgressBar progress = getCircularProgressBar(false); if (progress != null) { progress.setIndeterminate(true); } } if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { registerSwipeCallbacks(); } // Remaining setup -- of background and title -- that only applies // to top-level windows. if (getContainer() == null) { final Drawable background; if (mBackgroundResource != 0) { background = getContext().getDrawable(mBackgroundResource); } else { background = mBackgroundDrawable; } mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) { frame = getContext().getDrawable(mFrameResource); } else { frame = null; } mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) { setTitle(mTitle); } if (mTitleColor == 0) { mTitleColor = mTextColor; } setTitleColor(mTitleColor); } mDecor.finishChanging(); return contentParent; } 可以发现这里就是通过调用LayoutInflater.inflate方法来加载布局文件到内存中，关于LayoutInflater.inflater是如何加载布局文件的，并且，通过对代码的分析，我们发现PhoneWindow中的几个成员变量：mDector，mContentRoot，mContentParent的关系mDector –&gt; mContentRoot –&gt; mContentParent（包含）并且我们来看一下典型的布局文件： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 这里就是整个Activity加载的跟布局文件：screen_simple.xml，其中ViewStub对应着Activity中的titleBar而这里的FrameLayout里面主要用于填充内容。 然后我们具体看一下LayoutInflater.inflater方法： 123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null); } 这里调用了inflate的重载方法。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try { // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) { // Empty } if (type != XmlPullParser.START_TAG) { throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); } final String name = parser.getName(); if (DEBUG) { System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); } if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } rInflate(parser, root, inflaterContext, attrs, false); } else { // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) { if (DEBUG) { System.out.println(&quot;Creating params from root: &quot; + root); } // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) { // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); } } if (DEBUG) { System.out.println(&quot;-----&gt; start inflating children&quot;); } // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) { System.out.println(&quot;-----&gt; done inflating children&quot;); } // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; } catch (Exception e) { InflateException ex = new InflateException( parser.getPositionDescription() + &quot;: &quot; + e.getMessage()); ex.initCause(e); throw ex; } finally { // Don't retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; } Trace.traceEnd(Trace.TRACE_TAG_VIEW); return result; } } 通过分析源码，不难发现，主要是通过循环解析xml文件并将信息解析到内存View对象，布局文件中定义的一个个组件都被顺序的解析到了内存中并被父子View的形式组织起来，这样通过给定的一个root View就可以将整个布局文件中定义的组件全部解析。分析完解析布局文件，回到我们的setContentVIew方法，在调用了installDector方法之后，又调用了： 1mLayoutInflater.inflate(layoutResID, mContentParent); 这个方法的含义就是将我们传递的客户端的layoutId对应的布局文件作为mContentParent的子View加载到内存中，这样我们的layoutId作为mContentParent的子View，而mContentParent又是mContentRoot的子View，mContentRoot又是mDector的子View，通过LayoutInflater的inflate方法逐步加载到了内存中，而我们的Activity又持有自身的PhoneWindow的引用，这就相当于我们的Activity持有了我们定义的布局文件的引用，因而Activity的布局文件被加载到了内存中。 总结： Activity的展示界面的特性是通过Window对象来控制的； 每个Activity对象都对应这个一个Window对象，并且Window对象的初始化在启动Activity的时候完成，在执行Activity的onCreate方法之前； 每个Window对象内部都存在一个FrameLayout类型的mDector对象，它是Acitivty界面的root view； Activity中的window对象的实例是PhoneWindow对象，PhoneWindow对象中的几个成员变量mDector，mContentRoot，mContentParent都是View组件，它们的关系是：mDector –&gt; mContentRoot –&gt; mContentParent –&gt; 自定义layoutView LayoutInflater.inflate主要用于将布局文件加载到内存View组件中，也可以设定加载到某一个父组件中； 典型的Activity的onCreate方法中需要调用super.onCreate方法和setContentView方法，若不调用super.onCreate方法，执行启动该Activity的逻辑会报错，若不执行setContentView的方法，该Activity只会显示一个空页面。 好了，关于Activity的布局加载流程我们暂时介绍这么多，下一篇文章，我们将介绍一下Activity的布局显示流程。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程","link":"/2022/08/06/Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"},{"title":"Android 基础知识总结","text":"Activity生命周期 img Fragment生命周期 Activity****四种启动模式 standard : 标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(onCreate()-&gt;onStart()-&gt;onResume())都会执行。 singleTop : 栈顶复用模式.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用与standard**模式一样. singleTask: 栈内复用模式.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.(clear top) singleInstance : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了 Service的生命周期与启动方法由什么区别****？ startService()：开启Service，调用者退出后Service仍然存在。 bindService()：开启Service，调用者退出后Service也随即退出。 Service****生命周期： 只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory 只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 广播发送和接收的原理了解吗？ 继承BroadcastReceiver，重写onReceive()方法。 通过Binder机制向ActivityManagerService注册广播。 通过Binder机制向ActivityMangerService发送广播。 ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。 BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。、 Android Handler机制是做什么的，原理了解吗 主要涉及的角色如下所示： 1.Message:消息,分为硬件产生的消息（例如:按钮、触摸）和软件产生的消息。 2. MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。 3. Looper：消息循环器，主要用来把消息分发给相应的处理者。 4. Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。 整个消息的循环流程还是比较清晰的，具体说来： 1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。 2. Looper通过loop()循环提取触发Message,并将Message交给对应的target handler来处理。 3. target handler调用自身的handleMessage()方法来处理Message。 如何自定义android控件 自定义属性的声明和获取 分析需要的自定义属性 在res/values/attrs.xml定义声明 在layout文件中进行使用 在View的构造方法中进行获取 测量onMeasure(int widthMeasureSpec, int heightMeasureSpec) 布局onLayout(boolean changed, int left, int top, int right, int bottom) 绘制onDraw(Canvas canvas) onTouchEvent onInterceptTouchEvent(ViewGroup) 状态的恢复与保存 描述一下View的绘制原理？ View的绘制流程主要分为三步： onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成测量工作。 onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。 onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。 ④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。 *requestLayout()、invalidate()与postInvalidate()有什么区别*？ requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定 会触发onDraw()方法。 invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会 触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。 postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。 APK的打包流程 1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。 2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。 3. 通过Javac工具编译项目源码，生成Class文件。 4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。 5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。 6. 利用KeyStore对生成的APK文件进行签名。 7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件 的速度会更快。 (adsbygoogle = window.adsbygoogle || []).push({}); APK的安装流程 1. 复制APK到/data/app目录下，解压并扫描安装包。 2. 资源管理器解析APK里的资源文件。 3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。 4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。 5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。 6. 安装完成后，发送广播。 Android Binder机制是做什么的，为什么选用Binder，原理了解吗****？ Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。 为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种： 管道：在创建时分配一个page大小的内存，缓存区大小比较有限； 消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 \\6. 信号 : 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进 程等； 既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量： 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全 是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。","link":"/2022/08/04/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/"},{"title":"Android 经典蓝牙通讯传输Demo","text":"BlueUtils经典蓝牙搜索，连接，数据传输小DEMO 通过经典模式 搜索 蓝牙应用。蓝牙有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别。BLE 蓝牙不做过多讲解。具体的信息大家可以参考。 https://www.jianshu.com/p/fc46c154eb77 (经典蓝牙) https://www.jianshu.com/p/3a372af38103 (BLE蓝牙) 流程 发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信 经典蓝牙和低功耗蓝牙除了配对/绑定这个环节是一样的之外，其它三个环节都是不同的。 截图 详解 公司最近在要做一个蓝牙与串口通讯的项目，然后就涉及到手机端与蓝牙的连接及数据交互。大致需求就是通过手机搜索硬件蓝牙 设备，然后连接上蓝牙，通过手机端的指令消息来获取串口信息，在通过蓝牙返回数据到手机端。在这之前看了一些开源的项目， 包括BluetoothKit，FastBle，BluetoothHelper等其中BluetoothKit和FastBle只支持BLE 模式蓝牙，因为硬件的模式是 经典模式，后来自己在两个项目的基础上做了一些修改，然后可以搜索到经典蓝牙。但是怎么也是连接不上我们的硬件设备。（应 该是底层不是经典蓝牙连接导致。）后来发现了BluetoothHelper项目。在这个项目的基础上做了一些修改及优化 ，能够满足 项目需求，现在将这个项目做了分包及优化。然后在这分享自己的一些踩坑心得。 第一步：声明所需要的权限&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt; 使用蓝牙所需要的权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 使用扫描和设置蓝牙的权限（申明这一个权限必须申明上面一个权限） 在Android5.0之前，是默认申请GPS硬件功能的。而在Android 5.0 之后，需要在manifest 中申明GPS硬件模块功能的使用。 &lt;!-- Needed only if your app targets Android 5.0 (API level 21) or higher. --&gt; &lt;uses-feature android:name=&quot;android.hardware.location.gps&quot; /&gt; 在 Android 6.0 及以上，还需要打开位置权限。如果应用没有位置权限，蓝牙扫描功能不能使用（其它蓝牙操作例如连接蓝牙设备和写入数据不受影响）。 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 第二步：初始化实例在页面首先初始化一个BlueManager。 private BlueManager bluemanage; bluemanage = BlueManager.getInstance(getApplicationContext()); 第三步：设置实例监听 然后为这个蓝牙管理器设置监听(OnSearchDeviceListener，OnConnectListener，OnSendMessageListener，OnReceiveMessageListener) /** * 初始化蓝牙管理，设置监听 */ public void initBlueManager() { bluemanage = BlueManager.getInstance(getApplicationContext()); bluemanage.setOnSearchDeviceListener(onSearchDeviceListener); bluemanage.setOnConnectListener(onConnectListener); bluemanage.setOnSendMessageListener(onSendMessageListener); bluemanage.setOnReceiveMessageListener(onReceiveMessageListener); bluemanage.requestEnableBt(); } 第四步：开启蓝牙搜索蓝牙设备 通过调用 bluemanage.requestEnableBt()开启蓝牙， 调用searchDevices 获取蓝牙设备。在做蓝牙操作前，要确保各个监听器已经设置好。 搜索监听如下： onSearchDeviceListener =new OnSearchDeviceListener() { @Override public void onStartDiscovery() { Log.d(TAG, &quot;onStartDiscovery()&quot;); } @Override public void onNewDeviceFound(BluetoothDevice device) { Log.d(TAG, &quot;new device: &quot; + device.getName() + &quot; &quot; + device.getAddress()); } @Override public void onSearchCompleted(List&lt;BluetoothDevice&gt; bondedList, List&lt;BluetoothDevice&gt; newList) { Log.d(TAG, &quot;SearchCompleted: bondedList&quot; + bondedList.toString()); Log.d(TAG, &quot;SearchCompleted: newList&quot; + newList.toString()); } @Override public void onError(Exception e) { e.printStackTrace(); } } 通过 BlueManager里的searchDevices方法，里边其实就是获取了一个BluetoothAdapter然后，通过调用mBluetoothAda pter.startDiscovery()方法来搜索经典蓝牙设备。这里如果调用 mBluetoothAdapter.startLeScan(mLeScanCallback); 搜索的就是BLE蓝牙。然后在这之前需要动态注册一个BroadcastReceiver来监听 蓝牙的搜索情况，在通过onReceive中去判 断设备的类型，是不是新设备，是不是已经连接过。将设备加入集合当中。 搜索代码如下 /** * discovery the devices. */ public void searchDevices() { try { if (mCurrStatus == STATUS.FREE) { mCurrStatus = STATUS.DISCOVERING; checkNotNull(mOnSearchDeviceListener); if (mBondedList == null) mBondedList = new ArrayList&lt;&gt;(); if (mNewList == null) mNewList = new ArrayList&lt;&gt;(); if (mBluetoothAdapter == null) { mOnSearchDeviceListener.onError(new NullPointerException(DEVICE_HAS_NOT_BLUETOOTH_MODULE)); return; } if (mReceiver == null) mReceiver = new Receiver(); // ACTION_FOUND IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); mContext.registerReceiver(mReceiver, filter); // ACTION_DISCOVERY_FINISHED filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); mContext.registerReceiver(mReceiver, filter); mNeed2unRegister = true; mBondedList.clear(); mNewList.clear(); if (mBluetoothAdapter.isDiscovering()) //先判断是否在扫描 mBluetoothAdapter.cancelDiscovery();//取消扫描 mBluetoothAdapter.startDiscovery(); //开始扫描蓝牙 mOnSearchDeviceListener.onStartDiscovery(); } } catch (Exception e) { e.printStackTrace(); } } 第五步：连接蓝牙设备 当调用connectDevice(mac)方法时，因为连接蓝牙是一很耗时的操作，所以需要开启一个线程去连接蓝牙。 /** * 连接bluetooth * * @param mac */ public void connectDevice(String mac) { try { if (mCurrStatus != STATUS.CONNECTED) { if (mac == null || TextUtils.isEmpty(mac)) throw new IllegalArgumentException(&quot;mac address is null or empty!&quot;); if (!BluetoothAdapter.checkBluetoothAddress(mac)) throw new IllegalArgumentException(&quot;mac address is not correct! make sure it's upper case!&quot;); if (mReadable = false) { mReadable = true; } if (mWritable = false) { mWritable = true; } if (onConnectListener != null) { onConnectListener.onConnectStart(); ConnectDeviceRunnable connectDeviceRunnable = new ConnectDeviceRunnable(mac); checkNotNull(mExecutorService); mExecutorService.submit(connectDeviceRunnable); } } else { Log.i(&quot;blue&quot;, &quot;the blue is connected !&quot;); } } catch (IllegalArgumentException e) { e.printStackTrace(); } } 在连接的线程run方法中，通过调用mBluetoothAdapter.getRemoteDevice 获取远程蓝牙信息，通过 createInsecureRfcommSocketToServiceRecord获得一个与远程蓝牙的socket连接。通过这个socket连接获取输入 流和输出流进行数据的读写。 if (onConnectListener == null) { Log.i(&quot;blue&quot;, &quot;the connectListener is null !&quot;); return; } BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(mac); mBluetoothAdapter.cancelDiscovery(); mCurrStatus = STATUS.FREE; Log.d(TAG, &quot;prepare to connect: &quot; + remoteDevice.getAddress() + &quot; &quot; + remoteDevice.getName()); mSocket = remoteDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(Constants.STR_UUID)); onConnectListener.onConnectting(); mSocket.connect(); mInputStream = mSocket.getInputStream(); mOutputStream = mSocket.getOutputStream(); mCurrStatus = STATUS.CONNECTED; onConnectListener.onConectSuccess(); 第六步：向蓝牙设备发送消息 当设备连接成功之后，就可以给蓝牙设备发送消息了。 通过调用bluemanage.sendMessage(MessageBean mesaage， needResponse)方法，在bluemange里会开起一个WriteRunnable写线程和一个ReadRunnable去获取输入流和输出流 的实时数据，读线程只会在第一次发消息时初始化一次。以后都是用这个线程去读从蓝牙返回的数据。写数据的线程 在每次调用的时候都会从新初始化。(待优化) 在WriteRunnable中的润写数据 writer.write(item.text); writer.newLine(); writer.flush(); 在WriteRunnable 的run方法中通过mOutputStream流将数据传送给蓝牙设备,当蓝牙接受到消息之后会和串口进行 通信，具体的通信协议是根据各个厂商自己协商的。当串口接受数据执行操作，获取数据然后在返回数据给蓝牙，蓝 牙也就有返回数据。 第七步：从蓝牙设备读取消息 在ReadRunnable中从mInputStream里不断的读取数据。这里有一个问题，就是有的时候从蓝牙 口读取的数据并不是一个完整的数据，这里是一个坑。首先你需要知道你需要什么数据，什么格式，数据的长度。这 里我们的数据的格式类似是一帧一帧，而且我们的帧长度固定大小是10。那么我们就可以在这里做一些你想做的事了。 坑 有时候从蓝牙socket 中读取的数据不完整读数据不完整，是因为我们开启线程之后会一直读，有时候蓝牙并没有返回数据，或者没有返回完整数据，这个时候 我们需要在这做一些特殊处理。 int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } 通过以上代码可以确保读的数据不会是0。通过下边的代码可以确保读到完整数据之后才会走我的回调，保证了数据 的完整性。这里的what只是我用来区分当前读到的数据是进度信息，还是真正想要的信息。 if (onReceiveMessageListener == null) { Log.i(&quot;blue&quot;, &quot;the receiverMessageListener is null !&quot;); return; } mReadable = true; InputStream stream = mInputStream; while (mCurrStatus != STATUS.CONNECTED &amp;&amp; mReadable) ; checkNotNull(stream); byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; StringBuilder builder = new StringBuilder(); while (mReadable) { int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } if (count == 10 &amp;&amp; what) { int num = stream.read(buffer); String progress = TypeConversion.bytesToHexStrings(buffer); Log.i(&quot;progress&quot;, progress); onReceiveMessageListener.onProgressUpdate(progress, 0); } else if (count &gt;= 10) { what = false; int num = stream.read(buffer); String detect = TypeConversion.bytesToHexStrings(buffer); builder.append(detect); Log.i(&quot;detect&quot;, detect); if (detect.endsWith(&quot;04 &quot;)) { number++; } if (number == 5) { onReceiveMessageListener.onDetectDataFinish(); onReceiveMessageListener.onNewLine(builder.toString().trim()); builder.delete(0, builder.length()); } else { onReceiveMessageListener.onDetectDataUpdate(detect); } } } 当读到满足条件的完整数据，就会调用ReceiveMessageListener 中的各个方法。到这里从蓝牙读取数据的流程， 大致介绍完。 下边是BlueManager提供的一些方法： requestEnableBt() 开启蓝牙 searchDevices() 搜索蓝牙设备 connectDevice() 连接蓝牙设备 closeDevice() 断开蓝牙连接 sendMessage() 发送消息 close() 关闭销毁蓝牙 结尾 BlueManager大概的使用流程及大致原理就说到这里，口才不是很好，平常也不怎么写博客，有什么问题大家可以 探讨一下。项目代码部分参考BluetoothHelper 项目，在此基础上做了一些分包优化。如有雷同，不属巧合， 我就是抄的你的。哈哈哈哈~~ 希望对那些在踩蓝牙坑的小伙伴有帮助~~~ Contact Me QQ: 798774875 Email: moruoyiming123@gmail.com GitHub: https://github.com/moruoyiming","link":"/2022/08/04/Android%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E9%80%9A%E8%AE%AF%E4%BC%A0%E8%BE%93DEMO/"},{"title":"Android项目运行时丢失so文件","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码 123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 123456789101112defaultConfig { applicationId &quot;…&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' }} 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2022/08/04/Android%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%A2%E5%A4%B1so%E6%96%87%E4%BB%B6/"},{"title":"Anroid开发艺术探究","text":"1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？ onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别 2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B 的onResume()和 A 的onPaus()哪个先执行呢？ 启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内的Activvity的状态，AMS通过 ActivityThread去同步Activity的状态从而完成生命周期方法的调用。在ActivityStack中的resumeTopActivityInnerLocked方法中，在新Acctivity启动之前， 栈顶的Activity需要先onPause()后，新Activity才能启动。最终在ActivityStackSupervisor中的realStartActivityLocked方法会调用scheduleLaunchActivity， 接着完成新Activity的onCreate、onStart、onResume的调用过程。因此，可以得到结论，是旧Activity先onPause，然后新Activity再启动。 3.Activity被销毁并重建后，我们去获取之前的存储字符串，接受的位置可以是onRestoreInstanceState 或者 onCreate 方法，两者区别是？ onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的拍断是否为空； 但是onCreate不行，onCreate如果正常启动的话，其参数Bundle savedInstanceState为null, 所以必须要额外判断。 4.onSaveInstanceState和onRestoreInstanceState，在正常流程下会出发么？ 系统只在Activity异常种植的时候才会调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，其他情况不会出发这个过程。 5.比如目前任务栈S1中的情况为ABC，这个时候Activity D 以singleTask模式请求启动，其所需要的任务栈为 S2，由于S2和D的实例均不存在，所以系统会先创建 任务栈S2，然后在创建D的实例并将其入栈到S2. 6.TaskAffinity任务相关性。 这个参数标识一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。可以为每个Activity都单独制定TaskAffinity属性， 这个属性必须不能和包名相同，否则就相当于没有制定。TaskAffinity属性主要和singleTask启动模式或者allTaskReparenting属性配对使用。当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity回运行在名字和TaskAffinity相同的任务栈中。 当TaskAffinity和allowTaskReparenting结合的时候，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allTaskReparenting属性为true的话，那么当应用B被启动后，词Activity回直接从应用A的任务栈转移到应用B的任务栈中。 7.SharedPerences是否安全？ SharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，因为SharedPreferences底层是通过读/写XML文件来实现的，并发会出问题。 每个应用的SharedPreferences文件都在当前包所在的data目录下查看到，目录位于 /data/data/pacakage name/shared_prefs目录下。 SharedPreferences也属于文件的一种，但是由于系统对他的读/写有一定的缓存策略，即在内存中有一份ShareePreferences文件的缓存，因此在多进程下，系统对它的读写诗不可靠的，当面对高并发的读/写访问，有很大几率丢失文件。 8.Serializable接口的原理及serialVersionUID作用？ 想让一个对象实现序列化，只需要这个类实现Serializable接口并声明一个serialVersionUID即可。实际上，甚至连这个serialVersionUID也不是必须的。如何进行对象的序列化和反序列化也很简单，只需要采用ObjectOutputStream和ObjectInputStream，readObject()writeObject()函数。 serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的数据中的serialVersionUID只有和当前累的serialVersionUID相同时才能够正常的被反序列化。 serialVersionUID的详细工作机制时这样的：序列化的时候系统把当前类的serialVersionUID写入序列化文件中，当反序列化时候系统回去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本时相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候时无法正常反序列化的。 9.Parcelable接口原理？ Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并通过Intent和Binder传递。 Parcel内部包装了可序列化的数据，可以在Binder中自由传输。 序列化的功能由writeToParcel方法来完成，最终时通过Parcel的一系列write方法来完成的； 反序列化功能由CREATOR来完成，其内部表明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化过程。 10.Parcelable和Serializable的区别？ Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。 Parcelable是Android中的序列化方式，操作复杂，效率很高。 Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但是 这个过程会稍显复杂，因此这两种情况建议使用Serializable。 11.AIDL流程及原理 1.创建aidl文件，声明函数及接口 2.系统根据IBookManager.aidl生成IBookManager.jar类，继承了IInterface接口，本身也是接口。在Binder中传输的接口都需要继承 IInterface接口。 3.该类声明aidl中的方法，同时声明了两个正形的id分别用于标识这两个方法，这两个id用于表示在transact过程中客户端所追求的到底是哪个方法。它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成。 核心实现就是它的内部类Stub和Stub的内部代理类Proxy。 DESCRIPTOR：Binder的唯一标识，一半用单钱Binder的类名表示。 asInterface(android.os.IBinder obj):用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的数据，这种转换过程是区分进程的，如果客户端和服务端位于统一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBindeeer：此方法用于返回当前Binder对象。 onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层疯转后交由此方法处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值，onTransact方法执行过程是这样的。 需要注意的是，如果此方法返回false，那么客户端的请求会失败。 Proxy#geetBookList：这个方法运行在客户端，当客户端远程调用此方法时，，首先创建该方法所需要的输入型Parceel对象_data、输出型Parcel对象_reply和返回值对象List，然后把该方法的参数信息写入_data中；接着调用transact方法来发起RPC请求，同时当前线程刮起；然后服务端的onTransact方法会呗调用，知道RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_replay中的数据。 Proxy#addBook:这个方法运行在客户端，它的执行过程和getBookList是一样的。 注意点:1.当客户端发起远程请求时，由于当前线程会呗挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起此次远程请求 2.由于服务端的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。 12.Binder包含两个重要的方法linkToDeath和unlinkToDeath。Binder运行在服务端进程，如果服务端进程由于某种原因异常终止，这时到服务 端的Binder链接端礼，导致远程调用失败。为了解决这个问题，Binder中提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath可以给Binder设置一个死亡代理，当Linder死亡时，会收到通知，这时可以重新发起连接请求从而恢复连接。 可通过isBinderAlive可以判断BInder是否死亡。 1.声明DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法binderDied，我们需要实现这个方法，当Binder死亡的时候，系统就会毁掉binderDied方法 13.跨进程通讯Messenger原理？ 通过Messenger在不同进程中传递Message对象。Messenger底层是AIDL。 1.服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回一个Messenger对象顶层的Binder即可 2.客户端进程中，首先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger,通过这个Messenger就可以向服务端发送消息，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一样，还需要创建一个Handler并创建一个新的Messenger，并把这个Messengeer对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。 14.AIDL中能够使用的List只有ArrayList，但是使用了CopyOnWriteArrayList(注意它不是继承自ArrayList)，为什么能够正常工作？ 因为AIDL中所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但是在Binder中会按照List的规范去访问数据并最终形成一个新的ArrayList传递给客户端。所以，在服务端采用CopyOnWriteArrayList是完全可以的。 15.RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口。RemoteCallbackList是一个范型，支持管理任意的AIDL接口，这点从它的生命可以看出，因为所有 的AIDL接口都继承自IInterface接口。原理是它的内部有一个Map结构专门用来保存所有的AIDL回调，这个Map的key是IBinder类型，value是Callback类型。 RemoteCallbackList内部自动实现了线程同步的功能，所以使用它来注册和解注册时，不需要做额外的线程同步工作。 17.Sockeet套接字，氛围流式套接字和用户数据套接字两种，分别对应于网络的传输控制层中的TCP和UDP。TCP时面向连接的协议，提供稳定的双向通讯功能，TCP连接的建立 需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，具有很高的稳定性。而UDP时无连接的，提供不稳定的单向通讯功能，当然UDP也可以实现双向通讯功能。UDP具有更好的效率，确定是不保证数据一定能够正确传输，尤其在网络拥塞的情况下。 18.TouchSlop时系统所能识别出的被认为是滑动的最小距离，当手指在屏幕滑动时，如果两次滑动指尖的距离小于这个常量，系统就不认为是在进行滑动操作。 ViewConfiguration.get(getContext()).getScaleedTouchSlop(). 19.VelocityTracker速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。 GestureDetector手势检测，用于辅助检测用护的点击、滑动、长安、双击等行为。创建GestrueDetector对象并实现OnGestureListener接口。 Scroller弹性滑动对象，用于实现View的弹性滑动。 20.View的滑动方式 1.通过View本身提供的scrollTo/scrollBy方法来实现滑动 2.通过动画给View施加平移效果实现滑动 3.改变View的LayoutParams使得View重新布局从而实现滑动 21.scrollTo和scrollBy区别 scrollBy实际上也是调用了scrollTo方法，它实现了基于当前位置的相对滑动，而scrollTo则实现了基于所传递参数的绝对滑动。 22.View滑动过程中，view内部的两个属性mScrollX和mScrollY的改变规则，这两个属性可以通过getScrollX和getScrollY方法分别得到。 在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元呢在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在水平方向的距离。 scrollTo和scrollBy只能改变View的内容的位置，而不能改变View在布局中的位置。 23.三种滑动对比 1.scrollTo/scrollBy:操作简单呢，适合对View内容的滑动。缺点只能滑动View的内容，不能滑动View本身。 2.动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果。 3.改变布局参数：操作稍微复杂，适用于有交互的View。 24.Scroller原理？ 首先构造一个Scroller对象并调用它的startScroll方法，内部其实什么也没做，只是保存了我们传递的几个参数startScroll(int startx,int starty,int dx,int dy ,in duration),滑动指View内容的滑动而非View本身位置的改变。startScroll方法下面的invalidate方法。invalidate方法会导致View重绘，在View的draw方法中又会去调用computeScroll方法，computeScroll方法在View中是一个空实现，因此需要我们去实现，上面的代码实现了computeScroll方法。 当View冲毁后会在draw方法中调用computeScroll,而computeScroll又会去想Scroller获取当前的scrollX和scrollY，然后通过scrollTo方法实现滑动，接着又调用postInvalidate方法来进行第二次重绘。这一次重绘的过程和第一次重绘一样，还是会导致computeScroll方法被调用，然后继续向Scroller获取当前的scrollX和scrollY，并通过scrollTo方法滑动到最新的位置。 概括：Scroller本身并不能实现View的滑动，它需要配合View的computeScroll方法才能完成弹性滑动的效果，他不断的让View重绘，二每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得到View当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成Vieew滑动。就这样，Vieew的每一次重绘都会导致View进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动。 25.点击事件的分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生之后，系统需要把这个事件传递给一个具体的View，这个传递的过程就是分发过程。 分发过程主要由三个方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。 1.dispatchToucherEveent(MotionEvent ev) 用来进行事件的分发，如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 2.onInterceptTouchEvent(MotionEvent ev) 在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 3.onTouchEvent(MotionEvent event) 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则同一事件序列中，当前View无法再次接收到事件。 public boolean dispatchTouchEvent(MotionEvent ev){ boolean consume = false if(onInterceptTouchEvent(ev)){ consume = onTouchEvent(ev) }else{ consume = child.dispatchTouchEvent(ev) } return consume; } 26.事件传递规则 对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法会被调用，如此反复知道事件被最终处理。 27.事件传递的优先级别 OnTouchListener &gt; onTouchEvent -&gt; OnCLickListener 当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高.在onTouchEvent方法中，如果当前设置的有OnClickListeneer，那么它的onClick方法会被调用。可以看出，OnCLickListener，其优先级最低，即处于事件传递的尾端。 28.事件传递的顺序 当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View，即事件总是先传递给Activity，Activity在传递给Window，最后Window在传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依次类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。 29.关于事件传递的机制，一些结论 1.同一个事件序列是从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。 2.正常情况下，一个序列事件只能被一个View拦截且消耗。因为一旦一个元素拦截了某个事件，那么同一事件序列内的所有事件都会直接全交给它处理，那么同一事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onToucheEvent强行传递给其他View处理。 3.某个View一旦决定拦截，那么这一个事件序列都只能由它来处理(如果事件序列能够传递给它的话)，并且它的onInterceptTouchEveent不会再被调用。当一个View决定拦截一个事件后，那么系统会把同一事件序列内的其他方法都直接交给它来处理，那么就不用再调用这个View的onInterceptTouchEevent去询问它是否要拦截了。 4.某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新由它的父元素去处理，即父元素的onTouchEvent会被调用，意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。 5.如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 6.ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false。 7.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 8.View的onTouchEvent默认都会消耗事件(返回true),除非它是不可点击的(clickable和longClickable同时为false)。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。 9.View的enable属性不影响onTouchEvent的默认值。哪怕一个View是diable状态的，只要他的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 10.onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。 11.事件传递过程是由外向内的，即时间总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以再子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 30.事件分发源码解析 1.Activity点击事件的分发过程 点击事件用MotionEvent来表示，当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件派发，具体的工作是由Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow.getDecorView()可以获得。我们先从Activity的dispatchTouchEvent开始分析。 public boolean dispatchTouchEvent(MotionEvent ev){ if(ev.getAction() == MotionEvent.ACTION_DOWN){ onUserInteraction(); } if(getView().superDispatchTouchEvent(ev)){ return true; } return onTouchEvent(ev); } 首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。 接下来看Window是如何将事件传递给ViewGroup的。Window是个抽象类，而Window的superDispatchTouchEEvent方法也是个抽象方法，因此我们必须找到Window的实现类才行。Window的实现类是PhoneWindow。window的superDispatchTouchEvent 最后调用的是mDecor.superDIspatchTouchEvent方法。通过((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0)这种方式就可以获取Activity所设置的View，这个mDecor显然就是getWindow().getDecorView（）返回的View，而我们通过setContentViewe设置的View是它的一个子View。目前事件传递到了DecorView这里，由于DecorView继承自FrameLayout且是父View，所以最终事件会传递给View。换句话说，事件肯定会传递到View,不然应用如何响应点击事件呢。从这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。 3.顶级View对点击事件的分发过程 点击事件达到顶级View以后，会调用ViewGroup的dispatchTouchEvent方法，如果顶级ViewGroup拦截事件即onInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的mOnTouchEvent被设置，则onTouch方法会被调用，否则onTouchEvent会呗调用。也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvent方法。在onTouchEvent中，如果设置了mOnClickListener，则onClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此为止，事件已经从顶级View传递到了下一层View，接下来的传递过程和顶级View是一致的，如此循环，完成整个事件的分发。 首先看ViewGroup对点击事件的分发过程，其主要实现在ViewGroup的dispatchTouchEvent方法中，它描述的是当前View是否拦截点击事件这个逻辑。 final boolean intercepted; if(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget !=null){ final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOWINTERCEPT != 0 ) if(!disallowIntercept){ intercepted = onInterceptTouchEvent(ev); ev.setAction(action) }else{ intercepted = false; } }else{ intercepted = true; } 从代码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类型为ACTION_DOWN或者mFirstTouchTarget！=null。ACTION_DOWN事件好理解，那么mFirstTouchTarget！=null是什么意思呢？当事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向子元素，当ViewGroup不拦截事件并将事件交给子元素处理时mFirstTouchTarget！=null。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget！=null就不成立。那么当ACTION_MOVE和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget！=null)这个条件为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其他事件就会默认交给它处理。 当然，这里有一种特殊情况，那就是FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceceptTouchEvent方法来设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN意外的恶其他点击事件。为什么说是除了ACTION_DOWN以外的其他事件呢？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会充值FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。因此，当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onIntercept方法来询问自己是否要拦截事件。 if(actionMasked == MotionEvent.ACTION_DOWN){ cancelAndClearTouchTargets(ev); resetTouchState(); } ViewGroup会在ACTION_DOWN事件到来时做重制状态的操作，而在resetTOuchState方法中会对FLAG_DISALLOW_INTERCEPT进行充值，因此子View调用request-DisallowInterceptTouchEvent方法并不影响ViewGroup对ACTION_DOWN事件的处理。 得出结论:当ViewGroup决定拦截事件后，后续的点击事件将会默认交给它处理并且不在调用它的onInterceptTouchEvent方法。 FLAG_DISALLOW_INTERCEPT这个标志的作用时让ViewGroup不在拦截事件，当然前提是ViewGroup不拦截ACTION_DOWN事件。 价值:第一点，onInterceptToucheEvent不是每次事件都会被调用的，如果想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用，当然前提是事件能够传递到当前的ViewGroup； 第二点，FLAG_DISALLOW_INTERCEPT标记位的作用给提供了一个思路，当面对滑动冲突时，我们可以考虑用这种方法解决问题。 接着再看当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View进行处理 final View[] children = mChildren; for(int i = childrenCount - 1; i &gt;= 0 ; i –){ final int childIndex = customOrder ? getChildDrawingOrder(chilrenCount, i) : i ; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); if(!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)){ continue; } newTouchTarget = getTouchTarget(child); if(newTouchTarget != null){ newTouchTarget.pointerIdBits != idBitsToAssign; break; } } resetCancelNextUpFlag(child); if(dispatchTransformedTouchEvent(ev,false,child,idBitsToAssign)){ mLastTouchDownTime = ev.getDownTime(); if(preorderedList != null){ for(int j=0;j&lt;childrenCOunt ; j++){ if(children[childIndex]==mChildren[j]){ mLastTouchDownIndex = j ; break; } } }else{ mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true ; break; } 上方代码逻辑：首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接受到点击事件。是否能够接受点击事件主要由两点来衡量：子元素是否在播放动画和点击事件的坐标是否落在子元素的区域内。如果某个子元素满足这两个条件，那么事件就会传递给它来处理。dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，在它的内部有如下一段内容，而在上面的恶代码中传递的不是null，因此它会直接调用子元素的dispatchTouchEvent方法，这样事件就交由子元素处理，从而完成了一轮事件分发。 if(child == null){ handled = super.dispatchTouchEvent(event); }else{ handled = child.dispatchTouchEvent(event); } 如果子元素的dipatchTouchEvent返回true，这是我们暂时不用考虑事件在子元素内部时怎么分发的，那么mFirstTouchTarget就会被赋值同时跳出for循环， newTouchTarget = addTouchTarget(child,idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; 这几行代码完成了mFirstTouchTarget的肤质并终止对子元素的遍历。如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素(如果还有下一个子元素的话)。 其实mFirstTouchTarget真正的赋值过程是在addTouchEvent内部完成的，从下面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截测恶略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件。 private TouchTarget addTouchTarget(View child,int pointerIdBits){ TouchTarget target = TouchTarget.obtain(child,pointerIdBits); target.next = mFirstTouchTargeet; } 如果遍历所有的子元素后事件都没有被合适的处理，那包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。着两种情况下，ViewGroup会自己处理点击事件。 if(mFirstTouchTarget == null){ handled = dispatchTransformedTouchEvent(ev,canceled,null,TouchTarget.ALL_POINTER_IDS) } 这里第三个参数child为null，他会调用super.dispatchTouchEvent(event),很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理。 4.View对点击事件的处理过程 View对点击事件的处理过程稍微简单，注意这里的View不包含ViewGroup。 public boolean dispatchTouchEvent(MotionEvent event){ boolean result = false; if(onFilterTouchEventForSecurity(event)){ ListeneerInfo li = mListenerInfo; if(li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTOuchListener.onTouch(this,event)){ result = true; } } if(!result &amp;&amp; onTouchEvent(event)){ result = true; } return result; } View对点击事件的处理过程比较简单，因为View是一个单独的元素，他没有子元素因此无法向下传递事件，所以它只能自己处理事件。View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可以OnTouchListener的优先级高于onTouchEevent，方便在外界处理点击事件。 在分析OnTouchEEveent的实现。先看当View处于不可用状态下点击事件的处理过程。不可用状态下的View照样会消耗点击事件，接管它看起来不可用。 if((viewFlags &amp; ENABLE_MASK) == DISABLED){ if(event.getAction() == MotionEveent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0){ setPressed(false); } return (((vieewFlags &amp; CLICKABLEE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE)== LONG_CLICKABLE)); } 如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个onTouchEvent的工作机制看起来和OnTouchListener类似。 if(mTouchDelegate != null){ if(mTouchDelegate.onTouchEvent(eevent)){ return true; } } 下面看一下onTouchEvent中对点击事件的具体处理 if(((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)){ switch(event.getAction()){ case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed){ if(!mHasPerformedLongPress){ removeLongPressCallback(); } if(!focusTaken){ if(mPerformClick == null){ mPerformClick = new PerformClick(); } if(!post(mPerformClick)){ performClick(); } } } } } 从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEEvent方法返回true，不管它是不是DISABLEE状态，然后就是当ACTION_UP事件发生时，会出发performClick方法，如果View设置了OnClickListener，那么performClick方法回调用它的onClick方法，如下所示。 public boolean performClick(){ final boolean result; final ListeenerInfo li = mListenerInfo; if(li != null &amp;&amp; li.mOnClickListeener != null){ playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; }else{ result =false; } sendAccessibilityEvent(Access) return result; } View的LONG_CLICKABLE属性默认认为false，而CLICKABLE属性是否为false和具体的View有关，确切来说是可点击的Viewe其CLICKABLE为true，不可点击的View其CLICKABLE为false，比如Button是可点击的，TextView是不可点击的。通过setClickable和setLongClickable可以分别改变View的恶CLICKABLE和LONG_CLICKABLE属性。另外，setOnClickListener会自动将View的CLICKABLE设为true，setOnLongClickListener则会自动将View的LONG_CLICKABLE设为true，如下所示： public void setOnClickListener(OnClickListener l){ if(!isClickable()){ setClickable(true); } getListenerInfo().mOnClickListener = 1; } public void setOnLongClickListenr(OnLongClickListener l){ if(!isLongClickable){ setLongClickable(true); } getListenerInfo().mOnLongClickListener = l; } 31.滑动冲突时如何产生的呢？如何解决滑动冲突呢？ 其实在解饿面中只要内外两层同时可以滑动，这个时候就会产生滑动冲突。 32.常见的滑动冲突场景场景1:外部滑动方向和内部滑动方向不一致场景2:外部滑动方向和内部滑动方向一致场景3:上面两种情况的嵌套。解决场景1:当用户左右滑动时，需要让外部的View拦截点击事件，当用户上下滑动时，需要让内部View拦截点事件。这个事件我们就可以根据它们的特征来解决滑动冲突，具体来说时：根据滑动时水平滑动还是竖直滑动来判断到底由谁来拦截事件，根据滑动过程中两个点之间的坐标就可以得出到底时水平滑动还是竖直滑动。解决场景2:无法根据滑动的角度、距离差以及速度差来做判断。可以从业务上规定：当处于某种状态时需要外部View响应用户的滑动，而处于另外一种状态时则需要内部View来响应View的滑动，根据这种业务上的需求我们也能得到响应的处理规则，有了处理规则同样可以进行下一步处理。解决场景3:无法直接根据滑动角度、距离差以及速度差来做判断。 33.如果根据坐标来得到滑动的方向？ 可以依据滑动路径和水平方向所形成的夹角，也可以依据水平方向和竖直方向上的距离差来判断，某些特殊时候还可以依据水平和竖直方向的速度差来做判断。 34.两种解决滑动冲突的方式：外部拦截法和内部拦截法。 1.外部拦截法：所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题，这种方法比较符合点击事件的分发机制。外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可。 public boolean onInterceptTouchEvent(MotionEveent event){ boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch(event.getAction()){ case MotionEvent.ACTION_DOWN:{ intercepted = false; break; } case MotionEvent.ACTION_DOWN:{ if(父容器需要当前点击事件){ intercepted = true; }else{ intercepted = false; } break; } } mLastXInterecept = x; mLastYInterecept = y; return intercepted; } 上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不要做修改并且也不能修改。这里对上述代码再描述一下，在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件,设置因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件无法再次传递给子元素。其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false;最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。 考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接受到ACTION_UP事件，这个时候子元素中的onClick事件就无法出发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。 2.内部拦截法是指父容器不拦截任何事件，所有的时间都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，使用起来较外部拦截.稍显复杂。伪代码如下，需要重写子元素的dispatchTouchEvent方法： public boolean dispatchTouchEvent(){ int x = (int) event.getX(); int y = (int) event.getY(); switch(event.getAction()){ case MotionEvent.ACTION_DOWN:{ parent.requestDisallowInterceptTouchEvent(true); break; } case MotinoEvent.ACTION_MOVE:{ int deltaX = x - mLastX; int deltaY = y - mLastY; if(父容器需要此类点击事件){ parent.requestDisallowInterceptTouchEvent(false); } break; } case MotionEvent.ACTION_UP:{ break; } } mLastX = x; mLastY = y; return super.dispatchTouchEvent(event); } 上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面的条件即可，其他不需要做改动而且也不能有改动。除了子元素需要做处理以外，父元素也要默认拦截了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。 35.为什么父容器不能拦截ACTION_DOWN事件？ 因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截法就无法起作用了。 父元素所作的修改如下： public boolean onInterceptTouchEvent(MotionEvent event){ int action = event.getAction(); if(action == MotionEvent.ACTION_DOWN){ return false; }else{ return true; } } 36.ViewRoot和DecorView的概念 ViewRoot对应于ViewRootImpl类，它是链接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，代码如下： root = new ViewRootImpl(view.getContext(),display); root.setView(view,wparams,panelParentView); 37.View的绘制流程？ View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽度和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制到屏幕上。 performTraversals ViewGroup View performMeasure -&gt; measure -&gt; onMeasure measure performLayout -&gt; layout -&gt; onLayout layout performDraw -&gt; draw -&gt; onDraw draw performTraversals会一次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中在performMeasure中会调用measure方法，在measure方法中会调用onMeasure方法，在onMeasure方法中则会对所有子元素进行measure过程，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程。接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的。 measure过程决定了View的宽高，Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight方法来获取到View测量后的宽高，在几乎所有的情况下它都等同于View最终的宽高，但是特殊情况除外。Layout过程决定了View的四个顶点的坐标和实际的View的宽高，完成以后，可以通过getTop、getBottom、getLeft和getRight来拿到View的四个顶点位置，并可以通过getWidth和getHeight方法来拿到View额最终宽高。Draw过程则决定View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。 DecorView作为顶级View，一般情况下它内部会包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分，上面是标题栏，下面是内容栏。在Activity中通过setContextView所设置的布局文件被加到内容栏中，而内容栏的id是content，因此可以链接为Activity指定布局的方法不叫setView而叫setContentView,因此布局的确加到了id为content的FrameLayout中。通过ViewGroup content = findViewById(R.android.id.content)。通过content.getChaildAt(0)可以获取到设置的View。DecorView是一个FrameLayout，View层的事件都先经过DecorView，然后才传递给我们的View。 38.理解MeasureSpec MeasureSpec参与了View的mesasure过程，很大成都上决定了一个View的尺寸规格，这个过程还受父容器的影响，因此父容器影响View的MeasureSpec的创建过程。在测量过程中，系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec，然后在根据这个measureSpec来测量出View的宽高。 MeasureSpec代表一个32位int值，高2为代表SpecMode，低30位代表SpecSize,SpecMode是值测量模式，而SpecSize是指在某种测量模式下的规格大小。 private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static fianl int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size, int mode){ if(sUseBrokenMakeMeasureSpec){ return size + mode; }else { return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); } } public static int getMode(int measureSpecc){ return (measureSpec &amp; MODE_MASK); } public static int getSize(int measureSpec){ return (measureSpec &amp; ~MODE_MASK); } MeasureSpec通过SpecMode 和 SpecSize打包成一个int值来避免过的多的对象内存分配，为了方便操作，其提供了打包和解包方法。SpecMode和SpecSize也是一个int值，一组SpecMode和SpecSize可以打包为一个MeasureSpec，而一个MeasureSpec可以通过解包的形式来得出其原始的SpecMode和SpecSize，需要注意的是这里提到的MeasureSpec是指MeasureSpec所代表的int值，而并非MeasureSpec本身。 UNSPECIFIED： 父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。 ExACTLY：父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。 AT_MOST：父容器指定了一个可用大小即SpecSize,View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。 39.MeasureSpec和LayoutParams的对应关系 系统内部是通过MeasureSpec来进行View的测量，但是正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParams。在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应额MeasureSpec，然后在根据这个MeasureSpec来确定View测量后的宽高。需注意，MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽高。对于顶级View(即DecorView)和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同决定，对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽高。 对于DecorView来说，在ViewRootImpl中的measureHierarchy方法中有如下代码，它展示了DecorView的MeasureSpec的创建过程，其中desiredWindowWidth和desiredWindowHeight是屏幕的尺寸： childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); 接着看一下getRootMeasureSpec方法的实现： private static int getRootMeasureSpec(int windowSize,int rootDimension){ int measureSpec; switch(rootDimension){ case ViewGroup.LayoutParams.MATCH_PARENT: measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); case ViewGroup.LayoutParams.WRAP_CONTENT: measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); default: measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); } return measureSpec; } 通过上述代码，DecorView的MeasureSpec的产生过程就很明确了，具体来说其遵守如下规则，根据它的LayoutParms中额宽高的参数来划分。 LayoutParams.MATCH_PARENT:精确模式，大小就是窗口的大小。 LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小。 固定大小:精确模式，大小为LayoutParams中指定的大小。 对于普通View来说，这里是指我们布局中的View，View的measure过程由ViewGroup传递而来，看下ViewGroup的measureChildWithMargins方法： public static int getChildMeasureSpec(int spec, int padding, int chaildDimension){ int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0,specSize - padding); int resultSize = 0 ; int resultMode = 0 ; switch(specMode){ case MeasureSpec.EXACTLY: if(childDimension &gt;= 0){ resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; }else if(childDimensiong == LayoutParams.MATCH_PARENT){ resultSize = size; resultMode = MeasureSpec.EXACTLY; }else if(childDimension == LayoutParams.WRAP_CONTENT){ resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; case MeasureSpec.AT_MOST: if(childDimension &gt;= 0){ resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; }else if(childDimensiong == LayoutParams.MATCH_PARENT){ resultSize = size; resultMode = MeasureSpec.AT_MOST; }else if(childDimension == LayoutParams.WRAP_CONTENT){ resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; case MeasureSpec.UNSPECIFIED: if(childDimension &gt;= 0){ resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; }else if(childDimensiong == LayoutParams.MATCH_PARENT){ resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; }else if(childDimension == LayoutParams.WRAP_CONTENT){ resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; } break; } return MeasureSpec.makeMeasureSpecc(resultSize, resultMode); } 它的作用是根据父容器的MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，此参数中的padding是指父容器中已占用的空间大小，因此子元素可用的大小为父容器的尺寸减去padding，代码如下： int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); 40.View的工作流程？ View的工作流程主要是指measure、layout、draw这三大的流程，即测量、布局和绘制，其中measure确定View的测量宽高，layout确定View的最终宽高的四个顶点的位置，而draw则将View绘制到屏幕上。 measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子元素的measure方法，各个子元素在递归去执行这个流程。 1.View的measure过程 view的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这个方法子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，onMeasure方法如下： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){ setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec, getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec))); } setMeasuredDimension方法会设置View宽高的测量值，因此需要看getDefaultSize这个方法即可： public static int getDefaultSize(int size, int measureSpec){ int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSPec.getSize(measureSpec); switch(sspecMode){ case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: rersult = specSize； break; rerturn result; } } 可以看出，getDefaultSize这个方法逻辑很简单，我们只需要看AT_MOST和.EXACTLY这种情况。简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。 View的宽高由specSize决定，所以我们可以得出如下结论，直接继承View的自定义空间需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。 41.getSuggestedMinimumWidth大的逻辑？ 如果View没有设置背景那么返回android:minWidth这个属性所指定的值，这个值可以为0，如果View设置了背景，则返回android：minWidth和背景的最小宽度这两者中的最大值，getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值就是View的UNSPECIFIED情况下的测量宽高。 42.ViewGroup的measure过程 对于ViewGroup来说，除了完成自己的measure过程外，还会遍历去调用所有子元素的measure方法，各个子元素在递归去执行这个过程。和View不同的时，ViewGroup时一个抽象类，因此它没有重写View的onMeasure方法，但是它提供了一个较measureChildren的方法 protected void measureChildren(int widthMeasureSpec,int heightMeasureSpec){ final int size = mChildrenCount; final View[] children = mChildren; for(int i = 0; i &lt; size ; ++i){ final View child = children[i]; if((child.mViewFilags &amp; VISIBILITY_MASK) != GONE){ measureChild(child,widthMeasureSpec,heightMeasureSpec); } } } 从上述代码来看，ViewGroup在measure时，会对每一个子元素进行measure，measureChild这个方法的实现也很好理解， protected void measureChild(View child,int parentWidthMeasureSpec, int parentHeightMeasureSpec){ final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidth-MeasureSpec,mPaddingLeft+mPaddingRight,lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeight - MeasureSpec,mPaddingTop + mPaddingBottom , lp.height); child.measure(childWidthMeasureSpec , childHeightMeasureSpec); } measureChild 的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量。getChildMeasureSpec的工作已经再上面进行了详细分析。 ViewGroup并没有定义其测量的具体过程，这是因为ViewGroup时一个抽象类，其测量过程的onMeasure方法需要哥哥子类去具体实现，比如LinearLayout、RelativeLayout等，为什么ViewGroup不像View一样对其onMeasure方法做同意的实现呢？那是因为不同的ViewGroup子类有不同的布局特征，这导致他们的测量细节各不相同，比如LinearLayout、RelativeLayout这两者布局特性显然不同，因此ViewGroup无法做统一实现。 43.比如我们想再Activity已启动的时候做一件任务，但是这个一件任务需要获取某个View的宽高，再onCreate或者onResume里面获取这个View的宽高可以么？ 实际上onCreate、onStart、onResume中均无法正确得到某个View的宽高信息，这是因为View的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证Activity执行了onCreate、onStart、onResume时某个View已经测量完毕了，如果View还没有测量完毕，那么获取到的宽高就是0. 1.Activity/View#onWindowFocusChanged onWindowFocusChanged这个方法的含义是：View已经初始化完毕了，宽高已经准备好了，这个时候去获取宽高是没问题的。需要注意的是，onWindowFocusChanged会被调用多次，当Activity的窗口地道道焦点和失去焦点时均会被调用一次。具体来说，当Activity继续执行和暂停执行时，onWindowFocusChanged均会被调用，如果频繁的进行onResume和onPause，那么onWindowFousChanged也会被频繁地调用。 public void onWindowFocusChanged(boolean hasFocus){ super.onWindowFocusChanged(hasFocus); if(hasFous){ int widht = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); } } 2.view.post(runnable) 通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View也已经初始化好了。 protected void onStart(){ super.onStart(); view.post(new Runnable(){ public void run(){ int widht = view.getMeasuredWidth(); int height = view.getMeasureHeight(); } }); } 3.ViewTreeObserver。 使用ViewTreeObserver的众多回调可以完成这个功能，比如使用OnGlobalLayoutListener这个几口，当View树的状态发生改变或者View树内部的View的可见性发生改变时，onGlobalLayout方法将被回调，因此这是获取View的宽高一个很好的实际。需要注意的是，伴随着View树的状态改变等。onGlobalLayout会被调用多次。 protected void onStart(){ super.onStart(); ViewTreeObserver observer = view.getViewTreeObserver(); observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(){ public void onGlobalLyout(){ view.getViewTreeObserver().removeGlobalOnLayoutListener(this); int width = view.getMeasuredWidht(); itn height = view.getMeasuredHeight(); } }); } 4.view.measeure(int widthMeasureSpec, int heightMeasureSpec). 通过手动对View进行measure来得到View的宽高。这种方法比较复杂，这里要分情况处理，根据View的LayoutParams来分： match_parent: 直接放弃，无法measure出具体的宽高。原因很简单，根据View的measure过程，构造此种MeasureSpec需要知道parentSize，即父容器的剩余空间，而这个时候我们无法知道parentSize的大小，所以理论上不可能测量出View的大小。 具体的数值： 比如宽高都是100px，如下measure： int widthMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY); int heightMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY); view.measure(widthMeasureSpec, heightMeasureSpec); wrap_content: int widthMeasureSpec = MeasureSpec.makeMeasureSpec((1&lt;&lt;30) - 1, MeasureSPec.AT_MOST); int heightMeasureSpec = MeasureSpec.makeMeasureSpec((1&lt;&lt;30) - 1, MeasureSPec.AT_MOST); 44.layout过程 Layout的作用时ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它再onLayout中会遍历所有的子元素并调用其layout方法，再layout方法中onLayout方法会被调用。Layout过程和measure过程相比就简单多了，layout方法确定View本省的位置，而onLayout方法则会确定所有子元素的位置，先看View的layout方法，如下所示： public void layout(int l, int t, int r ,int b){ if((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0){ onMeasure(mOldWidthMeasureSpec , mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBotytom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l,t,r,b); if(changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED == PFLAG_LAYOUT_REQUIRED)){ onLayout(changed, l, t, r, b); } } layout方法的大致流程如下：时首先会通过setFrame方法来设定View的四个顶点的位置，即初始化mLeft、mRight、mTop和mBottom这四个值，View的四个顶点一旦确定，那么View在父容器中的位置也就确定了，接着会调用onLayout方法，这个方法的用途时父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正实现onLayout方法。 protected void onLayout(boolean changed, int l,int t, int r, int b){ if(mOrientation == VERTICAL){ layoutVertical(l, t, r, b); }else{ layoutHorizontal(l, t, r, b); } } LinearLyout中onLayout的实现逻辑和onMeasure的实现逻辑类似，这里选择layoutVertical继续讲解 void layoutVertical(int left, int top, int right, int bottom){ final int count = getVirtualChildCount(); for(int i = 0; i &lt; count; i++){ final View child = getVirtualChildAt(i); if(child == null){ childTop += measureNullChild(i); }else if(child.getVisibility() != GONE){ final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutPaarams) child.getLayoutParams(); if(hasDividerBeforeChildAt(i)){ childTop += mDividerHeight; } childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocation - Offset(child); i += getChildrenSkipCount(child,i); } } } 这里分析一下layoutVertical的代码逻辑，可以看到，此方法会遍历所有子元素并调用setChildFrame方法来为子元素指定相应的位置，其中childTop会逐渐增大，这就意味着后面的子元素会被放置靠下的位置，这刚好符合竖直防线的LinearLayout的特性。至于setChildFrame，它仅仅时调用子元素的layout方法而已，这样父元素在layout方法中完成自己的定位以后，就通过onLayout方法去调用子元素的layout方法，子元素会通过自己的layout方法来确定自己的位置，这样一层一层地传递下去就完成了整个View树的layout过程。setChildFrame方法的实现如下所示。 private void setChildFrame(View child, int left, int top, int width, int height){ child.layout(left, top, width, height); } setChildFrame中的width和height实际上就是子元素的测量宽高，从下面的代码可以看出这一点： final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); 而在layout方法中会通过setFrame去设置子元素的四个顶点的位置，在setFrame中有如下几句赋值语句，这样以来子元素的位置就确定了： mLeft = left; mTop = top; mRight = right; mBottom = bottom; 45.View的测量宽高和最终宽高有什么区别？View的getMeasuredWidth 和 getWidth这两个方法有什么区别？ 看一下getWidth 和 getHeight 这两个方法的具体实现: public final int getWidth(){ return mRight - mLeft; } public final int getHeight(){ return mBottom - mTop; } 从getWidth和getHeight的源码在结合mLeft、mRight、mTop和mBottom这四个变量的复制过程来看，getWidth方法的返回值刚好就是View的测量宽度，而getHeight方法的返回值也刚好就是View的测量高度。经过上述分析，在View的默认实现中，View的测量高度和最终的宽高时相等的，只不过测量宽高形成于View的measure过程，而最终的宽高形成于View的layout过程，即两者复制实际不同，测量宽高的复制时机稍微早一些。可以认为View的测量宽高就等于最终宽高，但是的却存在有些特殊情况下会导致两者不一致。 如果重写View的layout方法，代码如下： public void layout(int l ,int t, int r, int b){ supre.layout(l, t, r + 100, b + 100); } 上述代码会导致任何情况下View的最终宽高总是比测量宽高大100px，虽然这样做会导致View显示不正常并且也没有实际意义，但是这证明了测量宽高的确可以不等于最终宽高。另外一种情况是在某些情况下，View需要多次measure才能确定自己的测量宽高，在前几次的从测量过程中，其得到的测量宽高有可能和最终宽高不一致，但最终来说，测量宽高还是和最终宽高相同。 46.draw过程 Draw过程就比较简单了，它的作用是将View会知道屏幕上面。View的绘制过程遵循如下几步： 1.绘制背景background.draw(canvas) 2.绘制自己onDraw 3.绘制children(dispatchDraw) 4.绘制装饰(onDrawScrollBars) 这一点通过draw方法的源码可以明显看出来 public void draw(Canvas canvas){ final int privateFlags = mPrivateFlags ; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PGLAG_DRAWN; //Step1. draw the backgroud ,if needed int saveCount; if(!dirtyOpaque){ drawBackgroud(canvas); } final int viewFlags = mViewFLags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if(!verticalEdges &amp;&amp; !horizontalEdges){ //Step 3 draw the content if(!dirtyOpaque) onDraw(canvas); //Step 4 draw decorations(scrollbars) onDrawScrollBars(canvas); if(mOverlay != null &amp;&amp; !mOverlay.isEmpty()){ mOverlay.getOverlayView().dispatchDraw(canvas); } return; } } View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会便利调用所有子元素的draw方法，如此draw时间就一层层地传递了下去。View有一个特殊地方法setWillNotDraw，如下： public void setWillNotDraw(boolean willNotDraw){ setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); } 从setWillNotDraw这个方法地注释中可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启动这个优化标记位。这个标记位对实际开发的意义是：当我们的自定义控制继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显示的关闭WILL_NOT_DRAW这个标记位。 47.自定义VIew的分类 1.继承View重写onDraw方法 这种方法主要用于实现一些不规则的效果，即这种效果不方便通过布局的组合方式来达到，往往需要静态或者动态的显示一些不规则的图形。很显然需要通过绘制的方式来实现，即重写onDraw方法。采用这种方式需要自己支持wrap_content，并且padding也需要自己处理。 2.继承ViewGroup派生特殊的Layout 这种方式主要用于实现自定义的布局，即除了LinearLayout、RelativeLayout、FrameLayout这种系统的布局之外，我们重新定义一种新布局，当某种效果看起来很像集中View组合在一起的时候，可以采用这种方法来实现。采用这种方式稍微复杂一些，需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。 3.继承特定的View 一般时用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现。这种方法不需要自己支持wrap_content和padding等。 4.继承特定的ViewGroup 这种方法也比较常见，当某种效果看起来很像集中View组合在一起的时候，可以采用这种方法来实现。采用这种方法不需要自己处理ViewGroup的测量和布局这两个过程。需要注意这种方法和方法2的区别，一般来说方法2能实现的效果方法4也都能实现，两者的主要差别在于方法2更接近View的底层。 48.自定义View过程中的一些注意事项 1.让View支持wrap_content 支持因为支持继承View或者ViewGroup的控制，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。 2.如果有必要，让你的View支持padding 这是因为支持继承View的控件，如果不在draw方法中处理padding，那么padding属性时无法起作用的。直接继承自ViewGroup的控制需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。 3.尽量不要在View中使用Handler,没必要 这是因为View内部本身就提供了post系列的方法，完全可以替代Hanlder的作用。 4.View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow 如果有线程或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。当包含此View的Activity退出或者当前View被remove 时，View的onDetachedFromWindow方法会被调用，和此方法对应的时onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄露。 5.View带有华东嵌套情形时，需要处理好滑动冲突 如果有滑动冲突的话，那么要合适的处理华东冲突，否则将会严重影响View的效果。 49.AppWidgetProvider是Android中提供的用于实现桌面小部件的类，其本质是一个广播，即BroadcastReceiver。 50.PendingIntent和Intent的区别是什么？ PendingIntent表示一种处于pending状态的意图，而pending状态表示的是一种待定、等待、即将发生的意思，就是说接下来有一个Intent将在某个待定时刻发生。PendingIntent和Intent的区别在于，PendingIntent是在将来的某个不确定的时刻发生，而Intent是立刻发生。 51.PendingIntent匹配规则？ 如果两个PendingIntent他们内部的Intent相同并且requestCode也相同，那么这两个PendingIntent就是相同的。requestCode相同比较好理解，那么什么情况下Intent相同呢？Intent的匹配规则是：如果两个Intent的ComponentName和intent-filter都相同，那么这两个Intent就是相同的。需要注意的是Extras不参与Intent的匹配过程，只要Intent之间的ComponentName和intent-filter相同，即使他们的Extras不同，那么这两个Intent样式相同的。 52.PendingIntent中flags参数的含义？ 1.FLAG_ONE_SHOT：当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel，如果后续还有相同的PendingIntent，那么他们的send方法就会调用失败。对于通知栏消息来说，如果采用此标记位，那么同类的通知只能使用一次，后续的通知点击后将无法打开。 2.FLAG_NO_CREATE：当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity、getService和getBroadcast方法会直接返回null，即获取PendingIntent失败。这个标记位很少见，它无法单独使用。 3.FLAG_CANCEL_CURRENT：当前描述的PendingIntent如果已经存在，那么他们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些被cancel的消息单机后 将无法打开。 4.FLAG_UPDATE_CURRENT：当前描述的PendingIntent如果已经存在，那么他们都会被更新，即他们的Intent中的Extras会被替换成最新的。 53.通知栏和桌面小部件分别由NotificationManager和AppWidgetManager管理，而NotificationManager和AppWidgetManager通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetService进行通讯。因此可见，通知栏和桌面小部件中的布局文件实际上是在NotificationManagerService以及AppWidgetService中被加载的，而他们运行在系统的SystemServer中，这就和我们的进程构成了跨进成通讯的场景。 54.RemoteViews的apply以及reapply方法来家在活着更新界面的，apply和reApply的却别在与：apply会家在布局并更新界面，而reApply则只会更新界面。通知栏和桌面小插件在初始化界面时会调用apply方法，而在后续的更新界面时则会调用reapply方法。 WindowManager所提供的功能很简单，常用的只有三个方法，即添加View、更行View和删除View，这三个方法定义在ViewManager中，而WindowManager继承了ViewManagerpublic interfacce ViewManager{ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view,ViewGroup.LayoutParams params); public void removeView(View view);} Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此此Window并不是实际存在的，它是以View的形式存在。 Window的添加过程 Window的添加过程需要通过WindowManager的addView来实现，WindowManager是一个接口，它的真正实现是WindowManagerImpl类。在WindowManagerImpl中Window的三大操作的实现如下： public void addView(View view, ViewGroup.LayoutParams params){ mGlobal.addView(view, params, mDisplay, mParentWindow); } public void updateViewLayout(View view, ViewGroup.LayoutParams params){ mGlobal.updateViewLayout(view, params); } public void remoteView(View view){ mGlobal.removeView(view, false); } WindowManagerImpl并没有直接实现Window的三大操作，二十交割WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实力，在WindowManagerGlobal中有以下代码：private final WindowManagerGLobal mGlobal = WindowManagerGlobal。getInstance()。WindowManagerImpl这种工作模式是典型的桥接模式，将所有的操作全部委托给WindowMangerGlobal来实现。WindowManagerGlobal的addView方法主要分为如下几步。 1.检查参数是否合法，如果是子Window那么还需要调整一些布局参数 if(view == null){ throw new IllegalArgumentException(“view must not be null”); } if(display == null){ throw new IllegalArgumentException(“display must not be null”); } if(!(params instanceof WindowManager.LayoutParams)){ throw new IllegalArgumentException(“Params must be WindowManager.LayoutParams”); } final WindowManager.LayoutParams wparams = (WindowManger.LayoutParams)params; if(parentWindow != null){ parentWindow.adjustLayoutParamsForSubWindow(wparams); } 2.创建ViewRootImpl并将View添加到列表中 在WindowMangerGlobal内部有如下几个列表比较重要： private final ArrayList mViews = new ArrayList(); private final ArrayList mRoots = new ArrayList(); private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); private final ArraySet mDyingViews = new ArraySet(); 在上面生命中，mViews存储的是所有Window所对应的View，mRoots存储的是所有Window所对应的ViewRootImpol，mParams存储的是素有Window所对应的布局参数，而mDyingViews则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象。在addView中通过如下方式将Window的乙烯利列对象添加到列表中： root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); 3.通过ViewRootImpl来更新界面并完成Window的添加过程 这个步骤由ViewRootImpl的setView方法来完成，View的绘制过程是由ViewRootImpl来完成的。在setView内部会通过requestLayout来完成异步刷新请求。scheduleTraversals实际是View绘制的入口： public void requestLayout(){ if(!mHandlingLayoutInLayoutRequest){ checkThread(); mLayoutRequested = true; scheduleTraversals(); } }","link":"/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/"},{"title":"Dialog加载绘制流程","text":"前面两篇文章，我们分析了Activity的布局文件加载、绘制流程，算是对整个Android系统中界面的显示流程有了一个大概的了解，其实Android系统中所有的显示控件（注意这里是控件，而不是组件）的加载绘制流程都是类似的，包括：Dialog的加载绘制流程，PopupWindow的加载绘制流程，Toast的显示原理等，上一篇文章中，我说在介绍了Activity界面的加载绘制流程之后，就会分析一下剩余几个控件的显示控制流程，这里我打算先分析一下Dialog的加载绘制流程。 可能有的同学问这里为什么没有Fragment？其实严格意义上来说Fragment并不是一个显示控件，而只是一个显示组件。为什么这么说呢？其实像我们的Activity，Dialog，PopupWindow以及Toast类的内部都管理维护着一个Window对象，这个Window对象不但是一个View组件的集合管理对象，它也实现了组件的加载与绘制流程，而我们的Fragment组件如果看过源码的话，严格意义上来说，只是一个View组件的集合并通过控制变量实现了其特定的生命周期，但是其由于并没有维护Window类型的成员变量，所以其不具备组件的加载与绘制功能，因此其不能单独的被绘制出来，这也是我把它称之为组件而不是控件的原因。（在分析完这几个控件的加载绘制流程之后，有时间的话，也会分析一下Fragment的相关源码） 好吧，开始我们今天关于Dialog的讲解，相信大家在平时的开发过程中经常会使用到Dialog弹窗，使用Dialog可以在Activity弹出弹窗，确认消息等。为了更好的分析Dialog的源码，我们这里暂时写一个简单的demo，看一下Dialog的使用实例。 12345678910111213141516171819title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 我们在Activity中获取一个textView组件，并监听TextView的点击事件，并在点击事件中，初始化一个AlertDialog弹窗，并执行AlertDialog的show方法展示弹窗，在弹窗中定义一个按钮，并监听弹窗按钮的点击事件，若用户点击了弹窗的按钮，则执行AlertDialog的dismiss方法，取消展示AlertDialog。好吧，我们来看一下这个弹窗弹出的展示结果：可以看到我们定义的icon，title，message和button都已经显示出来了，这时候我们点击弹窗按钮知道了，这时候弹窗就会消失了。 一般我们使用Dialog的大概流程都是这样的，可能定制Dialog的时候有一些定制化的操作，但是基本操作流程还是这样的。 那么我们先来看一下AlertDialog.Builder的构造方法，这里的Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法： 123public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); } 好吧，这里调用的是Builder的重载构造方法： 1234public Builder(Context context, int themeResId) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); } 那么这里的P是AlertDialog.Builder中的一个AlertController.AlertParams类型的成员变量，可见在这里执行了P的初始化操作。 12345public AlertParams(Context context) { mContext = context; mCancelable = true; mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); } 可以看到这里主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量。这样执行了一系列操作之后我们的代码： 1AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); 就已经执行完成了，然后我们调用了builder.setIcon方法，这里看一下setIcon方法的具体实现： 1234public Builder setIcon(@DrawableRes int iconId) { P.mIconId = iconId; return this; } 可以看到AlertDialog的Builder的setIcon方法，这里执行的就是给类型为AlertController.AlertParams的P的mIconId赋值为传递的iconId，并且这个方法返回的类型就是Builder。 然后我们调用了builder.setMessage方法，可以看一下builder.setMessage方法的具体实现： 1234public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } 好吧，这里跟setIcon方法的实现逻辑类似，都是给成员变量的mMessage赋值为我们传递的Message值，且和setIcon方法类似的，这个方法返回值也是Builder。 再看一下builder.setTitle方法： 1234public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } 可以发现builder的setIcon、setMessage、setTitle等方法都是给Builder的成员变量P的icon，message，title赋值。 然后我们看一下builder.setView方法： 123456public Builder setView(int layoutResId) { P.mView = null; P.mViewLayoutResId = layoutResId; P.mViewSpacingSpecified = false; return this; } 可以发现这里的setView和setIcon，setMessage，setTitle等方法都是类似的，都是将我们传递的数据值赋值给Builder的成员变量P。 然后我们调用了builder.setPositiveButton方法： 123456builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); 好吧，这里我们看一下builder的setPositiveButton的源码： 12345public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } 好吧，可以发现跟上面几个方法还是类似的，都是为Builder的成员变量P的相应成员变量赋值。。。 上面的几行代码我们都是调用的builder.setXXX等方法，主要就是为Builder的成员变量P的相应成员变量值赋值。并且setXX方法返回值都是Builder类型的，因此我们可以通过消息琏的方式连续执行： 1builder.setIcon().setMessage().setTitle().setView().setPositiveButton()... 这样代码显得比较简洁，set方法的执行顺序是没有固定模式的，这里多说一下，这种编程方式很优秀，平时我们在设计构造类工具类的时候也可以参考这种模式，构造类有不同的功能或者特性，并且都不是必须的，我们可以通过set方法设置不同的特性值并返回构造类本身。 然后我们调用了builder.create方法，并且这个方法返回了AlertDialog。 123456789101112131415public AlertDialog create() { // Context has already been wrapped with the appropriate theme. final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } 可以看到这里首先构造了一个AlertDialog，我们可以看一下这个构造方法的具体实现： 1234567AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); } 可以看到这里首先调用了super的构造方法，而我们的AlertDialog继承于Dialog，所以这里执行的就是Dialog的构造方法，好吧，继续看一下Dialog的构造方法： 1234567891011121314151617181920212223Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { if (createContextThemeWrapper) { if (themeResId == 0) { final TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true); themeResId = outValue.resourceId; } mContext = new ContextThemeWrapper(context, themeResId); } else { mContext = context; } mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); } 可以发现在Dialog的构造方法中直接直接构造了一个PhoneWindow，并赋值给Dialog的成员变量mWindow，从这里可以看出其实Dialog和Activity的显示逻辑都是类似的，都是通过对应的Window变量来实现窗口的加载与显示的。然后我们执行了一些Window对象的初始化操作，比如设置回调函数为本身，然后调用了Window类的setWindowManager方法，并传入了WindowManager，可以发现这里的WindowManager对象是通过方法： 1mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); 获取的，而我们的context传入的是Activity对象，所以这里的WindowManager对象其实和Activity获取的WindowManager对象是一致的。然后我们看一下window类的setWindowManager方法： 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 可以看到跟Activity的Window对象的windowManager的获取方式是相同的，都是通过new的方式创建一个新的WindowManagerImpl对象。好吧，继续回到我们的AlertDialog的构造方法中，在构造方法中，我们除了调用Dialog的构造方法之外还执行了： 1mAlert = new AlertController(getContext(), this, getWindow()); 相当于初始化了AlertDiaog的成员变量mAlert。 继续回到我们的AlertDialog.Builder.create方法，在创建了一个AlertDialog之后，又执行了P.apply(dialog.mAlert)；我们知道这里的P是一个AlertController.AlertParams的变量，而dialog.mAlert是我们刚刚创建的AlertDialog中的一个AlertController类型的变量，我们来看一下apply方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ublic void apply(AlertController dialog) { if (mCustomTitleView != null) { dialog.setCustomTitle(mCustomTitleView); } else { if (mTitle != null) { dialog.setTitle(mTitle); } if (mIcon != null) { dialog.setIcon(mIcon); } if (mIconId != 0) { dialog.setIcon(mIconId); } if (mIconAttrId != 0) { dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); } } if (mMessage != null) { dialog.setMessage(mMessage); } if (mPositiveButtonText != null) { dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); } if (mNegativeButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); } if (mNeutralButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); } if (mForceInverseBackground) { dialog.setInverseBackgroundForced(true); } // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) { createListView(dialog); } if (mView != null) { if (mViewSpacingSpecified) { dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); } else { dialog.setView(mView); } } else if (mViewLayoutResId != 0) { dialog.setView(mViewLayoutResId); } } 看到了么？就是我们在初始化AlertDialog.Builder的时候设置的icon、title、message赋值给了AlertController.AlertParams，这里就是将我们初始化时候设置的属性值赋值给我们创建的Dialog对象的mAlert成员变量。。。。 继续我们的AlertDialog.Builder.create方法，在执行了AlertController.AlertParams.apply方法之后又调用了： 1dialog.setCancelable(P.mCancelable); 可以发现这个也是AertController.AlertParams的一个成员变量，我们在初始化AlertDialog.Builder的时候也可以通过设置builder.setCancelable赋值，由于该属性为成员变量，所以默认值为false，而我们并没有通过builder.setCancelable修改这个属性值，所以这里设置的dialog的cancelable的值为false。然后我们的create方法有设置了dialog的cancelListener和dismissListener并返回了我们创建的Dialog对象。这样我们就获取到了我们的Dialog对象，然后我们调用了dialog的show方法用于显示dialog，好吧，这里我们看一下show方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void show() { if (mShowing) { if (mDecor != null) { if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); } mDecor.setVisibility(View.VISIBLE); } return; } mCanceled = false; if (!mCreated) { dispatchOnCreate(null); } onStart(); mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); } WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; } try { mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); } finally { } } 方法体的内容比较多，我们慢慢看，由于一开始mShowing变量用于表示当前dialog是否正在显示，由于我们刚刚开始调用执行show方法，所以这里的mShowing变量的值为false，所以if分支的内容不会被执行，继续往下看： 123if (!mCreated) { dispatchOnCreate(null); } mCreated这个控制变量控制dispatchOnCreate方法只被执行一次，由于我们是第一次执行，所以这里会执行dispatchOnCreate方法，好吧，我们看一下dispatchOnCreate方法的执行逻辑： 123456void dispatchOnCreate(Bundle savedInstanceState) { if (!mCreated) { onCreate(savedInstanceState); mCreated = true; } } 好吧，可以看到代码的执行逻辑很简单就是回调了Dialog的onCreate方法，那么onCreate方法内部又执行了那些逻辑呢？由于我们创建的是AlertDialog对象，该对象继承于Dialog，所以我们这时候需要看一下AlertDialog的onCreate方法的执行逻辑： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent(); } 可以看到这里面除了调用super.onCreate方法之外就是调用了mAlert.installContent方法，而这里的super.onCreate方法就是调用的Dialog的onCreate方法，Dialog的onCreate方法只是一个空的实现逻辑，所以我们具体来看一下mAlert.installContent的实现逻辑。 12345678public void installContent() { /* We use a custom title so never request a window title */ mWindow.requestFeature(Window.FEATURE_NO_TITLE); int contentView = selectContentView(); mWindow.setContentView(contentView); setupView(); setupDecor(); } 可以看到这里实现Window窗口的页面设置布局初始化等操作，这里设置了mWindow对象为NO_TITLE，然后通过调用selectContentView设置Window对象的布局文件。 12345678910private int selectContentView() { if (mButtonPanelSideLayout == 0) { return mAlertDialogLayout; } if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) { return mButtonPanelSideLayout; } // TODO: use layout hint side for long messages/lists return mAlertDialogLayout; } 可以看到这里通过执行selectContentView方法返回布局文件的id值，这里的默认值是mAlertDialogLayout。看过Activity布局加载流程（android源码解析（十七）–&gt;Activity布局加载流程）的童鞋应该知道，从这个方法开始我们就把指定布局文件的内容加载到内存中的Window对象中。我们这里看一下具体的布局文件。 12mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); 也就是R.layout.alert_dialog的布局文件，有兴趣的同学可以看一下该布局文件的源码，O(∩_∩)O哈哈~ 继续回到我们的installContent方法，在执行了mWindow.setContentView方法之后，又调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量，这里就不在详细的说明。 然后回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法，这个方法主要用于设置ActionBar，这里不做过多的说明，然后初始化WindowManager.LayoutParams对象，并最终调用我们的mWindowManager.addView()方法。 O(∩_∩)O哈哈~，到了这一步大家如果看了上一篇Acitivty布局绘制流程的话，就应该知道顺着这个方法整个Dialog的界面就会被绘制出来了。 最后我们调用了sendShowMessage方法，可以看一下这个方法的实现： 123456private void sendShowMessage() { if (mShowMessage != null) { // Obtain a new message so this dialog can be re-used Message.obtain(mShowMessage).sendToTarget(); } } 这里会发送一个Dialog已经显示的异步消息，该消息最终会在ListenersHandler中的handleMessage方法中被执行： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 由于我们的msg.what = SHOW,所以会执行OnShowListener.onShow方法，那么这个OnShowListener是何时赋值的呢？还记得我们构造AlertDialog.Builder么？ 123456alertDialog.setOnShowListener(new DialogInterface.OnShowListener() { @Override public void onShow(DialogInterface dialog) { } }); 这样就为我们的AlertDialog.Builder设置了OnShowListener，可以看一下setOnShowListener方法的具体实现： 1234567public void setOnShowListener(OnShowListener listener) { if (listener != null) { mShowMessage = mListenersHandler.obtainMessage(SHOW, listener); } else { mShowMessage = null; } } 这样就为我们的Dialog中的mListenersHandler构造了Message对象，并且当我们在Dialog中发送showMessage的时候被mListenersHandler所接收。。。。 注：这里说一下我们平时开发中若创建的Dialog使用的Context对象不是Activity，就会报出： 12345678910111213141516Process: com.example.aaron.helloworld, PID: 11948 android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an applicationat android.view.ViewRootImpl.setView(ViewRootImpl.java:690)at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:282)at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)at android.app.Dialog.show(Dialog.java:298)at com.example.aaron.helloworld.MainActivity$1.onClick(MainActivity.java:59)at android.view.View.performClick(View.java:4811)at android.view.View$PerformClick.run(View.java:20136)at android.os.Handler.handleCallback(Handler.java:815)at android.os.Handler.dispatchMessage(Handler.java:104)at android.os.Looper.loop(Looper.java:194)at android.app.ActivityThread.main(ActivityThread.java:5552)at java.lang.reflect.Method.invoke(Native Method)at java.lang.reflect.Method.invoke(Method.java:372)at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 的异常，这是由于WindowManager.addView方法最终会调用ViewRootImpl.setView方法，而这时候会有mToken的检查，若我们传入的Context对象不是Activity，这时候的mToken为空，就会出现上述问题。。。 总结： Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑； Dialog中的Window对象与Activity中的Window对象是相似的，都对应着一个WindowManager对象； Dialog相关的几个类：Dialog，AlertDialog，AlertDialog.Builder，AlertController，AlertController.AlertParams，其中Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑，而AlertDialog是具体的Dialog的操作实现类，AlertDialog.Builder类是AlertDialog的内部类，主要用于构造AlertDialog，AlertController是AlertDialog的控制类，AlertController.AlertParams类是控制参数类； 构造显示Dialog的一般流程，构造AlertDialog.Builder，然后设置各种属性，最后调用AlertDialog.Builder.create方法获取AlertDialog对象，并且create方法中会执行，构造AlertDialog，设置dialog各种属性的操作。最后我们调用Dialog.show方法展示窗口，初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，并最终将Dialog显示出来； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程","link":"/2022/08/06/Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"CoordinatorLayout 与viewpage 使用 viewpager 内如何空出子布局高度","text":"在子布局中使用 添加NestedScrollView并添加 android:fillViewport=”true” android:fitsSystemWindows=”true” &lt;android.support.v4.widget.NestedScrollView android:id=”@+id/nest_scrollview” android:layout_width=”match_parent” android:layout_height=”match_parent” android:layout_gravity=”fill_vertical” android:fillViewport=”true” android:fitsSystemWindows=”true” app:layout_behavior=”@string/appbar_scrolling_view_behavior”&gt; &lt;your layout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;","link":"/2022/08/06/CoordinatorLayout%20%E4%B8%8Eviewpage%20%E4%BD%BF%E7%94%A8%20viewpager%20%E5%86%85%E5%A6%82%E4%BD%95%E7%A9%BA%E5%87%BA%20%E9%AB%98%E5%BA%A6/"},{"title":"Dialog取消绘制流程","text":"上几篇文章中我们分析了Dialog的加载绘制流程，也分析了Acvityi的加载绘制流程，说白了Android系统中窗口的展示都是通过Window对象控制，通过ViewRootImpl对象执行绘制操作来完成的，那么窗口的取消绘制流程是怎么样的呢？这篇文章就以Dialog为例说明Window窗口是如何取消绘制的。 有的同学可能会问前几篇文章介绍Activity的加载绘制流程的时候为何没有讲Activity的窗口取消流程，这里说明一下。那是因为当时说明的重点是Activity的加载与绘制流程，而取消绘制流程由于混杂在Activity的生命周期管理，可能不太明显，所以这里将Window窗口的取消绘制流程放在Dialog中，其实他们的取消绘制流程都是相似的，看完Dialog的取消绘制流程之后，再看一下Activity的取消绘制流程就很简单了。 还记得我们上一篇文章关于Dialog的例子么？我们通过AlertDialog.Builder创建了一个AlertDialog，并通过Activity中的按钮点击事件来显示这个AlertDialog，而在AlertDialog中定义了一个“知道了”按钮，点击这个按钮就会触发alertDialog.cancel方法，通过执行这个方法，我们的alertDialog就不在显示了，很明显的，cancel方法执行过程中就执行了取消绘制的逻辑，这里我们先看一下我们的例子核心代码： 123456789101112131415161718title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this.getApplication()); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.cannel(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 这里的title就是我们自己的Activity中的一个TextView，通过注册这个TextView的点击事件，来显示一个AlertDialog，通过注册AlertDialog中按钮的点击事件，执行alertDialog的cancel方法。 好吧，看一下Dialog的cannel方法的具体实现： 12345678public void cancel() { if (!mCanceled &amp;&amp; mCancelMessage != null) { mCanceled = true; // Obtain a new message so this dialog can be re-used Message.obtain(mCancelMessage).sendToTarget(); } dismiss(); } 可以看到方法体中，若当前Dialog没有取消，并且设置了取消message，则调用Message.obtain(mCancel).sendToTarget()，前面已经分析过这里的sendToTarget方法会回调我们注册的异步消息处理逻辑： 123456789101112public void setOnCancelListener(final OnCancelListener listener) { if (mCancelAndDismissTaken != null) { throw new IllegalStateException( &quot;OnCancelListener is already taken by &quot; + mCancelAndDismissTaken + &quot; and can not be replaced.&quot;); } if (listener != null) { mCancelMessage = mListenersHandler.obtainMessage(CANCEL, listener); } else { mCancelMessage = null; } } 可以看到如果我们在初始化AlertDialog.Builder时，设置了setOnCancelListener，那么我们就会执行mListenersHandler的异步消息处理，好吧，这里看一下mListenersHandler的定义： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 好吧，这里调用的是设置的OnCancelListener的onCancel方法，也就是说我们调用dialog.cancel方法时首先会判断dialog是否调用了setOnCancelListener若设置了，则先调用OnCancelListener的onCancel方法，然后再次执行dismiss方法，若我们没有为Dialog.Builder设置OnCancelListener那么cancel方法和dismiss方法是等效的。 这样，我们来看一下dismiss方法的实现逻辑： 1234567public void dismiss() { if (Looper.myLooper() == mHandler.getLooper()) { dismissDialog(); } else { mHandler.post(mDismissAction); } } 可以看到，这里首先判断当前线程的Looper是否是主线程的Looper（由于mHandler是在主线程中创建的，所以mHandler.getLooper返回的是主线程中创建的Looper对象），若是的话，则直接执行dismissDialog()方法，否则的话，通过mHandler发送异步消息至主线程中，简单来说就是判断当前线程是否是主线程，若是主线程则执行dismissDialog方法否则发送异步消息，我们看一下mHandler对异步消息的处理机制，由于这里的mDismissAction是一个Runnable对象，所以这里直接看一下mDismissAction的定义： 12345private final Runnable mDismissAction = new Runnable() { public void run() { dismissDialog(); } }; 好吧，这里的异步消息最终也是调用的dismissDialog方法。。。。 所以无论我们执行的cancel方法还是dismiss方法，无论我们方法是在主线程执行还是子线程中执行，最终调用的都是dismissDialog方法，那么就看一下dismissDialog是怎么个执行逻辑。 123456789101112131415161718192021222324void dismissDialog() { if (mDecor == null || !mShowing) { return; } if (mWindow.isDestroyed()) { Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog's window was already destroyed!&quot;); return; } try { mWindowManager.removeViewImmediate(mDecor); } finally { if (mActionMode != null) { mActionMode.finish(); } mDecor = null; mWindow.closeAllPanels(); onStop(); mShowing = false; sendDismissMessage(); } } 好吧，看样子代码还不是特别多，方法体中，首先判断当前的mDector是否为空，或者当前Dialog是否在显示，若为空或者没有在显示，则直接return掉，也就是说当前我们的dialog已经不再显示了，则我们不需要往下在执行。 然后我们调用了mWindow.isDestroyed()方法，判断Window对象是否已经被销毁，若已经被销毁，则直接return，并打印错误日志。 然后我们调用了mWindowManager.removeViewImmediate(mDector)，这里的mDector是我们Dialog窗口的根布局，看这个方法的名字应该就是Dialog去除根布局的操作了，可以看一下这个方法的具体实现。前几篇文章中我们已经分析过了这里的mWindowManager其实是WindowManagerImpl的实例，所以这里的removeViewImmediate方法应该是WindowManagerImpl中的方法，我们看一下它的具体实现： 1234@Override public void removeViewImmediate(View view) { mGlobal.removeView(view, true); } 可以发现，这里它调用了mGlobal.removeView方法，而这里的mGlobal是WindowManagerGlobal的实例，所以我们再看一下WIndowManagerGlobal中removeView的实现逻辑: 1234567891011121314151617public void removeView(View view, boolean immediate) { if (view == null) { throw new IllegalArgumentException(&quot;view must not be null&quot;); } synchronized (mLock) { int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) { return; } throw new IllegalStateException(&quot;Calling with view &quot; + view + &quot; but the ViewAncestor is attached to &quot; + curView); } } 可以发现，这里在获取了保存的mDector组件之后，又调用了removeViewLocked方法，我们在看一下这个方法的具体实现逻辑： 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) { ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) { InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) { imm.windowDismissed(mViews.get(index).getWindowToken()); } } boolean deferred = root.die(immediate); if (view != null) { view.assignParent(null); if (deferred) { mDyingViews.add(view); } } } 看到了么，我们获取了mDector组件的ViewRootImpl，然后调用了其的die方法，通过这个方法实现Window组件的销毁流程。 1234567891011121314151617boolean die(boolean immediate) { // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) { doDie(); return false; } if (!mIsDrawing) { destroyHardwareRenderer(); } else { Log.e(TAG, &quot;Attempting to destroy the window while drawing!\\n&quot; + &quot; window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle()); } mHandler.sendEmptyMessage(MSG_DIE); return true; } 可以看到在方法体中有调用了doDie方法，看名字应该就是真正执行window销毁工作的方法了，我们在看一下doDie方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839void doDie() { checkThread(); if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface); synchronized (this) { if (mRemoved) { return; } mRemoved = true; if (mAdded) { dispatchDetachedFromWindow(); } if (mAdded &amp;&amp; !mFirst) { destroyHardwareRenderer(); if (mView != null) { int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) { // If layout params have been changed, first give them // to the window manager to make sure it has the correct // animation info. try { if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) { mWindowSession.finishDrawing(mWindow); } } catch (RemoteException e) { } } mSurface.release(); } } mAdded = false; } WindowManagerGlobal.getInstance().doRemoveView(this); } 可以看到方法体中，首先调用了checkThread方法，介绍Activity的绘制流程的时候有过介绍，判断当前执行代码的线程，若不是主线程，则抛出异常： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 我们顺着doDie的方法往下看，又调用了dispatchDetachedFromWindow()方法，这个方法主要是销毁Window中的各中成员变量，临时变量等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void dispatchDetachedFromWindow() { if (mView != null &amp;&amp; mView.mAttachInfo != null) { mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false); mView.dispatchDetachedFromWindow(); } mAccessibilityInteractionConnectionManager.ensureNoConnection(); mAccessibilityManager.removeAccessibilityStateChangeListener( mAccessibilityInteractionConnectionManager); mAccessibilityManager.removeHighTextContrastStateChangeListener( mHighContrastTextManager); removeSendWindowContentChangedCallback(); destroyHardwareRenderer(); setAccessibilityFocus(null, null); mView.assignParent(null); mView = null; mAttachInfo.mRootView = null; mSurface.release(); if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) { mInputQueueCallback.onInputQueueDestroyed(mInputQueue); mInputQueue.dispose(); mInputQueueCallback = null; mInputQueue = null; } if (mInputEventReceiver != null) { mInputEventReceiver.dispose(); mInputEventReceiver = null; } try { mWindowSession.remove(mWindow); } catch (RemoteException e) { } // Dispose the input channel after removing the window so the Window Manager // doesn't interpret the input channel being closed as an abnormal termination. if (mInputChannel != null) { mInputChannel.dispose(); mInputChannel = null; } mDisplayManager.unregisterDisplayListener(mDisplayListener); unscheduleTraversals(); } 可以看到我们在方法中调用了mView.dispatchDetachedFromWindow方法，这个方法的作用就是将mView从Window中detach出来，我们可以看一下这个方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940void dispatchDetachedFromWindow() { AttachInfo info = mAttachInfo; if (info != null) { int vis = info.mWindowVisibility; if (vis != GONE) { onWindowVisibilityChanged(GONE); } } onDetachedFromWindow(); onDetachedFromWindowInternal(); InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null) { imm.onViewDetachedFromWindow(this); } ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) { // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to // perform the dispatching. The iterator is a safe guard against listeners that // could mutate the list by calling the various add/remove methods. This prevents // the array from being modified while we iterate it. for (OnAttachStateChangeListener listener : listeners) { listener.onViewDetachedFromWindow(this); } } if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) { mAttachInfo.mScrollContainers.remove(this); mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED; } mAttachInfo = null; if (mOverlay != null) { mOverlay.getOverlayView().dispatchDetachedFromWindow(); } } 其中onDetachedFromWindow方法是一个空的回调方法，这里我们重点看一下onDetachedFromWindowInternal方法： 12345678910111213141516171819protected void onDetachedFromWindowInternal() { mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT; mPrivateFlags3 &amp;= ~PFLAG3_IS_LAID_OUT; removeUnsetPressCallback(); removeLongPressCallback(); removePerformClickCallback(); removeSendViewScrolledAccessibilityEventCallback(); stopNestedScroll(); // Anything that started animating right before detach should already // be in its final state when re-attached. jumpDrawablesToCurrentState(); destroyDrawingCache(); cleanupDraw(); mCurrentAnimation = null; } onDetachedFromWindowInternal方法的方法体也不是特别长，都是一些调用函数，这里看一下destropDrawingCache方法，这个方法主要是销毁View的缓存Drawing，我们来看一下具体实现： 12345678910public void destroyDrawingCache() { if (mDrawingCache != null) { mDrawingCache.recycle(); mDrawingCache = null; } if (mUnscaledDrawingCache != null) { mUnscaledDrawingCache.recycle(); mUnscaledDrawingCache = null; } } 这里的mDrawingCache其实就是一个Bitmap类型的成员变量，而这里调用的recycler和置空操作其实就是把View中执行draw方法之后缓存的bitmap清空。 这里需要说明的是，我们View组件的最终显示落实是通过draw方法实现绘制的，而我们的draw方法的参数是一个Canvas，这是一个画布的对象，通过draw方法就是操作这个对象并显示出来，而Canvas对象之所以能够实现显示的效果是因为其内部保存着一个Bitmap对象，通过操作Canvas对象实质上是操作Canvas对象内部的Bitmap对象，而View组件的显示也就是通过这里的Bitmap来实现的。 而我们上文中置空了bitmap对象就相当于把View组件的显示效果置空了，就是相当于我们取消了View的draw方法的执行效果，继续回到我们的dispatchDetachedFromWindow方法，在执行了mView.dispatchDetachedFromWindow()方法之后，又调用了mView = null;方法，这里设置mView为空，这样我们有取消了View的meature和layouot的执行效果。 这样经过一系列的操作之后我们的Dialog的取消绘制流程就结束了，现在我们来看一下Activity的取消绘制流程。还记得我们“Activity的销毁流程”么？可参考：android源码解析之（十五）–&gt;Activity销毁流程当我们调用activity的finish方法的时候回调用ActivityThread的handleDestroyActivity方法，我们来看一下这个方法的实现： 123456private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... wm.removeViewImmediate(v); ... } 可以看到这里调用了这里调用了wm.removeViewImmediate方法，这个方法不就是我们刚刚分析Dialog销毁绘制流程的起始方法么？以后的逻辑都是详细的，这样我们就实现了Activity的取消绘制流程。 总结： 窗口的取消绘制流程是相似的，包括Activity和Dialog等； 通过调用WindowManager.removeViewImmediate方法，开始执行Window窗口的取消绘制流程； Window窗口的取消绘制流程，通过清空bitma撤销draw的执行效果，通过置空View撤销meature和layout的执行效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程","link":"/2022/08/06/Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"git常用命令","text":"一、常用命令 切换到master分支：git checkout master 查看已有本地及远程分支：git branch -a（先git pull拉下全部数据） 查看远程分支：git branch -r 查看所有分支：git branch -a 查看本地分支：git branch 删除远程dev分支：git push origin –delete dev 删除本地dev分支：git branch -d dev 从远程的origin仓库的master分支下载到本地，并新建一个test分支：git fetch origin master:test 本地从当前所在分支上创建一个新分支： git checkout -b 新分支名 查看test分支与本地原有分支的不同：git diff test 将test分支和当前分支合并：git merge test 将远程git仓库里的指定分支拉取到本地（本地不存在的分支）：git checkout -b 本地分支 origin/远程分支，或者 git pull origin dev(remote):dev(local) 将本地master分支提交到远程dev分支：git push origin master:dev 二、常见报错处理 1、导致报错:error: You have not concluded your merge (MERGE_HEAD exists).的原因可能是在以前pull下来的代码自动合并失败。 解决方案一：保留本地的更改，中止合并-&gt;重新合并-&gt;重新拉取 $:git merge –abort$:git reset –merge$:git pull git pull之后然后重新解决冲突，再push，（记得需要稍微跟自己push的要有一点区别，要不然又会造成这样的情况） 解决方案二：舍弃本地代码，远端版本覆盖本地版本（慎重） $:git fetch –all$:git reset –hard origin/master$:git fetch2、Git fetch和git pull的区别 都可以从远程获取最新版本到本地 git fetch：只是从远程获取最新版本到本地，不会merge(合并) $:git fetch origin master //从远程的origin的master主分支上获取最新版本到origin/master分支上$:git log -p master..origin/master //比较本地的master分支和origin/master分支的区别$:git merge origin/master //合并 Git pull：从远程获取最新版本并merge(合并)到本地 $:git pull origin master //相当于进行了 git fetch 和 git merge两部操作3、本地删除无效的远程分支：清理远程分支，把本地不存在的远程分支删除 git remote prune origin Git 本地分支 关联 远程分支 git branch –set-upstream-to=origin/develop_userflow hegui","link":"/2022/08/06/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Gradle编译Build output乱码","text":"IDEA 打开 HELP-&gt;Edit Custom VM OPtions中加 -Dfile.encoding=utf-8 重启idea 。 Edit Custom VM Options -Dfile.encoding=UTF-8","link":"/2022/08/06/Gradle%E7%BC%96%E8%AF%91%20Build%20output%20%E4%B9%B1%E7%A0%81/"},{"title":"","text":"上一篇文章中我们介绍了android系统的截屏事件，由于截屏事件是一种系统全局处理事件，所以事件的处理逻辑不是在App中执行，而是在PhoneWindowManager中执行。而本文我们现在主要讲解android系统中HOME按键的事件处理，和截屏事件类似，这里的HOME按键也是系统级别的按键事件监听，所以其处理事件的逻辑也应该和截屏事件处理流程类似，从上一篇文章的分析过冲中我们不难发现，系统级别的按键处理逻辑其实都是在PhoneWindowManager中，所以HOME按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中执行，那么我们就从dispatchUnhandleKey方法开始分析HOME按键的处理流程。 好吧我们看一下PhoneWindowManager的dispatchUnhandleKey方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } if (DEBUG_INPUT) { if (fallbackEvent == null) { Slog.d(TAG, &quot;No fallback.&quot;); } else { Slog.d(TAG, &quot;Performing fallback: &quot; + fallbackEvent); } } return fallbackEvent; } 通过查看源码，我们重点看一下dispatchUnhandledKey方法中调用的interceptFallback方法，关于HOME按键的处理逻辑也是在这个方法体中的，所以继续看一下interceptFallback方法的实现： 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; } 通过分析源码我们知道关于HOME按键的处理逻辑主要是在interceptKeyBeforeDispatching方法的实现的，既然这样，我们看一下interceptKeyBeforeDispatching方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) { ... // First we always handle the home key here, so applications // can never break it, although if keyguard is on, we do let // it handle it, because that gives us the correct 5 second // timeout. if (keyCode == KeyEvent.KEYCODE_HOME) { // If we have released the home key, and didn't do anything else // while it was pressed, then it is time to go home! if (!down) { cancelPreloadRecentApps(); mHomePressed = false; if (mHomeConsumed) { mHomeConsumed = false; return -1; } if (canceled) { Log.i(TAG, &quot;Ignoring HOME; event canceled.&quot;); return -1; } // If an incoming call is ringing, HOME is totally disabled. // (The user is already on the InCallUI at this point, // and his ONLY options are to answer or reject the call.) TelecomManager telecomManager = getTelecommService(); if (telecomManager != null &amp;&amp; telecomManager.isRinging()) { Log.i(TAG, &quot;Ignoring HOME; there's a ringing incoming call.&quot;); return -1; } // Delay handling home if a double-tap is possible. if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) { mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); // just in case mHomeDoubleTapPending = true; mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout()); return -1; } handleShortPressOnHome(); return -1; } // If a system window has focus, then it doesn't make sense // right now to interact with applications. WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null; if (attrs != null) { final int type = attrs.type; if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0) { // the &quot;app&quot; is keyguard, so give it the key return 0; } final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length; for (int i=0; i&lt;typeCount; i++) { if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) { // don't do anything, but also don't pass it to the app return -1; } } } // Remember that home is pressed and handle special actions. if (repeatCount == 0) { mHomePressed = true; if (mHomeDoubleTapPending) { mHomeDoubleTapPending = false; mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); handleDoubleTapOnHome(); } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) { preloadRecentApps(); } } else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) != 0) { if (!keyguardOn) { handleLongPressOnHome(event.getDeviceId()); } } return -1; } // Let the application handle the key. return 0; } 这里我们主要看一下对android系统HOME按键的处理逻辑，通过分析源码我们知道HOME按键进入launcher界面的主要逻辑是在handleShortPressOnHome();方法中执行的，所以我们继续看一下handleShortPressOnHome方法的实现。 1234567891011121314private void handleShortPressOnHome() { // Turn on the connected TV and switch HDMI input if we're a HDMI playback device. getHdmiControl().turnOnTv(); // If there's a dream running then use home to escape the dream // but don't actually go home. if (mDreamManagerInternal != null &amp;&amp; mDreamManagerInternal.isDreaming()) { mDreamManagerInternal.stopDream(false /*immediate*/); return; } // Go home! launchHomeFromHotKey(); } 可以看到在handleShortPressOnHome方法中调用了launchHomeFromHotKey方法，该方法的注释用于go home，所以继续看一下该方法的实现： 123void launchHomeFromHotKey() { launchHomeFromHotKey(true /* awakenFromDreams */, true /*respectKeyguard*/); } 可以看到在launchHomeFromHotKey方法中我们又调用了launchHomeFromHotkey的重构方法，这样我们看一下这个重构方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) { if (respectKeyguard) { if (isKeyguardShowingAndNotOccluded()) { // don't launch home if keyguard showing return; } if (!mHideLockScreen &amp;&amp; mKeyguardDelegate.isInputRestricted()) { // when in keyguard restricted mode, must first verify unlock // before launching home mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() { @Override public void onKeyguardExitResult(boolean success) { if (success) { try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } }); return; } } // no keyguard stuff to worry about, just launch home! try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } if (mRecentsVisible) { // Hide Recents and notify it to launch Home if (awakenFromDreams) { awakenDreams(); } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); hideRecentApps(false, true); } else { // Otherwise, just launch Home sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } 可以发现在方法中我们首先调用了ActivityManagerNative.getDefault().stopAppSwitches();该方法主要用于暂停后台的打开Activity的操作，避免打扰用户的操作。比如这时候我们在后台打开一个新的App，那么这时候由于要回到home页面，所以需要先延时打开。方法执行这个方法之后然后执行了sendCloseSystemWindows方法，该方法主要实现了对当前系统App页面的关闭操作，下面我们先看一下ActivityManagerNative.getDefault().stopAppSwitches();方法的实现，这里的ActivityManagerNative.getDefault我们在前面已经多次说过了其是一个Binder对象，是应用进程Binder客户端用于与ActivityManagerService之间通讯，所以这里最终调用的是ActivityManagerService的stopAppsSwitches方法，这样我们就继续看一下ActivityManagerService的stopAppsSwitches方法的实现。 1234567891011121314151617@Override public void stopAppSwitches() { if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES) != PackageManager.PERMISSION_GRANTED) { throw new SecurityException(&quot;Requires permission &quot; + android.Manifest.permission.STOP_APP_SWITCHES); } synchronized(this) { mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME; mDidAppSwitch = false; mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG); Message msg = mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG); mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME); } } 可以发现这里主要是发送了一个异步消息，并且msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG，即跳转Activity，然后我们继续我们看一下mHandler的handleMessage方法当msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG时的操作。而且我们可以发现这里的异步消息是一个延时的异步消息，延时的时间为APP_SWITCH_DELAY_TIME，我们可以看一下该变量的定义： 123// Amount of time after a call to stopAppSwitches() during which we will // prevent further untrusted switches from happening. static final long APP_SWITCH_DELAY_TIME = 5*1000; 然后我们可以看一下mHander的handleMessage方法的具体实现： 12345case DO_PENDING_ACTIVITY_LAUNCHES_MSG: { synchronized (ActivityManagerService.this) { mStackSupervisor.doPendingActivityLaunchesLocked(true); } } break; 可以发现这里直接调用了mStackSupervisor.doPendingActivityLaunchesLocked方法，好吧，继续看一下doPendingActivityLaunchesLocked方法的实现。 1234567final void doPendingActivityLaunchesLocked(boolean doResume) { while (!mPendingActivityLaunches.isEmpty()) { PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags, doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null); } } 可以发现这里就是调用了startActivity的操作了，看过Activity启动流程的同学应该知道：android源码解析之（十四）–&gt;Activity启动流程 这里就是开始启动Activity了，所以当我们按下HOME按键的时候，后台的startActivity都会延时5秒钟执行… 然后回到我们的launchHomeFromHotKey方法，看一下launchHomeFromHotKey方法的实现。 123void sendCloseSystemWindows(String reason) { PhoneWindow.sendCloseSystemWindows(mContext, reason); } 可以发现这里调用了PhoneWindow的静态方法sendCloseSystemWindow,继续看一下该方法的实现逻辑。 12345678public static void sendCloseSystemWindows(Context context, String reason) { if (ActivityManagerNative.isSystemReady()) { try { ActivityManagerNative.getDefault().closeSystemDialogs(reason); } catch (RemoteException e) { } } } 看到这里，很明显了又是调用了Binder的进程间通讯，最终ActivityManagerService的closeSystemDialogs方法会被执行，所以我们继续看一下ActivityManagerService的closeSystemDialogs方法的实现。 12345678910111213141516171819202122232425262728@Override public void closeSystemDialogs(String reason) { enforceNotIsolatedCaller(&quot;closeSystemDialogs&quot;); final int pid = Binder.getCallingPid(); final int uid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); try { synchronized (this) { // Only allow this from foreground processes, so that background // applications can't abuse it to prevent system UI from being shown. if (uid &gt;= Process.FIRST_APPLICATION_UID) { ProcessRecord proc; synchronized (mPidsSelfLocked) { proc = mPidsSelfLocked.get(pid); } if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { Slog.w(TAG, &quot;Ignoring closeSystemDialogs &quot; + reason + &quot; from background process &quot; + proc); return; } } closeSystemDialogsLocked(reason); } } finally { Binder.restoreCallingIdentity(origId); } } 可以发现其实在方法体中将关闭窗口的逻辑下发到了closeSystemDialogsLocked中，所以我们继续看一下closeSystemDialogsLocked方法的实现。 123456789101112131415void closeSystemDialogsLocked(String reason) { Intent intent = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND); if (reason != null) { intent.putExtra(&quot;reason&quot;, reason); } mWindowManager.closeSystemDialogs(reason); mStackSupervisor.closeSystemDialogsLocked(); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, -1, Process.SYSTEM_UID, UserHandle.USER_ALL); } 可以发现在方法体中首先调用了mWindowManager.closeSystemDialogs方法，该方法就是关闭当前页面中存在的系统窗口，比如输入法，壁纸等： 12345678910111213141516171819@Override public void closeSystemDialogs(String reason) { synchronized(mWindowMap) { final int numDisplays = mDisplayContents.size(); for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) { final WindowList windows = mDisplayContents.valueAt(displayNdx).getWindowList(); final int numWindows = windows.size(); for (int winNdx = 0; winNdx &lt; numWindows; ++winNdx) { final WindowState w = windows.get(winNdx); if (w.mHasSurface) { try { w.mClient.closeSystemDialogs(reason); } catch (RemoteException e) { } } } } } } 讲过这样一层操作之后，我们就关闭了当前中存在的系统窗口。然后还是回到我们的launchHomeFromHotKey方法，我们发现在方法体的最后我们调用了startDockOrHome方法，这个方法就是实际的跳转HOME页面的方法了，我们可以具体看一下该方法的实现。 12345678910111213141516171819202122232425262728void startDockOrHome(boolean fromHomeKey, boolean awakenFromDreams) { if (awakenFromDreams) { awakenDreams(); } Intent dock = createHomeDockIntent(); if (dock != null) { try { if (fromHomeKey) { dock.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } startActivityAsUser(dock, UserHandle.CURRENT); return; } catch (ActivityNotFoundException e) { } } Intent intent; if (fromHomeKey) { intent = new Intent(mHomeIntent); intent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } else { intent = mHomeIntent; } startActivityAsUser(intent, UserHandle.CURRENT); } 可以发现我们在方法体中调用了createHomeDockIntent，这个方法的作用就是创建到达HOME页面的Intent对象，然后我们调用了startActivityAsUser方法，这样经过一系列的调用之后就调起了home页面的Activity，所以这时候系统就返回到了HOME页面。 总结： 系统也是在PhoneWindowManager中监听HOME按键的点击并进行处理； 系统监听到HOME按键之后会首先关闭相应的系统弹窗； 通过创建Intent对象，并调用startActivity方法使系统跳转到HOME页面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程","link":"/2022/08/06/HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"Java应该掌握的知识","text":"以Java工程师应该掌握的知识，按重要程度排出六个梯度： 第一梯度：计算机组成原理、数据结构和算法、网络通信原理、操作系统原理；第二梯度：Java基础、JVM内存模型和GC算法、JVM性能调优、JDK工具、设计模式；第三梯度：Spring系列、Mybatis、Dubbo等主流框架的运用和原理；第四梯度：MySQL(含SQL编程)、Redis、RabbitMQ/RocketMQ/Kafka、ZooKeeper等数据库或者中间件的运用和原理；第五梯度：CAP理论、BASE理论、Paxos和Raft算法等其他分布式理论；第六梯度：容器化、大数据、AI、区块链等等前沿技术理论；","link":"/2022/08/06/Java%E5%AD%A6%E4%B9%A0/"},{"title":"Java基础知识面试题","text":"Java语言有啥特点？ 简单易学 面向对象（封装、继承、多态、抽象） 跨平台（JVM实现跨平台） 可靠性 安全性 支持多线程 支持网络编程 编译和解析并存JVM是什么？ JVM（Java虚拟机）：是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。 字节码：JVM可以理解的代码，扩展名为 .class 的文件。它不面向任何特定的处理器，只面向虚拟机。Java通过字节码的方式，在一定程度上解决了传统解析型语言执行效率低的问题，同时又保留了解析型语言可移植的特定。所以Java程序运行比较高效。 字节码和不同系统的JVM的实现是Java语言“一次编译，随处可运行”的关键。 Java 程序运行过程OracleJDK 和 OpenJDK 的对比？ OpenJDK是一个参考模型并且是完全开源的；而OracleJDK是基于OpenJDK7构建的，并不是完全开源的。 OracleJDK比OpenJDK更稳定。两者代码几乎相同，但OracleJDK有更多的类和一些错误的修复。 在响应性和JVM性能方面，OracleJDK更出色一些。import java 和 javax 有什么区别？ 刚开始Java API所必需的包是java开头的包，javax是扩展API包来使用。 后来 javax 逐渐成为 Java API 的组成部分。字符型常量 和 字符串常量的区别？ 形式上：字符型常量是单引号引起的一个字符；字符串常量是双引号引起的0个或若干个字符； 含义上：字符型常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（在内存中的存放位置）； 内存大小：字符型常量只占2个字节；字符串常量占若干个字节；标识符和关键字的区别？ 标识符：是一个名字，类、变量、方法的名字都是标识符。 关键字：被Java语言赋予了特殊含义的标识符。例如：private / public / class / new 等。Java泛型？类型擦除？常用的通配符？ Java泛型：JDK5引入的一个新特性，提供了编译时类型安全检测的机制。表现为：将类型当作参数传递给一个类或者方法。 泛型类 泛型接口 泛型方法 类型擦除：Java泛型是伪泛型，Java在编译期间，所有的泛型信息都会被擦除掉。 常用通配符 ？ 表示不确定的java类型 T 表示具体的一个java类型 K / V 分别表示Java键值对的 key value E 表示 Element == 和 equals 的区别？ == ： 基本数据类型 比较的是值是否相等； 引用类型 比较的是内存地址是否一样（即两个对象是否同一个对象）； ｜ 因为Java只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。 equals：判断两个对象是否相等，不能用于比较基本数据类型的变量。 ｜ equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。 类没有覆盖equals方法：等价于“==”，使用的默认是Object类的equals方法。 类覆盖了equals方法：一般都会覆盖equals方法，来比较两个对象的内容是否相等。为什么重写equals方法时，必须重写hashCode方法？ hashCode()方法介绍 ｜ 在Object类中的一个本地方法，作用是获取哈希码（散列码），它是一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。 为什么要有 hashCode()方法？ ｜ 以“HashSet 如何检查重复”为例子说明。 ｜ 当把对象添加到HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值做比较，如果没有相同的hashCode，则认为没有重复的对象。如果有相同的hashCode（发生碰撞），则会调用equals()方法来判断对象是否相同。如果相同，则不会让其加入成功。如果不同，则重新散列到其他位置。这样就减少使用equals的次数，提高了执行速度。 重写equals方法，必须重写hashCode方法 ｜ hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()方法，则两个对象是永远不相等的（即使有同样的数据）。 如果两个对象相等（equals返回true），则它们的hashCode也一定相等。 如果两个对象的hashCode相等，但它们不一定相等（equals不一定返回true）。为什么说Java中只有值传递？ 按值调用（call by value）：方法接收的是调用者提供的值。 按引用调用（call by reference）：方法接收的是调用者提供的变量地址。 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 Java才用按值调用，方法得到的是参数值的一个拷贝。深拷贝、浅拷贝？ 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递。 ｜ 引用类型未新建对象，仍指向同一个对象（引用地址值）。 深拷贝：对基本数据类型进行值传递，对引用类型，创建一个新的对象，并复制其内容。 ｜ 引用类型新建了对象，引用地址值不相等。定义一个不做事且无参的构造函数的作用？ Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则默认会调用父类中“无参构造方法”。因此，如果父类中没有定义“无参构造方法”，而子类构造方法又没有用super()去调用父类特定的构造方法，则编译会发生错误。成员变量 与 局部变量 的区别？ 成员变量属于类的；局部变量是在代码块或方法中定义的变量或方法的参数； 成员变量可以被private、public、static 等修饰符所修饰；局部变量不能被访问控制修饰符及static修饰； 成员变量和局部变量都可以被 final修饰； 成员变量存在于堆内存；局部变量存在于栈内存； static修饰的成员变量属于类的，随着类的初始化而存在；没有static修饰的成员变量是对象的一部分，随着对象的创建而存在；局部变量随着方法的调用而存在和自动消失； 成员变量如果没有被赋初值，则会自动以类型的默认值赋值（被final修饰的例外，需要显示赋值）；局部变量不会自动赋值；对象实例和对象引用的关系？ 对象实例存在堆内存中；对象引用存在栈内存中； 一个对象实例可以有若干个对象引用指向它；一个对象引用指向0个或1个对象实例；类的构造方法？ 作用是：完成对类对象的初始化工作。 一个类没有显示声明构造方法也可以执行，因为Java会给它一个默认的无参构造方法；如果显示声明了构造方法，那Java不会给它再添加默认的构造方法。 特性 名字与类名相同； 没有返回值，并且不能用void声明； 生成类的对象时自动执行，无需调用。 子类在构造方法里调用父类的无参构造方法的目的是？ 帮助子类完成初始化工作。面向对象的特征？ 抽象 ｜ 将一些事物的共性和相似点抽离出来，并将这些属性归为一个类。 封装 ｜ 指把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但可以通过对象提供的一些可以被外界访问的方法来操作属性。 继承 ｜ 使用已存在的类（父类）作为基础建立新的类（子类），新类拥有父类的属性和方法，并可以增加新的属性和方法。通过继承，可以快速创建新类，提高代码的重用和程序的可维护性。 子类拥有父类的所有属性和方法（包括私有的），但无法访问父类私有的属性和方法，仅仅是拥有。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以覆盖父类的方法。 多态 ｜ 一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。 对象类型和引用类型之间，具有继承（类）或实现（接口）的关系； 引用类型变量发出的方法调用到底是哪个类中的方法，必须在运行期间才能确定； 多态不能调用“只在子类存在但父类不存在”的方法； 如果子类重写了父类的方法，执行的是子类覆盖的方法，否则是父类的方法；String、StringBuffer、StringBuilder 的区别？ 可变性 String类中使用final关键字修饰字符数组来保存字符串（private final char value[]），所以String对象是不可变的。 StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在该类中也是使用字符数组（char[] value）来保存字符串，但没有用final关键字修饰，所以这两种对象都是可变的。 线程安全性 String 对象是不可变的，可以理解成常量，所以线程安全。 AbstractStringBuilder 是StringBuffer、StringBuilder的父类，定义了一些字符串的基本操作方法，如：append、indexOf等公共方法。StringBuffer对方法加了同步锁（public synchronized StringBuffer append(String str)），所以是线程安全的。StringBuilder没有对方法进行加同步锁，所以是非线程安全。 性能 String 类型进行改变的时候，会生成一个新的String对象，然后将指针指向新的String对象； StringBuffer 进行改变时，会对StringBuffer对象本身进行操作； StringBuilder与StringBuffer操作一样，但因为没有加同步锁，性能更好一些； 总结 操作少量的数据：适用 String 单线程操作字符串缓存区下大量的数据：适用 StringBuilder 多线程操作字符串缓存区下大量的数据：适用 StringBufferObject类常见的方法有哪些？ public final native Class getClass() ｜ 本地方法，返回当前运行时对象的Class对象，final关键字修饰，子类不可重写。 public native int hashCode() ｜ 本地方法，返回对象的哈希码，主要使用在哈希表中，如：HashMap。 public boolean equals(Object obj) ｜ 用于比较两个对象内存地址是否相等，String类对该方法重写后用于比较字符串的值是否相等。 protected native Object clone() throws CloneNotSupportedException ｜ 本地方法，用于创建并返回当前对象的一份拷贝。 public String toString() ｜ 返回 类名@实例的哈希码的16进制字符串。 public final native void notify() ｜ 本地方法，并且不能重写。唤醒一个在此对象监视器（锁）上等待的线程。如果有多个线程在等待，只会唤醒一个。 public final native void notifyAll() ｜ 跟notify()一样，区别在于会唤醒所有在此对象监视器等待的线程。 public final native void wait(long timeout) throws InterruptedException ｜ 暂停线程的执行。等待时间（timeout）到了会释放锁，sleep()方法没有释放锁。 public final void wait(long timeout, int nanos) throws InterruptedException ｜ nanos参数：表示额外时间（单位：纳秒，范围：0-999999， 1纳秒 = 十亿分之一秒）。超时的时间需要加上nanos纳秒（过去式）。查看源码，只要 nanos 在0-999999范围内，则 timeout++； public final void wait() throws InterruptedException ｜ 暂停线程的执行，并且没有超时概念，一直等待。 protected void finalize() throws Throwable { } ｜ 实例被垃圾回收器回收的时候触发。Java序列化中如果有些字段不想被序列化，怎么办？ 对于不想被序列化的变量，使用 transient 关键字修饰。 transient 关键字：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。获取键盘输入常用的两种方法？ 通过 Scanner 类 通过 BufferReader 类反射机制？ 什么是反射机制？ ｜ 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息和动态调用对象的方法的功能称为反射机制。 静态编译 VS 动态编译 静态编译：编译时确定类型，绑定对象； 动态编译：运行时确定类型，绑定对象； 反射机制的优缺点 优点：运行期类型的判断、动态加载类、提高代码灵活度。 缺点 性能问题：反射相当于一系列解析操作，通知JVM要做的事情，比直接的java代码要慢很多。 安全问题：动态操作改变类的属性，增加了安全隐患。 反射技术的应用 JDBC连接数据库时使用Class.forName() 通过反射加载数据库的驱动程序； Spring 的IOC创建对象（动态加载管理Bean）、AOP（动态代理）功能； 动态配置实例的属性； 获取Class 对象的两种方式 知道具体类的情况 ｜ Class clazz = TargetObject.class; 通过 Class.forName() 传入类的路径获取； ｜ 一般是不知道具体类的，基本都是通过便利包下面的类来获取Class对象 ｜ Class clazz = Class.forName(“com.xxx.TargetObject”);Java异常有哪些？ 所有的异常都有一个共同的祖先：java.lang.Throwable类，Throwable类有两个重要的子类Exception（异常）和Error（错误）。Exception 能被程序本身处理（try-catch），Error是无法处理的。 Exception ： 程序本身可以处理的异常，可以通过 catch 捕获。 受检异常（必须处理的） ｜ 在编译过程中，如果没有被 catch / throw 处理，则无法通过编译。除了RuntimeException及其子类之外，其他的Exception类及其子类都属于受检异常。 IOException ClassNotFoundException SQLException 不受检异常（可以不处理） ｜ 在编译过程中，即使不处理也可以正常编译通过。RuntimeException及其子类统称为非受检异常。 NullPointException NumberFormatException ArrayIndexOutBoundsException ArithmeticException Error：程序无法处理的错误。JVM会选择终止线程。 Virtual MachineError （Java虚拟机运行错误） OutOfMemoryError （虚拟机内存不够错误） NoClassDefFoundError （类定义错误） StackOverflowError （栈溢出错误）try-catch-finally try 块：用于捕获异常。其后可以接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch 块：用于处理try捕获到的异常。 finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当try块或catch块中遇到return语句时，finally块的语句将在方法返回之前被执行，并且finally语句返回值将覆盖原始返回值。 以下3种情况下，finally块不会被执行 在try或finally块中用 System.exit(int)退出程序。并且这句要在异常语句之前。 程序所在的线程死亡。 关闭CPU。try-with-resources 适用范围：任何实现 java.lang.AutoCloseable 或 java.io.Closeable的对象。 面对需要关闭的资源，我们总是应该优先使用 try-with-resources，而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources 语句让我们更容易编写必须要关闭的资源代码，若采用try-finally 则几乎做不到这点。—《Effective Java》 InputStream、Scanner等资源都需要调用close()方法手动关闭。 try-catch-finally实现方式 使用Java 7 之后的try-with-resources 语句改造上面的代码： 当多个资源需要关闭的时候，通过使用分号分隔。Java中IO流分为几种？ 按照流的流向分：分为输入流和输出流； 按照流的操作单元分：分为字节流和字符流； 按照流的角色分：分为节点流和处理流； Java IO流有40多个类，都是从以下4个抽象类基类中派生出来的。 InputStream / Reader ：所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream / Writer ：所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式 按操作对象既然有了字节流，为什么还要有字符流？ 不管是文件读写还是网络传输，信息的最小存储单元都是字节，那为什么I/O流操作要分为字节流和字符流？ 字符流是由于Java虚拟机将字节转换得到的，这个过程比较复杂耗时，并且，如果不知道编码类型很容易出现乱码问题。所以，I/O流提供了一个直接操作字符的接口，方便对字符进行流操作。怎么解决浮点数进度丢失？ 使用BigDecimal 浮点数之间的等值判断，基本数据类型不能用“==”来比较，包装类型不能用“equals”来判断。（具体原理与浮点数的编码方式有关，精度丢失） 使用BigDecimal来定义浮点数，再进行运算操作 在使用BigDecimal时，为防止精度丢失，推荐使用它的BigDecimal(String) 构造方法或者BigDecimal.valueOf方法来创建对象，禁止使用构造方法BigDecimal(double)的方式把double值转化为BigDecimal对象。 BigDecimal a = new BigDecimal(0.1f); 实际存储值为：0.10000000149 BigDecimal a = new BigDecimal(“0.1”); 正解 BigDecimal a = new BigDecimal.valueOf(0.1); 正解工具类Arrays.asList() 使用注意事项？ Arrays.asList() 将数组转换为集合后，底层其实还是数组，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UpsupportedOperationException异常。 Arrays.asList() 的返回对象是一个Arrays 的内部类，并没有实现集合的修改方法。体现的是适配器模式，只是转换接口，后台的数据仍是数组。 传递的数组必须是对象数组，而不是基本类型。（Arrays.asList()是泛型方法，传入的对象必须是对象数组） ｜ 当传入一个基本类型的数组时，Arrays.asList()的得到的参数不是数组中的元素，而是数组本身。此时List的唯一元素就是这个数组。如何将数组转换为ArrayList？ 自定义方法实现 结合Arrays.asList()实现（推荐） 使用Java 8 的Stream（推荐） 使用Java 9 的List.of()方法不要在 foreach 循环里进行元素的 remove / add 操作？ fail-fast（快速失败） 机制：java集合（Collection）中的一种错误机制。 当多个线程对同一个集合内容进行操作时，就可能会产生fail-fast事件。 ｜ 例如：当某一个线程A通过iterator便利某集合的过程中，若该集合内容被其他线程所改变了，那么线程A访问该集合时，就会抛出ConcurrentModificationException异常。 单线程下，在foreach循环里调用集合类的remove方法，将抛出ConcurrentModificationException异常。 解决方案一：Java 8 开始可以使用Collection#removeIf()方法删除满足条件的元素。 解决方案二：使用Iterator方式。（如果并发，需要对Iterator对象加锁） fail-safe（安全失败）机制：采用安全失败机制的容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所做的修改并不能被迭代器检测到，故不会抛ConcurrentModificationException异常。创建对象的方式有哪几种？ new 方法。 clone()：使用Object的clone方法。 反射 调用public无参构造函数，若没有，则会报异常。 ｜ Object obj = clazz.newInstance(); 调用带有参数的构造函数，先获取到其构造对象，再通过构造方法类获取实例。 ｜ // 获取构造函数类的对象 ｜ Constructor constructor = User.class.getConstructor(String.class); ｜ // 使用构造对象的newInstance方法初始化对象 ｜ Object obj = constructor.newInstance(“name”); 发序列化创建对象。（被创建实例的类需实现Serializable接口）如何实现静态代理？优缺点？ 实现方式 1. 为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口。 2. 在创建对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法。 优点 在客户端和目标对象之间充当中介的作用，保护目标对象； 可以扩展目标对象的功能；（在调用目标对象方法的前后增加其他一些方法。）比如：打印日志 缺点 需要为每一个目标类编写对应的代理类，产生的类太多，工作量大。 相比直接调用目标对象的方法，效率低一些。了解动态代理？在哪些地方用到？ 作用 为其它对象提供一种代理以控制对这个对象的访问。 JDK动态代理的实现 在运行运行时，通过反射机制动态生成代理对象； 调用程序必须实现InvocationHandler接口； 使用Proxy类中的newProxyInstance方法动态的创建代理类。 在哪些地方应用到？ AOP、RPC 框架中都有用到。 JDK的动态代理与CGLIB的区别 JDK动态代理只能代理实现了接口的类；而CGLIB可以代理未实现任何接口的类。 JDK动态代理是通过反射的方式创建代理类；而CGLIB动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能将代理类声明为final类型的类和方法； JDK动态代理的效率更优。对Java注解的理解，解决声明问题？ Java语言中的类、方法、变量、参数和包等都可以注解标记，在程序运行期间可以获取到相应的注解以及注解中定义的内容。 注解极大地简化了代码，通过注解可以帮助我们简单地完成一些事情；比如：Spring中如果检测到你的类被 @Component 注解标记的话，Spring容器在启动的时候就会把这个类进行管理，我们可以通过 @Autowired 注解注入类的实例。内存泄漏和内存溢出？ 内存泄漏 定义：是指不再使用的对象持续占用内存或者它们占用的内存得不到及时释放，从而造成内存空间的浪费。 根本原因：长生命周期的对象持有短生命周期对象的引用； 内存泄漏场景 静态集合类引起：静态成员的生命周期是整个程序运行期间。 ｜ 例如Map是在堆上动态分配对象，正常情况下使用完毕后，就会被gc回收。而如果Map被static修饰，且没有删除机制，静态成员是不会被回收的，所以导致很大的Map一直停留在堆内存中。懒初始化static变量，尽量避免使用。 当集合里的对象属性被修改后，再调用remove()方法是不起作用的。 ｜ 当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了。 各种连接对象（IO流对象、数据库连接对象、网络连接对象）使用后未关闭。 ｜ 因为每个流在操作系统层面都对应了打开的文件句柄，流没有关闭，会导致操作系统的文件句柄一直处于打开状态，而JVM会消耗内存来跟踪操作系统打开的文件句柄。 监听器的使用。 ｜ 在释放对象的同时，没有相应删除监听器的时候，也可能导致内存泄露。 不正确使用单例模式。 ｜ 单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么被持有的对象将不能被JVM正常回收。 解决措施 尽量减少使用静态变量，类的静态变量的生命周期是和类同步的。 声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员变量改写为方法内 的局部变量。 减少长生命周期的对象持有短生命周期的引用。 使用StringBuilder和StringBuffer替换String进行字符串连接。避免产生大量临时字符串。 对于不需要使用的对象，手动设置null值，不管GC何时会开始清理，我们都应该及时的将无用的对象标记为可被清理的对象。 各种连接（数据库连接、网络连接、IO连接）操作，操作结束都务必显式调用close关闭。 内存溢出 指程序运行过程中无法申请到足够的内存而导致的一种错误。 通常发生在OLD段或perm段垃圾回收后，仍然无内存空间容纳新的对象的情况。 内存溢出场景 JVM Heap(堆)溢出：（java.lang.OutOfMemoryError：java heap space） ｜ 发生这种问题的原因是java虚拟机创建的对象太多了，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了。 ｜ 解决方法 ｜ JVM在启动的时候，会自动设置JVM Heap的值，可以利用JVM提供的 -Xmn -Xms -Xmx 等选项进展设置。Heap的大小是新生代和老年代之和。 手动设置JVM Heap的大小； 检查程序，看是否有死循环或不必要地创建大量对象； Metaspace溢出：（java.lang.OutOfMemoryError:Metaspace） ｜ 原因：程序中使用了大量的jar或class，使java虚拟机装载类的空间不够。 ｜ 解决方法 ｜ ​方法区用于存放java类型的相关信息。在类装载器加载class文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储信息而方法区的内存占用又已经达到 -XX:MaxMetaspaceSize设置的最大值，将会抛出此异常。测试基本思路：运行时产生大量的类去填满方法区，直到溢出。 通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。 栈溢出：（java.lang.OutOfMemoryError:Thread Stack space） ｜ 线程的方法嵌套调用层次太多（如：递归调用），以致把栈区溢出了。 解决方法 修改程序； 通过 -Xss：来设置每个线程的Stack 大小；BIO、NIO、AIO BIO （Blocking I/O） ｜ 同步阻塞I/O模式，数据的读写必须阻塞在一个线程内等待其完成。 NIO （Non-Blocking/New I/O） ｜ 是一种同步非阻塞的I/O模型，对应java.nio包，提供了Channel、Selector、Buffer 等抽象。 ｜ 单线程从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。非阻塞写数据也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程可以同时去做别的事情。JDK的NIO底层由epoll实现。 NIO中所有I/O操作都是从Channel（通道）开始的。 从通道进行数据读取，创建一个缓存区，然后请求通道读取数据。 从通道进行数据写入，创建一个缓冲区，填充数据，并请求通道写入数据。 AIO （Asynchronous I/O） ｜ 异步非阻塞I/O模型，异步I/O是基于事件和回调机制实现的。应用操作之后会直接返回，不会阻塞，当后台处理完成，操作系统会通知相应的线程进行后续的操作。Java中finalize()方法的使用？ finalize() 是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize() 方法中一般用于释放非Java资源（如：打开的文件资源、数据库连接等），或是调用非Java方法（native方法）时分配的内存。 避免使用的原因 finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到finalize()方法被执行，所花费的时间是任意长的。我们不能依赖finalize()方法能及时的回收占用的资源，可能在资源耗尽之前，gc仍为触发。因此通常的做法是提供显式的close()方法供客户端手动调用。 finalize() 方法意味着回收对象时需要进行更多的操作，从而延长了对象回收的时间。Java中Class.forName 和 ClassLoader的区别？ Class.forName() 和 ClassLoader 都可以对类进行加载； ClassLoader 遵循双亲委派模型，实现的功能是通过一个类的全限定名来获取描述此类的二进制字节流，获取到二进制流后放到JVM中。ClassLoader只做一件事，就是将.class文件加载到JVM中，不会只想static中的内容。 Class.forName()方法实际上也是调用ClassLoader来实现的，不同的是除了将类的.class文件加载到JVM中之外，还会对类进行初始化，执行类中的static块。讲一下CopyOnWriteArrayList和CopyOnWriteArraySet？ CopyOnWrite 容器：写时复制的容器。往一个容器添加元素时，不是直接往当前容器添加，而是先将当前容器进行copy，复制出一个新的容器，然后往新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。 添加元素的时候需要加锁，否则多线程写的时候会copy出N个副本 读的时候不需要加锁，多线程读写时，读到的可能还是旧数据，因为读的时候不会对当前容器加锁 CopyOnWrite 并发容器主要用于读多写少的并发场景。 优点：可以对CopyOnWrite容器进行并发读，而不需要加锁，因为当前容器不会添加任何元素。 ｜ CopyOnWrite容器是一种读写分离的思想，读和写不同的容器。 缺点 内存占用问题 ｜ 因为CopyOnWrite是写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存。如果这些对象占用的内存比较大，那么有可能会造成频繁的Yong GC 和 Full GC。 针对内存占用问题，可以通过压缩容器中的元素来减少大对象的内存消耗，如元素全是10进制的数字，可考虑把它压缩成36进制或者64进制。或者不使用CopyOnWrite容器，而使用其他并发容器，如：ConcurrentHashMap。 数据一致性问题 ｜ CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。HashMap了解多少？ HashMap底层实现 HashMap 是用数组 + 链表 + 红黑树（JDK1.8开始增加了红黑树）进行实现的，当添加一个元素（key-value）时，首先计算元素key的hash值，并根据hash值来确定插入数组的位置，如果发生碰撞（存在其他元素已经被放在数组同一位置），这个时候便使用链表来解决哈希冲突，当链表长度太长的时候，便将链表转为红黑树来提高搜索的效率。 数组的容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。 数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组，这个0.75就是默认的负载因子，可由构造函数传入。 为了解决碰撞，数组中的元素是单向链表类型。当链表长度达一个阈值时（&gt;=8），会将链表转换为红黑树提高性能。而当链表长度缩小到另一个阈值（&lt;=6）时，又会将红黑树转换回单向链表提高性能。 HashMap的put方法执行流程/步骤 1. 判断数组table是否为null，若为null则执行resize()扩容操作。 2. 根据键key的值计算hash值得到插入的数组索引i，若table[i] == nulll，则直接新建节点插入，进入步骤6；若table[i]非null，则继续执行下一步。 3. 判断table[i]的首个元素key是否和当前key相同（hashCode和equals均相同），若相同则直接覆盖value，进入步骤6，反之继续执行下一步。 4. 判断table[i]是否为treeNode，若是红黑树，则直接在树中插入键值对并进入步骤6，反之继续执行下一步。 5. 遍历table[i]，判断链表长度是否大于8，若&gt;8，则把链表转换为红黑树，在红黑树中执行插入操作；若&lt;8，则进行链表的插入操作；遍历过程中若发现key已存在则会直接覆盖该key的value值。 6. 插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold，若超过则进行扩容。 HashMap的get方法执行流程/步骤 1. 首先定位到键所在的数组的下标，并获取对应节点n。 2. 判断n是否为null，若n为null，则返回null并结束；反之，继续下一步。 3. 判断n的key和要查找的key是否相同(key相同指的是hashCode和equals均相同)，若相同则返回n并结束；反之，继续下一步。 4. 判断是否有后续节点m，若没有则结束；反之，继续下一步。 5. 判断m是否为红黑树，若为红黑树则遍历红黑树，在遍历过程中如果存在某一个节点的key与要找的key相同，则返回该节点；反之，返回null；若非红黑树则继续下一步。 6. 遍历链表，若存在某一个节点的key与要找的key相同，则返回该节点；反之，返回null。 HashMap的扩容机制 扩容是为了防止HashMap中的元素个数超过了阀值，从而影响性能所服务的。而数组是无法自动扩容的，HashMap的扩容是申请一个容量为原数组大小两倍的新数组，然后遍历旧数组，重新计算每个元素的索引位置，并复制到新数组中；又因为HashMap的哈希桶数组大小总是为2的幂次方，所以重新计算后的索引位置要么在原来位置不变，要么就是“原位置+旧数组长度”。其中，threshold和loadFactor两个属性决定着是否扩容。threshold=LengthloadFactor，Length表示table数组的长度（默认值为16），loadFactor为负载因子（默认值为0.75）；阀值threshold表示当table数组中存储的元素个数超过该阀值时，即需要扩容。 HashMap的扩容使用新的数组代替旧数组，然后将旧数组中的元素重新计算索引位置并放到新数组中，对旧数组中的元素如何重新映射到新数组中？ HashMap的哈希算法数组扩容 ｜ （a）为扩容前，key1和key2两个key确定索引的位置；（b）为扩容后，key1和key2两个key确定索引的位置；hash1和hash2分别是key1与key2对应的哈希“与高位运算”结果。 ｜ (a)中数组的高位bit为“1111”，120 + 121 + 122 + 123 = 15，而 n-1 =15，所以扩容前table的长度n为16； ｜ (b)中n扩大为原来的两倍，其数组大小的高位bit为“1 1111”，120 + 121 + 122 + 123 + 124 = 15+16=31，而 n-1=31，所以扩容后table的长度n为32； ｜ (a)中的n为16，(b)中扩大两倍n为32，相当于(n-1)这部分的高位多了一个1，然后和原hash码作与操作，最后元素在新数组中映射的位置要么不变，要么向后移动16个位置。 HashMap中数组扩容两倍后位置的变化 ｜ 因此，在扩充HashMap，复制数组元素及确定索引位置时不需要重新计算hash值，只需要判断原来的hash值新增的那个bit是1，还是0；若为0，则索引未改变；若为1，则索引变为“原索引+oldCap” HashMap中数组16扩容至32 ｜ JDK1.7中扩容时，旧链表迁移到新链表的时候，若出现在新链表的数组索引位置相同情况，则链表元素会倒置，但从上图中看出JKD1.8的扩容并不会颠倒相同索引的链表元素。 扩容机制设计的优点 1. 省去了重新计算hash值的时间(由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快)，只需判断新增的一位是0或1； 2. 由于新增的1位可以认为是随机的0或1，因此扩容过程中会均匀的把之前有冲突的节点分散到新的位置(bucket槽)，并且位置的先后顺序不会颠倒； 3. JDK1.7中扩容时，旧链表迁移到新链表的时候，若出现在新链表的数组索引位置相同情况，则链表元素会倒置，但JKD1.8的扩容并不会颠倒相同索引的链表元素。 HashMap 和 Hashtable 的区别 线程安全 HashMap是非线程安全的； Hashtable是线程安全的，方法被synchronized修饰； 是否允许NULL值 HashMap允许有一个key是NULL，允许值为NULL； Hashtable无论是key还是value都不允许为NULL； 继承的父类 HashMap和Hashtable都实现了Map接口； HashMap继承的父类是AbstractMap； Hashtable继承的父类是Dictionary； contains()方法 HashMap没有contains()方法，但有containsValue和containsKey方法； Hashtable保留了contains方法，也有containsValue和containsKey方法；contains方法与containsValue方法效果一样（containsValue方法里调用contains方法）。 计算hash值的方式不同 二叉树 某节点的左子树节点值仅包含小于该节点值 某节点的右子树节点值仅包含大于该节点值 左右子树每个也必须是二叉查找树 图示 红黑树 每个节点都有红色或黑色 树的根始终是黑色的 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点） 从节点（包括根）到其任何后代NULL节点（叶子结点下方挂的两个空节点，并且认为他们是黑色的）的每条路径都具有相同数量的黑色节点。ConcurrentHashMap的底层实现？ 底层数据结构 JDK 1.7 的ConcurrentHashMap底层采用 分段的数组+链表 实现； JDK 1.8 采用的数据结构跟HashMap 1.8 一致：数组 + 链表 | 红黑二叉树； 实现线程安全的方式 JDK 1.7 ，ConcurrentHashMap（分段锁）对整个桶数据进行了分割分段（Segment），每一把锁只锁容器其中一部分的数据，多线程访问容器中不同数据段的数据，就不会存在锁竞争，提高并发访问率； JDK 1.8，开始摒弃Segment的概念，并发控制使用 synchronized 和 CAS 来操作，像是优化过且线程安全的HashMap。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率非常高。 ConcurrentHashMap的读操作为什么不需要加锁？ get操作全程不需要加锁是因为Node的成员val是用volatile修饰的，和数组用volatile修饰无关； 数组用volatile修饰主要是保证在数组扩容的时候保证可见性； 总结：定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，而不会读到过期值。由于get操作只需读不需要写共享变量，所以不用加锁。之所以不会读到过期值，依据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，get总能拿到最新值。HashMap、LinkedHashMap、TreeMap 有什么区别？各自的使用场景？ LinkedHashMap 保存了记录的插入顺序，在用Iterator遍历时，先取到的记录是先插入的，遍历比HashMap慢； TreeMap 实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序，也可以指定排序的比较器）。 使用场景 HashMap：一般情况下，使用最多的；适用于Map的插入、删除和定位元素； TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下； LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下；HashMap 多线程操作死循环问题 由于多线程并发下进行扩容（调用rehash()方法）造成元素之间形成一个循环链表。 正常Rehash过程 ｜ 1. 假设了hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。 ｜ 2. 最上面的是old hash表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table1这里了。 ｜ 3. 接下来的三个步骤是Hash表 resize成4，然后所有的元素重新rehash的过程。 并发的Rehash过程 ｜ 假设有两个线程：线程一和线程二，假设出现以下过程： ｜ 1. 线程一执行到 next = e.next; 的时候，被CPU挂起； （当前元素e = 3, next = 7;） ｜ 2. 线程二执行完成，完成了扩容操作，链表被改变，元素被翻转；（元素 7 的next元素变为 3） ｜ 3. 线程一重新获得CPU，继续执行，由于链表已经被线程二改了，原来元素3的next元素是7，现在发现7的next元素居然是3，一脸闷逼，进入死循环疯狂操作！！！ JDK 1.8 已经解决了该问题，但是由于HashMap是非线程安全的，多线程下使用还是会存在其他问题，比如：数据丢失。所以多线程下如果需要更新操作的，建议改用 ConcurrentHashMap。","link":"/2022/08/08/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"Launcher启动流程(转)","text":"Launcher程序就是我们平时看到的桌面程序，它其实也是一个android应用程序，只不过这个应用程序是系统默认第一个启动的应用程序，这里我们就简单的分析一下Launcher应用的启动流程。 不同的手机厂商定制android操作系统的时候都会更改Launcher的源代码，我们这里以android23的源码为例大致的分析一下Launcher的启动流程。 通过上一篇文章，我们知道SystemServer进程主要用于启动系统的各种服务，二者其中就包含了负责启动Launcher的服务，LauncherAppService。具体关于SystenServer的启动流程可以参见： android源码解析之（九）–&gt;SystemServer进程启动流程 在SystemServer进程的启动过程中会调用其main静态方法，开始执行整个SystemServer的启动流程，在其中通过调用三个内部方法分别启动boot service、core service和other service。在调用startOtherService方法中就会通过调用mActivityManagerService.systemReady()方法，那么我们看一下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// We now tell the activity manager it is okay to run third party // code. It will call back into us once it has gotten to the state // where third party code can really run (but before it has actually // started launching the initial applications), for us to complete our // initialization. mActivityManagerService.systemReady(new Runnable() { @Override public void run() { Slog.i(TAG, &quot;Making services ready&quot;); mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); try { mActivityManagerService.startObservingNativeCrashes(); } catch (Throwable e) { reportWtf(&quot;observing native crashes&quot;, e); } Slog.i(TAG, &quot;WebViewFactory preparation&quot;); WebViewFactory.prepareWebViewInSystemServer(); try { startSystemUi(context); } catch (Throwable e) { reportWtf(&quot;starting System UI&quot;, e); } try { if (networkScoreF != null) networkScoreF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Score Service ready&quot;, e); }&lt;!-- more --&gt; try { if (networkManagementF != null) networkManagementF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Managment Service ready&quot;, e); } try { if (networkStatsF != null) networkStatsF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Stats Service ready&quot;, e); } try { if (networkPolicyF != null) networkPolicyF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Policy Service ready&quot;, e); } try { if (connectivityF != null) connectivityF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Connectivity Service ready&quot;, e); } try { if (audioServiceF != null) audioServiceF.systemReady(); } catch (Throwable e) { reportWtf(&quot;Notifying AudioService running&quot;, e); } Watchdog.getInstance().start(); // It is now okay to let the various system services start their // third party code... mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); try { if (wallpaperF != null) wallpaperF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying WallpaperService running&quot;, e); } try { if (immF != null) immF.systemRunning(statusBarF); } catch (Throwable e) { reportWtf(&quot;Notifying InputMethodService running&quot;, e); } try { if (locationF != null) locationF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying Location Service running&quot;, e); } try { if (countryDetectorF != null) countryDetectorF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying CountryDetectorService running&quot;, e); } try { if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying NetworkTimeService running&quot;, e); } try { if (commonTimeMgmtServiceF != null) { commonTimeMgmtServiceF.systemRunning(); } } catch (Throwable e) { reportWtf(&quot;Notifying CommonTimeManagementService running&quot;, e); } try { if (textServiceManagerServiceF != null) textServiceManagerServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TextServicesManagerService running&quot;, e); } try { if (atlasF != null) atlasF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying AssetAtlasService running&quot;, e); } try { // TODO(BT) Pass parameter to input manager if (inputManagerF != null) inputManagerF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying InputManagerService running&quot;, e); } try { if (telephonyRegistryF != null) telephonyRegistryF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TelephonyRegistry running&quot;, e); } try { if (mediaRouterF != null) mediaRouterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MediaRouterService running&quot;, e); } try { if (mmsServiceF != null) mmsServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MmsService running&quot;, e); } } }); 可以发现这个方法传递了一个Runnable参数，里面执行了各种其他服务的systemReady方法，这里不是我们关注的重点，我们看一下在ActivityManagerService中systemReady方法的具体实现，方法体比较长，我就不在这里贴出代码了，主要的逻辑就是做一些ActivityManagerService的ready操作 1234567public void systemReady(final Runnable goingCallback) { ... // Start up initial activity. mBooting = true; startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;); ... } 重点是在这个方法体中调用了startHomeActivityLocked方法，看其名字就是说开始执行启动homeActivity的操作，好了，既然如此，我们再看一下startHomeActivityLocked的具体实现： 12345678910111213141516171819202122232425262728boolean startHomeActivityLocked(int userId, String reason) { if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) { // We are running in factory test mode, but unable to find // the factory test app, so just sit around displaying the // error message and don't try to start anything. return false; } Intent intent = getHomeIntent(); ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) { intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) { intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); mStackSupervisor.startHomeActivity(intent, aInfo, reason); } } return true; } 首先是调用getHomeIntent()方法，看一下getHomeIntent是如何实现构造Intent对象的： 12345678Intent getHomeIntent() { Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) { intent.addCategory(Intent.CATEGORY_HOME); } return intent; } 可以发现，启动Launcher的Intent对象中添加了Intent.CATEGORY_HOME常量，这个其实是一个launcher的标志，一般系统的启动页面Activity都会在androidmanifest.xml中配置这个标志。比如我们在github中的android launcher源码中查看其androidmanifest.xml文件：可以发现其Activity的定义intentfilter中就是定义了这样的category。不同的手机厂商可能会修改Launcher的源码，但是这个category一般是不会更改的。 继续回到我们的startHomeActivityLocked方法，我们发现经过一系列的判断逻辑之后最后调用了mStackSupervisor.startHomeActivity方法，然后我们可以查看一下该方法的具体实现逻辑： 12345678910111213141516void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason) { moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); startActivityLocked(null /* caller */, intent, null /* resolvedType */, aInfo, null /* voiceSession */, null /* voiceInteractor */, null /* resultTo */, null /* resultWho */, 0 /* requestCode */, 0 /* callingPid */, 0 /* callingUid */, null /* callingPackage */, 0 /* realCallingPid */, 0 /* realCallingUid */, 0 /* startFlags */, null /* options */, false /* ignoreTargetSecurity */, false /* componentSpecified */, null /* outActivity */, null /* container */, null /* inTask */); if (inResumeTopActivity) { // If we are in resume section already, home activity will be initialized, but not // resumed (to avoid recursive resume) and will stay that way until something pokes it // again. We need to schedule another resume. scheduleResumeTopActivities(); } } 发现其调用的是scheduleResumeTopActivities()方法，这个方法其实是关于Activity的启动流程的逻辑了，这里我们不在详细的说明，关于Activity的启动流程我们在下面的文章中会介绍。 因为我们的Launcher启动的Intent是一个隐士的Intent，所以我们会启动在androidmanifest.xml中配置了相同catogory的activity，android M中配置的这个catogory就是LauncherActivity。 LauncherActivity继承与ListActivity，我们看一下其Layout布局文件： 12345678910111213141516171819202122&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@android:id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;TextView android:id=&quot;@android:id/empty&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/activity_list_empty&quot; android:visibility=&quot;gone&quot; android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; /&gt;&lt;/FrameLayout&gt; 可以看到我们现实的桌面其实就是一个ListView控件，然后看一下其onCreate方法： 12345678910111213141516171819202122232425262728@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPackageManager = getPackageManager(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS); setProgressBarIndeterminateVisibility(true); } onSetContentView(); mIconResizer = new IconResizer(); mIntent = new Intent(getTargetIntent()); mIntent.setComponent(null); mAdapter = new ActivityAdapter(mIconResizer); setListAdapter(mAdapter); getListView().setTextFilterEnabled(true); updateAlertTitle(); updateButtonText(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { setProgressBarIndeterminateVisibility(false); } } 可以看到在LauncherActivity的onCreate方法中初始化了一个PackageManager，其主要作用就是从中查询出系统所有已经安装的应用列表，应用包名，应用图标等信息。然后将这些信息注入到Adapter中，这样就可以将系统应用图标和名称显示出来了。在系统的回调方法onListItemClick中 12345@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); } 这也就是为什么我们点击了某一个应用图标之后可以启动某一项应用的原因了，我们看一下这里的intentForPosition是如何实现的。 1234protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); } 这里又调用了adapter的intentForPosition方法： 12345678910111213public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以看到由于adapter的每一项中都保存了应用的包名可启动Activity名称，所以这里在初始化Intent的时候，直接将这些信息注入到Intent中，然后调用startActivity，就将这些应用启动了（关于startActivity是如何启动的下面的文章中我将介绍）。 总结： Launcher的启动流程 Zygote进程 –&gt; SystemServer进程 –&gt; startOtherService方法 –&gt; ActivityManagerService的systemReady方法 –&gt; startHomeActivityLocked方法 –&gt; ActivityStackSupervisor的startHomeActivity方法 –&gt; 执行Activity的启动逻辑，执行scheduleResumeTopActivities()方法。。。。 因为是隐士的启动Activity，所以启动的Activity就是在AndroidManifest.xml中配置catogery的值为： 1public static final String CATEGORY_HOME = &quot;android.intent.category.HOME&quot;; 可以发现android M中在androidManifest.xml中配置了这个catogory的activity是LauncherActivity，所以我们就可以将这个Launcher启动起来了 LauncherActivity中是以ListView来显示我们的应用图标列表的，并且为每个Item保存了应用的包名和启动Activity类名，这样点击某一项应用图标的时候就可以根据应用包名和启动Activity名称启动我们的App了。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程","link":"/2022/08/06/Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"MAC OS Big Sur新系统下 Android Studio 打开新窗口卡(bug)","text":"MAC OS Big Sur新系统下 Android Studio 打开新窗口卡(bug) 第一步 退出android studio第二步 打开终端,敲入上面的代码 defaults write com.google.android.studio AppleWindowTabbingMode manual第三步 再打开android studio 原文地址https://www.reddit.com/r/androiddev/comments/jtbl4m/has_anyone_updated_to_macos_big_sur_and_is/","link":"/2022/08/06/MAC%20OS%20Big%20Sur%E6%96%B0%E7%B3%BB%E7%BB%9F%E4%B8%8B%20Android%20Studio%20%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%E5%8D%A1(bug)/"},{"title":"MAC系统Charles破解版","text":"1，环境： mac ---10.12.6 charles---4.2最新的版本都可以 2，安装： 官方地址：https://www.charlesproxy.com 3，破解： 可以参考CSDN博客上面的破解教程，比如修改charles.jar文件或者替换掉原来的软件。 我的方法是—注册码！！！ 按照常规安装好charles软件之后，打开软件，点击工具栏中的help –&gt; register 输入如下信息： Registered Name: https://zhile.ioLicense Key: 48891cf209c6d32bf4","link":"/2022/08/06/MAC%E7%B3%BB%E7%BB%9FCharles%E7%A0%B4%E8%A7%A3%E7%89%88/"},{"title":"","text":"title: Mac下移动硬盘的读写软件Mountythumbnail: /gallery/thumbnails/sculpture.jpgcategories: 应用软件tags: 壁纸路径 Mounty Mac系统 终端运行: brew cask install mounty 官网地址:https://mounty.app/","link":"/2022/08/04/Mac%20%E4%B8%8B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E8%BD%AF%E4%BB%B6Mounty/"},{"title":"MacOS快捷键说明","text":"您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。 要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常对某些按键使用符号，其中包括以下修饰键： Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪ Fn 在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的应用中切换到下一个最近使用的应用。 Shift-Command-5：在 macOS Mojave 中，拍摄屏幕快照或录制屏幕。在更早的 macOS 版本中，请使用 Shift-Command-3 或 Shift-Command-4 来拍摄屏幕快照。进一步了解屏幕快照。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的应用的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样可以避免您无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮*或 Control–Media Eject（Control–介质推出键）：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–Power 电源按钮：*强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option-Command–电源按钮*或 Control–Option–Command–Media Eject（Control–Option–Command–介质推出键）：退出所有应用，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 * 不适用于触控 ID 传感器。 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以封面流方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–“调度中心”：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的应用而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。 其他快捷键如需了解更多快捷键，请查看应用菜单中显示的快捷键缩写。每个应用都有自己的快捷键，在一个应用中可用的快捷键可能在另一个应用中不可用。 辅助功能快捷键 Safari 浏览器快捷键 聚焦快捷键 启动快捷键 iTunes 快捷键：从 iTunes 菜单栏中选取“帮助”&gt;“键盘快捷键”。 其他快捷键：选取苹果菜单 &gt;“系统偏好设置”，点按“键盘”，然后点按“快捷键”。","link":"/2022/08/04/MacOS%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"},{"title":"Mac系统壁纸路径","text":"在 Finder 中，菜单栏选取“前往”&gt;“前往文件夹”，弹出的框里输入/Library/Desktop Pictures/或/System/Library/Desktop Pictures/然后回车即可打开该文件夹。 系统壁纸默认路径存在两个地方，当时去了第一个路径上找未找到，后来通过命令行获取到路径发现System 下也有一个Desktop Pictures 文件夹。 终端命令：显示壁纸所在路径（路径显示在屏幕对应壁纸上）： defaults write com.apple.dock desktop-picture-show-debug-text -bool TRUE;killall Dock 终端命令：隐藏该路径： defaults delete com.apple.dock desktop-picture-show-debug-text;killall Dock","link":"/2022/08/04/Mac%20%E7%B3%BB%E7%BB%9F%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"title":"Mac下Google备份和同步问题","text":"1.下载并安装Google备份和同步 Google备份和同步（下载地址） 2.打开xx的http代理 在偏好设置中打开http代理服务器，配置默认即可 3.打开系统设置中的http代理 系统偏好设置→网络→高级→代理→网页代理(HTTP)，设置代理127.0.0.1:1087 4. 允许并登录Google账户 完全配置完成后即可食用 原文地址 https://www.fangpengjun.com/2017/09/08/%E8%A7%A3%E5%86%B3Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","link":"/2022/08/04/Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"},{"title":"Mac下安装软件提示文件损坏解决办法","text":"1.打开应用程序-实用工具-终端；b2制以下代码（master注意是两个-）到终端中，回车（输入电脑密码）： 1sudo spctl --master-disable 3.打开应用程序-系统偏好设置-安全性和隐私-通用，消失的任何来源终于出现了（默认应该勾选了）；4.此时可以尽情使用第三方程序了如已经开启了任何来源，还无法安装当出现提示的时候，去系统偏好设置-安全和隐私那里允许下（会提示该软件的安装信息） 还提示损坏的，试试按住Control后，再次点击软件图标","link":"/2022/08/04/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Mac使用终端登录谷歌云","text":"1.网页SSH进入谷歌云，切换到root角色 sudo -i 2.修改SSH配置文件/etc/ssh/sshd_config vi /etc/ssh/sshd_config 修改PermitRootLogin和PasswordAuthentication为yes # Authentication: PermitRootLogin yes //默认为no，需要开启root用户访问改为yes # Change to no to disable tunnelled clear text passwords PasswordAuthentication yes //默认为no，改为yes开启密码登陆 3.给root用户设置密码 passwd root 4.重启SSH服务使修改生效 /etc/init.d/ssh restart 5.启动mac终端 ssh root@ip 输入密码即可进入SSH。","link":"/2022/08/04/Mac%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"title":"Mac安装oh-my-zsh出现TimeOut","text":"mac终端 安装 oh-my-zshsh -c “$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 提示错误 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out 用这个连接wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh","link":"/2022/08/04/Mac%E5%AE%89%E8%A3%85oh-my-zsh%20%E5%87%BA%E7%8E%B0TimeOut/"},{"title":"Mac文件安装应用，打开提示文件已损坏，如何解决","text":"终端运行该命令:sudo xattr -d com.apple.quarantine /Applications/ColorFinale.app","link":"/2022/08/04/Mac%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8%EF%BC%8C%E6%89%93%E5%BC%80%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"},{"title":"PopupWindow加载绘制流程","text":"在前面的几篇文章中我们分析了Activity与Dialog的加载绘制流程，取消绘制流程，相信大家对Android系统的窗口绘制机制有了一个感性的认识了，这篇文章我们将继续分析一下PopupWindow加载绘制流程。 在分析PopupWindow之前，我们将首先说一下什么是PopupWindow？理解一个类最好的方式就是看一下这个类的定义，这里我们摘要了一下Android系统中PopupWindow的类的说明： A popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity. 一个PopupWindow能够被用于展示任意的View，PopupWindow是一个悬浮的容易展示在当前Activity的上面。简单来说PopupWindow就是一个悬浮在Activity之上的窗口，可以用展示任意布局文件。 在说明PopupWindow的加载绘制机制之前，我们还是先写一个简单的例子用于说明一下PopupWindow的简单用法。 1234567891011121314151617181920212223public static View showPopupWindowMenu(Activity mContext, View anchorView, int layoutId) { LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View view = inflater.inflate(layoutId, null); popupWindow = new PopupWindow(view, DisplayUtil.dip2px(mContext, 148), WindowManager.LayoutParams.WRAP_CONTENT); popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_bg)); popupWindow.setFocusable(true); popupWindow.setOutsideTouchable(true); int[] location = new int[2]; anchorView.getLocationOnScreen(location); popupWindow.setAnimationStyle(R.style.popwin_anim_style); popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY, location[0] - popupWindow.getWidth() + anchorView.getWidth() - DisplayUtil.dip2px(mContext, 12), location[1] + anchorView.getHeight() - DisplayUtil.dip2px(mContext, 10)); popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() { @Override public void onDismiss() { popupWindow = null; } }); return view; } 可以看到我们首先通过LayoutInflater对象将布局文件解析到内存中View对象，然后创建了一个PopupWindow对象，可以看到传递了三个参数，一个是View对象，一个是PopupWindow的宽度和高度。 这里就是PopupWindow的初始化流程的开始了，好吧，我们来看一下PopupWindow的构造方法的实现： 123public PopupWindow(View contentView, int width, int height) { this(contentView, width, height, false); } 可以看到这里调用了PopupWindow的重载构造方法，好吧，继续看一下这个重载构造方法的实现逻辑： 1234567891011public PopupWindow(View contentView, int width, int height, boolean focusable) { if (contentView != null) { mContext = contentView.getContext(); mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } setContentView(contentView); setWidth(width); setHeight(height); setFocusable(focusable); } 这里首先根据传入的View是否为空做了一下判断，若不为空，则初始化成员变量,Context和mWindowManager，可以发现这里的mContext对象就是传入的View组件中保留的Context对象，这里的mWindowManager是应用进程创建的时候注册的服务本地接口。然后调用了setContentView方法，这里就是为PopupWindow的contentView赋值。然后后面调用的setWidth、setHeight、setFocusable方法都是为PopupWindow的成员变量，width，height，focusable等赋值，这样PopupWindow的构造方法就执行完成了。 我们继续回到我们的例子代码中，在后续的代码中我们调用了：popupWindow.setBackgroundDrawable、popupWindow.setFocusable、PopupWindow.setOutsideTouchable、PopupWindow.setAnimationStyle等方法，初始化了PopupWindow中的相关成员变量，最后我们调用了popupWindow.showAtLocation方法用于展示PopupWindow，这里我们具体看一下showAtLocation的实现逻辑： 123public void showAtLocation(View parent, int gravity, int x, int y) { showAtLocation(parent.getWindowToken(), gravity, x, y); } 可以发现，这里调用了showAtLocation的重载函数，这样我们继续看一下这个重载函数的实现方式： 12345678910111213141516171819202122232425public void showAtLocation(IBinder token, int gravity, int x, int y) { if (isShowing() || mContentView == null) { return; } TransitionManager.endTransitions(mDecorView); unregisterForScrollChanged(); mIsShowing = true; mIsDropdown = false; final WindowManager.LayoutParams p = createPopupLayoutParams(token); preparePopup(p); // Only override the default if some gravity was specified. if (gravity != Gravity.NO_GRAVITY) { p.gravity = gravity; } p.x = x; p.y = y; invokePopup(p); } 可以看到通过调用createPopupLayoutParams方法创造了WindowManager.LayoutParams对象，然后又调用了preparePopup方法，可以看一下preparePopup方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637private void preparePopup(WindowManager.LayoutParams p) { if (mContentView == null || mContext == null || mWindowManager == null) { throw new IllegalStateException(&quot;You must specify a valid content view by &quot; + &quot;calling setContentView() before attempting to show the popup.&quot;); } // The old decor view may be transitioning out. Make sure it finishes // and cleans up before we try to create another one. if (mDecorView != null) { mDecorView.cancelTransitions(); } // When a background is available, we embed the content view within // another view that owns the background drawable. if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } mDecorView = createDecorView(mBackgroundView); // The background owner should be elevated so that it casts a shadow. mBackgroundView.setElevation(mElevation); // We may wrap that in another view, so we'll need to manually specify // the surface insets. final int surfaceInset = (int) Math.ceil(mBackgroundView.getZ() * 2); p.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset); p.hasManualSurfaceInsets = true; mPopupViewInitialLayoutDirectionInherited = (mContentView.getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT); mPopupWidth = p.width; mPopupHeight = p.height; } preparePopup方法的参数是WindowManager.LayoutParams，然后设置了PopupWindow中的几个比较重要的成员变量，首先看一下mBackgroundView的初始化过程： 123456if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } 可以发现如果我们设置了mBackground变量也就是我们在初始化的时候执行了popupWindow的setBackgound方法，那么我们这里执行的就是if分之，这里看一下createBackgourndView的具体执行逻辑： 12345678910111213141516private PopupBackgroundView createBackgroundView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupBackgroundView backgroundView = new PopupBackgroundView(mContext); final PopupBackgroundView.LayoutParams listParams = new PopupBackgroundView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, height); backgroundView.addView(contentView, listParams); return backgroundView; } 可以看到，createBackgroundView的执行逻辑就是在参数contentView的外面一层包裹一层PopupBackgroundView，而这里的PopupBackgroundView值我们自定义的FrameLayout的子类，重写了其onCreateDrawableState方法。 继续回到我们的preparePopup方法，这里我们又调用了createDecorView方法初始化mDectorView变量，我们可以看一下createDecorView的具体实现： 12345678910111213141516private PopupDecorView createDecorView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupDecorView decorView = new PopupDecorView(mContext); decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height); decorView.setClipChildren(false); decorView.setClipToPadding(false); return decorView; } 可以发现这里也是给参数contentView外面包裹了一层PopupDecorView，这里的PopupDecorView也是我们自定义的FrameLayout的子类，PopupDecorView的源码比较多，这里就不都贴出来了，这里具体看一下其onTouchEvent方法的实现： 12345678910111213141516@Override public boolean onTouchEvent(MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); if ((event.getAction() == MotionEvent.ACTION_DOWN) &amp;&amp; ((x &lt; 0) || (x &gt;= getWidth()) || (y &lt; 0) || (y &gt;= getHeight()))) { dismiss(); return true; } else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) { dismiss(); return true; } else { return super.onTouchEvent(event); } } 可以发现其重写了onTouchEvent时间，这样我们在点击popupWindow外面的时候就会执行pupopWindow的dismiss方法，取消PopupWindow。 好吧，继续回到我们的showAsDropDown方法，在执行完成preparePopup方法之后又调用了invokePopup方法，这里的方法应该就是具体执行PopupWindow的加载与显示逻辑了。这里我们具体看一下其实现逻辑： 12345678910111213141516private void invokePopup(WindowManager.LayoutParams p) { if (mContext != null) { p.packageName = mContext.getPackageName(); } final PopupDecorView decorView = mDecorView; decorView.setFitsSystemWindows(mLayoutInsetDecor); setLayoutDirectionFromAnchor(); mWindowManager.addView(decorView, p); if (mEnterTransition != null) { decorView.requestEnterTransition(mEnterTransition); } } 我们看到这里我们调用了mWindowManager.addView方法，看过我们前面几篇关于Dialog和Activity的加载与现实流程的同学应该知道这里的addView其实是我们布局绘制的流程，这里的mWindowManager是我们在调用PopupWIndow的构造函数的时候初始化的，其调用的是： 123if (mWindowManager == null &amp;&amp; mContentView != null) { mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } 而这里的mContext.getSystemService是一个接口其具体的实现是在ContextImpl中实现的，所以这里我们看一下ContextImpl的getSystemService的实现： 1234@Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } 好吧，在ContextImpl中的getSystemService方法又调用了SystemServiceRegister中的静态方法getSystemService，这样我们再看看一下在SystemServiceRegister是如何实现的。 1234public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } 这里发现服务对象的获取就是通过一个SYSTEM_SERVICE_FETCHERS的map数据结构获取的，那么这个map对象的数据是何时填充的呢？通过查看源码我们发下在SystemServiceRegister中有一段静态代码主要用于注册本地服务接口，其中关于windowManagerService本地服务的代码如下： 123456registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() { @Override public WindowManager createService(ContextImpl ctx) { return new WindowManagerImpl(ctx.getDisplay()); }}); 好吧，原来我们通过mContext.getSystemService获取的WindowManager其实际上是一个WindowManagerImpl对象，而我们调用的addView就是WindowManagerImpl的addView方法。 这样就回到了我们前几篇讲解的内容上了，通过调用WindowManagerImpl实现了布局文件的绘制流程。。。。 好了，经过上面的一系列的操作我们分析完了PopupWindow的加载绘制流程，其和Dialog，Activity的加载绘制流程类似，都是通过Window对象控制布局文件的加载与绘制流程。 总结： PopupWindow的界面加载绘制流程也是通过Window对象实现的； PopupWindow内部保存的mWindowManager对象通过ContextImpl中获取，并且取得的是WindowManagerImpl对象； PopupWindow通过为传入的View添加一层包裹的布局，并重写该布局的点击事件，实现点击PopupWindow之外的区域PopupWindow消失的效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程","link":"/2022/08/06/PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"Android 项目中so文件丢失","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码 123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 1234567891011121314151617defaultConfig { applicationId &quot;...&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2022/08/04/SO%E6%96%87%E4%BB%B6%E7%BC%BA%E5%A4%B1/"},{"title":"SSH通用命令","text":"Quick Start查看当前ss服务器所开放的端口1$ ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件1$ ps aux | grep ssserver 用cat查看下配置文件1$ cat /etc/shadowsocks.json 修改ss密码1$ vi /etc/shadowsocks.json 按i键进入编辑模式，修改密码为123456“password”:”123456”, 重启ss即可1$ service shadowsocks restart 启动：service shadowsocks start停止：service shadowsocks stop重启：service shadowsocks restart状态：service shadowsocks status","link":"/2022/08/04/SSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"JNI 串口通讯库 SerialPort开发封装","text":"SerialportManagerJNI 串口通讯库 SerialPort开发封装前言 最近工作比较清闲，闲来无事，把原先项目用到的串口通讯项目所涉及到的知识及项目简化出来一个库，方便以后开发新项目。同时希望 对其他小伙伴有所帮助。项目涉及到 ndk工程构建及硬件串口通讯。期间涉及到硬件屏幕功能开发这里不做多介绍。 下面从NDK项目构建开始说起。 NDK是Google为便于Android开发提供的一种原生开发集：Native Development Kit，而且也是一个包含API、构建工具、交叉编译、调 试器、文档示例等一系列的工具集，可以帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成APK。 与NDK密切相关的另一个词汇则是JNI，它是NDK开发中的枢纽，Java与底层交互绝大多数都是通过它来完成的，那么接下来看看什么是 JNI? JNI：Java Native Interface 也就是java本地接口，它是一个协议，这个协议用来沟通java代码和本地代码(c/c++)。通过这个 协议，Java类的某些方法可以使用原生实现，同时让它们可以像普通的Java方法一样被调用和使用，而原生方法也可以使用Java对象， 调用和使用Java方法。也就是说，使用JNI这种协议可以实现：java代码调用c/c++代码，而c/c++代码也可以调用java代码。 那为什么要使用NDK开发呢？ 我们都知道，java是半解释型语言，很容易被反汇编后拿到源代码文件，在开发一些重要协议时，我们为了安全起见，使用C语言来编写 这些重要的部分，来增大系统的安全性。 在一些复杂性的计算中，要求高性能的场景中，C/C++更加的有效率，代码也更便于复用。 当然还有其他的优点，这些都驱使我们选择相对来说高效和安全的DNK来开发我们的应用程序。 NDK环境搭建1.下载NDK 首先下载NDK，可以从AndroidStudio中的SDK Manager中下载，也可自己单独下载 点击按钮进入 或者进入http://www.androiddevtools.cn/ 下载 Windows 64-bit Mac OS X 如单独下载 1). 解压NDK的zip包，注意路径目录不要出现空格和中文，这里建议大家把包解压到SDK目录里面，并命名为ndk-bundle，好处是，启动AS的时候会检查它并直接添加到ndk.dir中，减少我们的配置工作； 2). 配置path : 把解压好的路径添加到环境变量path中； 3). ndk-build：cd到解压后NDK的根目录，执行ndk-build命令。 2.安装配置NDK AndroidStudio 点击File -&gt; Other Settings -&gt; Default Project Strjucture 如图 到这里NDK配置完成，接下来 开始 NDK 开发。 NDK项目开发 在library 中的 build.gradle 文件中的 defaultConfig 中 配置 ndk { moduleName &quot;serial_port&quot; // 设置支持的SO库架构 abiFilters 'armeabi', 'x86', 'armeabi-v7a', 'x86_64', 'arm64-v8a' } 在android 中配置 sourceSets { main { jni.srcDirs = ['src/main/jni', 'src/main/jni/'] } } externalNativeBuild { ndkBuild { path 'src/main/jni/Android.mk' } } 如图 Android.mk 文件中配置如下内容 Android.mk用法详解 # # Copyright 2009 Cedric Priscal # # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an &quot;AS IS&quot; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) TARGET_PLATFORM := android-3 LOCAL_MODULE := serial_port //项目名称 LOCAL_SRC_FILES := SerialPort.c //底层c LOCAL_LDLIBS := -llog include $(BUILD_SHARED_LIBRARY) 在main目录下创建一个jni文件目录，并将 Android.mk 文件放到jni文件下 直接使用网上 SerialPort.java 类，里边封装底层方法 package com.serialport.library.core; import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; /** * Created by Jian on 2017/8/7. * 用来加载SO文件，通过JNI的方式打开关闭串口 */ public class SerialPort { private static final String TAG = &quot;SerialPort&quot;; /* * Do not remove or rename the field mFd: it is used by native method close(); */ private FileDescriptor mFd; private FileInputStream mFileInputStream; private FileOutputStream mFileOutputStream; public SerialPort(File device, int baudrate, int flags) throws SecurityException, IOException { /* Check access permission */ if (!device.canRead() || !device.canWrite()) { try { /* Missing read/write permission, trying to chmod the file */ Process su; su = Runtime.getRuntime().exec(&quot;/system/bin/su&quot;); String cmd = &quot;chmod 666 &quot; + device.getAbsolutePath() + &quot;\\n&quot; + &quot;exit\\n&quot;; su.getOutputStream().write(cmd.getBytes()); if ((su.waitFor() != 0) || !device.canRead() || !device.canWrite()) { throw new SecurityException(); } } catch (Exception e) { e.printStackTrace(); throw new SecurityException(); } } mFd = open(device.getAbsolutePath(), baudrate, flags); if (mFd == null) { throw new IOException(); } mFileInputStream = new FileInputStream(mFd); mFileOutputStream = new FileOutputStream(mFd); } // Getters and setters public InputStream getInputStream() { return mFileInputStream; } public OutputStream getOutputStream() { return new FileOutputStream(mFd); } // JNI private native static FileDescriptor open(String path, int baudrate, int flags); public native void close(); static { System.loadLibrary(&quot;serial_port&quot;); } } 点击”View-&gt;Tool Windows-&gt;Terminal”，即在Studio中进行终端命令行工具.执行如下命令生成c语言头文件: cd 到目录java/ 下执行 javah -o SerialPort.h -jni com.serialport.library.core.SerialPort javah -o SerialPort.h -jni com.serialport.library.core.SerialPort com.serialport.library.core 为包名。 SerialPort.h 文件如下 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_serialport_library_core_SerialPort */ #ifndef _Included_com_serialport_library_core_SerialPort #define _Included_com_serialport_library_core_SerialPort #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *, jclass, jstring, jint, jint); /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 并把 SerialPort.h 头文件转移到jni文件夹下 创建实现头文件的.C源文件，将 com_serialport_library_core 为SerialPort.java 文件位置，将该 path 替换成其他 项目包名 符号.换成_ /* * Copyright 2009-2011 Cedric Priscal * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;jni.h&gt; #include &quot;SerialPort.h&quot; #include &quot;android/log.h&quot; static const char *TAG = &quot;serial_port&quot;; #define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, TAG, fmt, ##args) #define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, TAG, fmt, ##args) #define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, TAG, fmt, ##args) static speed_t getBaudrate(jint baudrate) { switch (baudrate) { case 0: return B0; ... default: return -1; } } /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags) { int fd; speed_t speed; jobject mFileDescriptor; /* Check arguments */ { speed = getBaudrate(baudrate); if (speed == -1) { /* TODO: throw an exception */ LOGE(&quot;Invalid baudrate&quot;); return NULL; } } /* Opening device */ { jboolean iscopy; const char *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy); LOGD(&quot;Opening serial port %s with flags 0x%x&quot;, path_utf, O_RDWR | flags); fd = open(path_utf, O_RDWR | flags); LOGD(&quot;open() fd = %d&quot;, fd); (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf); if (fd == -1) { /* Throw an exception */ LOGE(&quot;Cannot open port&quot;); /* TODO: throw an exception */ return NULL; } } /* Configure device */ { struct termios cfg; LOGD(&quot;Configuring serial port&quot;); if (tcgetattr(fd, &amp;cfg)) { LOGE(&quot;tcgetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } cfmakeraw(&amp;cfg); cfsetispeed(&amp;cfg, speed); cfsetospeed(&amp;cfg, speed); if (tcsetattr(fd, TCSANOW, &amp;cfg)) { LOGE(&quot;tcsetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } } /* Create a corresponding file descriptor */ { jclass cFileDescriptor = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, &quot;descriptor&quot;, &quot;I&quot;); mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor); (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd); } return mFileDescriptor; } /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *env, jobject thiz) { jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz); jclass FileDescriptorClass = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, &quot;mFd&quot;, &quot;Ljava/io/FileDescriptor;&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, &quot;descriptor&quot;, &quot;I&quot;); jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID); jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID); LOGD(&quot;close(fd = %d)&quot;, descriptor); close(descriptor); } 到此 NDK 项目搭建完成。接下来 介绍一下 SerialPortManager 类库 下图为类库的介绍 SerialPort.java 封装底层开关串口方法 SerialPortFinder.java 获取所有串口方法 OnS3DataReceiverListener.java 和 OnS6DataReceiverListener.java 是串口响应数据监听。当接收到串口数据会调 接口方法，我们的硬件设备S3口监听主板数据，S6口监听硬件屏幕数据。 BaseProtocol.java 提供指令封装方法。根据各个设备硬件串口协议，继承、封装。 SerialportManager.java 串口管理对象 SerialportManager.java 串口管理对象，该对象为单例。底层对 SerialPort 进行封装、管理。 private SerialPort mSerialPort; mSerialPort = new SerialPort(new File(path), baudrate, 0);//根据串口名，波特率 生成串口管理对象 mOutputStream = mSerialPort.getOutputStream(); //获取串口的输出流 mInputStream = mSerialPort.getInputStream(); //获取串口的输入流 开启一个新线程循环读取串口信息 if (mReadThread == null) { mReadThread = new ReadThread(); mReadThread.start(); } 线程方法中通过输入流获取串口数据 返回数据为byte数组，当获取到数据回调 onS3DataReceiverListener 接口方法 private class ReadThread extends Thread { @Override public void run() { super.run(); while (!isStop &amp;&amp; !isInterrupted()) { int size; try { if (mInputStream == null) { return; } byte[] buffer = new byte[64]; size = mInputStream.read(buffer); if (size &gt; 0) { if (null != onS3DataReceiverListener) { onS3DataReceiverListener.onS3DataReceive(buffer, size); } } Thread.sleep(10); } catch (Exception e) { Log.i(&quot;readthread&quot;, &quot;throw exception !&quot; + e.toString()); e.printStackTrace(); return; } } } } 下面介绍一下如何使用类库，我们项目串口用的是S3、S6口，如果想用其他串口 请修改SerialportManager中的path/screenpath 如果baudrate也想改也修改对应的数值即可。 SerialportManager.getInstance().setOnS3DataReceiverListener(this);//设置主板串口回调 SerialportManager.getInstance().setOnS6DataReceiverListener(this);//设置屏幕串口回调 SerialportManager.getInstance().InitThread();//初始化对应 读写线程 //因有不同主板类型，屏幕类型。这里对其做了一次封装 SenderManager.getInstance().getSender().sendStartDetect(); 设备开机会轮训配置串口，根据主板类型屏幕类型，生成对应管理对象。然后进行串口数据通讯。当我们串口读到我们的输入数据，会 想onS3DataReceiverListener.onS3DataReceive 回调返回数据。再界面我们拿到数据坐相应操作 @Override public void onS3DataReceive(byte[] buffer, int size) { byte[] mBufferTemp = new byte[size]; System.arraycopy(buffer, 0, mBufferTemp, 0, size); int length = mBufferTemp.length - 1; String tempdata = TypeConversion.bytes2HexString(mBufferTemp); Log.i(&quot;serialport&quot;,tempdata); } 当界面跳转时要及时将OnS3DataReceiverListener、OnS6DataReceiverListener监听remove掉，避免造成内存泄漏。 @Override protected void onPause() { super.onPause(); SerialportManager.getInstance().removeOnS3DataReceiverListener(); SerialportManager.getInstance().removeOnS6DataReceiverListener(); }","link":"/2022/08/04/SerialportManager/"},{"title":"SystemServer进程启动流程(转)","text":"转载请标明出处：一片枫叶的专栏 上面一文中我们讲过android系统中比较重要的几个进程：init进程，Zygote进程，SystemServer进程已经各种应用进程，其中Zygote进程是整个android系统的根进程，包含SystemServer进程已经各种应用进程在内的进程都是通过Zygote进程fork出来的，具体可参见： android源码解析之（八）–&gt;Zygote进程启动流程那么SystemServer进程是做什么用的呢？ 其实SystemServer进程主要的作用是在这个进程中启动各种系统服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务，以及各种系统性的服务其实都是在SystemServer进程中启动的，而当我们的应用需要使用各种系统服务的时候其实也是通过与SystemServer进程通讯获取各种服务对象的句柄的。 由上一篇文章我们知道SystemServer进程其实也是有Zygote进程fork出来的，并且执行其main方法，那么这里我们以android23的源码为例，看一下SystemServer的main方法的执行逻辑： 123456/** * The main entry point from zygote. */ public static void main(String[] args) { new SystemServer().run(); } 这里比较简单，只是new出一个SystemServer对象并执行其run方法，查看SystemServer类的定义我们知道其实final类型的，所以我们一般不能重写或者继承。 然后我们查看run方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110private void run() { // If a device's clock is before 1970 (before 0), a lot of // APIs crash dealing with negative numbers, notably // java.io.File#setLastModified, so instead we fake it and // hope that time from cell towers or NTP fixes it shortly. if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } // If the system has &quot;persist.sys.language&quot; and friends set, replace them with // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by // AndroidRuntime using the same set of system properties, but only the system_server // and system apps are allowed to set them. // // NOTE: Most changes made here will need an equivalent change to // core/jni/AndroidRuntime.cpp if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } // Here we go! Slog.i(TAG, &quot;Entered the Android system server!&quot;); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis()); // In case the runtime switched since last boot (such as when // the old runtime was removed in an OTA), set the system // property so that it is in sync. We can't do this in // libnativehelper's JniInvocation::Init code where we already // had to fallback to a different runtime because it is // running as root and we need to be the system user to set // the property. http://b/11463182 SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary()); // Enable the sampling profiler. if (SamplingProfilerIntegration.isEnabled()) { SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() { @Override public void run() { SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null); } }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); } // Mmmmmm... more memory! VMRuntime.getRuntime().clearGrowthLimit(); // The system server has to run all of the time, so it needs to be // as efficient as possible with its memory usage. VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); // Within the system server, it is an error to access Environment paths without // explicitly specifying a user. Environment.setUserRequired(true); // Ensure binder calls into the system always run at foreground priority. BinderInternal.disableBackgroundScheduling(true); // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper(); // Initialize native services. System.loadLibrary(&quot;android_servers&quot;); // Check whether we failed to shut down last time we tried. // This call may not return. performPendingShutdown(); // Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) { Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;); } // Loop forever. Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 好吧，代码比较多，慢慢看。。。 1234if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } 首先判断系统当前时间，若当前时间小于1970年1月1日，则一些初始化操作可能会处所，所以当系统的当前时间小于1970年1月1日的时候，设置系统当前时间为该时间点。 然后代码： 12345678if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } 主要是设置系统的语言环境等；下面的主要是设置虚拟机运行内存，加载运行库，设置SystemServer的异步消息，具体的异步消息机制可参见： android源码解析之（二）–&gt;异步消息机制 然后下面的代码是： 1234567891011121314151617// Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 首先调用createSystemContext()方法： 12345private void createSystemContext() { ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); } 可以看到在SystemServer进程中也存在着Context对象，并且是通过ActivityThread.systemMain方法创建context的，这一部分的逻辑以后会通过介绍Activity的启动流程来介绍，这里就不在扩展，只知道在SystemServer进程中也需要创建Context对象。 然后通过SystemServiceManager的构造方法创建了一个新的SystemServiceManager对象，我们知道SystemServer进程主要是用来构建系统各种service服务的，而SystemServiceManager就是这些服务的管理对象。 然后调用： 1LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); 是将SystemServiceManager对象保存SystemServer进程中的一个数据结构中。 最后开始执行： 12345678910// Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 里面主要涉及了是三个方法：startBootstrapServices() 主要用于启动系统Boot级服务startCoreServices() 主要用于启动系统核心的服务startOtherServices() 主要用于启动一些非紧要或者是非需要及时启动的服务 下面我们重点介绍这三个启动服务的方法，包括启动那些系统服务已经如何启动系统服务等。 首先看一下startBootstrapServices方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void startBootstrapServices() { // Wait for installd to finish starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions. We need this to complete before we initialize other services. Installer installer = mSystemServiceManager.startService(Installer.class); // Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); // Power manager needs to be started early because other services need it. // Native daemons may be watching for it to be registered so it must be ready // to handle incoming binder calls immediately (including being able to verify // the permissions for those calls). mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // Now that the power manager has been started, let the activity manager // initialize power management features. mActivityManagerService.initPowerManagement(); // Manages LEDs and display backlight so we need it to bring up the display. mSystemServiceManager.startService(LightsService.class); // Display manager is needed to provide display metrics before package manager // starts up. mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); // We need the default display before we can initialize the package manager. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); // Only run &quot;core&quot; apps if we're encrypting the device. String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); mOnlyCore = true; } else if (ENCRYPTED_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); mOnlyCore = true; } // Start the package manager. Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); Slog.i(TAG, &quot;User Service&quot;); ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); // Initialize attribute cache used to cache resources from packages. AttributeCache.init(mSystemContext); // Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); // The sensor service needs access to package manager service, app ops // service, and permissions service, therefore we start it after them. startSensorService(); } 首先执行： 1Installer installer = mSystemServiceManager.startService(Installer.class); mSystemServiceManager是系统服务管理对象，在main方法中已经创建完成，这里我们看一下其startService方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) { final String name = serviceClass.getName(); Slog.i(TAG, &quot;Starting &quot; + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) { throw new RuntimeException(&quot;Failed to create &quot; + name + &quot;: service must extend &quot; + SystemService.class.getName()); } final T service; try { Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); } catch (InstantiationException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service could not be instantiated&quot;, ex); } catch (IllegalAccessException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (NoSuchMethodException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (InvocationTargetException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service constructor threw an exception&quot;, ex); } // Register it. mServices.add(service); // Start it. try { service.onStart(); } catch (RuntimeException ex) { throw new RuntimeException(&quot;Failed to start service &quot; + name + &quot;: onStart threw an exception&quot;, ex); } return service; } 可以看到我们通过反射器构造方法创建出服务类，然后添加到SystemServiceManager的服务列表数据中，最后调用了service.onStart()方法，因为我们传递的是Installer.class，我们这里我们查看一下Installer的onStart方法： 12345@Override public void onStart() { Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;); mInstaller.waitForConnection(); } 很简单就是执行了mInstaller的waitForConnection方法，这里简单介绍一下Installer类，该类是系统安装apk时的一个服务类，继承SystemService（系统服务的一个抽象接口），我们需要在启动完成Installer服务之后才能启动其他的系统服务。然后查看waitForConnection（）方法： 123456789public void waitForConnection() { for (;;) { if (execute(&quot;ping&quot;) &gt;= 0) { return; } Slog.w(TAG, &quot;installd not ready&quot;); SystemClock.sleep(1000); } } 通过追踪代码可以发现，其在不断的通过ping命令连接Zygote进程（SystemServer和Zygote进程通过socket方式通讯，其他进程通过Binder方式通讯）； 总结：在开始执行启动服务之前总是会先尝试通过socket方式连接Zygote进程，在成功连接之后才会开始启动其他服务。 继续来看startBootstrapServices方法： 12345// Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); 这段代码主要是用于启动ActivityManagerService服务，并为其设置SysServiceManager和Installer。ActivityManagerService是系统中一个非常重要的服务，Activity，service，Broadcast，contentProvider都需要通过其余系统交互。 首先看一下Lifecycle类的定义： 1234567891011121314151617public static final class Lifecycle extends SystemService { private final ActivityManagerService mService; public Lifecycle(Context context) { super(context); mService = new ActivityManagerService(context); } @Override public void onStart() { mService.start(); } public ActivityManagerService getService() { return mService; } } 可以看到其实ActivityManagerService的一个静态内部类，在其构造方法中会创建一个ActivityManagerService，通过刚刚对Installer服务的分析我们知道，SystemServiceManager的startService方法会调用服务的onStart()方法，而在Lifecycle类的定义中我们看到其onStart（）方法直接调用了mService.start()方法，mService是Lifecycle类中对ActivityManagerService的引用，所以我们可以看一下ActivityManagerService的start方法的实现： 123456789private void start() { Process.removeAllProcessGroups(); mProcessCpuThread.start(); mBatteryStatsService.publish(mContext); mAppOpsService.publish(mContext); Slog.d(&quot;AppOps&quot;, &quot;AppOpsService published&quot;); LocalServices.addService(ActivityManagerInternal.class, new LocalService()); } 由于ActivityManagerService的创建过程比较复杂这里不做过多的分析了，主要是在其构造方法中初始化了一些变量。 然后是启动PowerManagerService服务： 1mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); 启动方式跟上面的ActivityManagerService服务相似都会调用其构造方法和onStart方法，PowerManagerService主要用于计算系统中和Power相关的计算，然后决策系统应该如何反应。同时协调Power如何与系统其它模块的交互，比如没有用户活动时，屏幕变暗等等。 然后是启动LightsService服务 1mSystemServiceManager.startService(LightsService.class); 主要是手机中关于闪光灯，LED等相关的服务；也是会调用LightsService的构造方法和onStart方法； 然后是启动DisplayManagerService服务 1mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); 主要是手机显示方面的服务； 然后是启动PackageManagerService，该服务也是android系统中一个比较重要的服务，包括多apk文件的安装，解析，删除，卸载等等操作。 12345Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); 可以看到PackageManagerService服务的启动方式与其他服务的启动方式有一些区别，直接调用了PackageManagerService的静态main方法，这里我们看一下其main方法的具体实现： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; } 可以看到也是直接使用new的方式创建了一个PackageManagerService对象，并在其构造方法中初始化相关变量，最后调用了ServiceManager.addService方法，主要是通过Binder机制与JNI层交互，这里不再扩展。 然后启动UserManagerService和SensorService，至此startBootstrapServices方法执行完成。 然后查看startCoreServices方法： 1234567891011121314private void startCoreServices() { // Tracks the battery level. Requires LightService. mSystemServiceManager.startService(BatteryService.class); // Tracks application usage stats. mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); // Update after UsageStatsService is available, needed before performBootDexOpt. mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); // Tracks whether the updatable WebView is in a ready state and watches for update installs. mSystemServiceManager.startService(WebViewUpdateService.class); } 可以看到这里启动了BatteryService（电池相关服务），UsageStatsService，WebViewUpdateService服务等。 最后看一下startOtherServices方法，主要用于启动系统中其他的服务，代码很多，这里就不贴代码了，启动的流程和ActivityManagerService的流程类似，会调用服务的构造方法与onStart方法初始化变量。 总结： SystemServer进程是android中一个很重要的进程由Zygote进程启动； SystemServer进程主要用于启动系统中的服务； SystemServer进程启动服务的启动函数为main函数； SystemServer在执行过程中首先会初始化一些系统变量，加载类库，创建Context对象，创建SystemServiceManager对象等之后才开始启动系统服务； SystemServer进程将系统服务分为三类：boot服务，core服务和other服务，并逐步启动 SertemServer进程在尝试启动服务之前会首先尝试与Zygote建立socket通讯，只有通讯成功之后才会开始尝试启动服务； 创建的系统服务过程中主要通过SystemServiceManager对象来管理，通过调用服务对象的构造方法和onStart方法初始化服务的相关变量； 服务对象都有自己的异步消息对象，并运行在单独的线程中； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程","link":"/2022/08/06/SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"","text":".安装Python 3.7.5 版本百度云盘:链接:https://pan.baidu.com/s/1lC7ZPFAIB8pYor1DbIOL8Q 密码:v6tj官网:https://www.python.org/ftp/python/3.7.5/python-3.7.5-macosx10.9.pkg 查看版本号。 123python3 --versionpip3 --versionvirtualenv --version 输入which python3 查看路径 2.如果已经安装，跳过这步：如果没用过brew，需要先下载，关于brew查看这里: https://brew.sh/ 123/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 1234/usr/bin/ruby -e &quot;PATH&quot;brew updatebrew install python # Python 3sudo pip3 install -U virtualenv # system-wide install 3.安装virtualenv虚拟环境创建一个新的虚拟环境通过选择一个Python解释器,创建./venv目录来保存它:可修改为其他目录。目录会出现在 user的子目录下。 1virtualenv --system-site-packages -p python3 ./venv 4.激活虚拟环境 1source ./venv/bin/activate # sh, bash, ksh, or zsh virtualenv活跃时,shell提示符前缀(venv)。 安装包在一个虚拟环境在不影响主机系统设置。先升级pip: 12pip install --upgrade pippip list # show packages installed within the virtual environment 5.退出虚拟环境 deactivate # don’t exit until you’re done using TensorFlow 如果提示权限不够时，需要在命令后添加 –user。 6.安装TensorFlow 1pip install --upgrade tensorflow 验证安装 1python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot; 问题汇总 1pip install Keras-Applications ModuleNotFoundError: No module named ‘matplotlib’ 1pip install matplotlib ModuleNotFoundError: No module named ‘tensorflow_datasets’ 1pip install tensorflow_datasets ModuleNotFoundError: No module named ‘tensorflow_hub’ 1pip install tensorflow_hub seaborn 绘制矩阵图 (pairplot) 1pip install seaborn 引入类库 TensorFlow and tf.keras12import tensorflow as tffrom tensorflow import keras Helper librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport seaborn as sns","link":"/2022/08/04/TensorFlow%20Mac%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"Zygote进程启动流程(转)","text":"大家都知道android系统的Zygote进程是所有的android进程的父进程，包括SystemServer和各种应用进程都是通过Zygote进程fork出来的。Zygote（孵化）进程相当于是android系统的根进程，后面所有的进程都是通过这个进程fork出来的，而Zygote进程则是通过linux系统的init进程启动的，也就是说，android系统中各种进程的启动方式 init进程 –&gt; Zygote进程 –&gt; SystemServer进程 –&gt;各种应用进程 init进程：linux的根进程，android系统是基于linux系统的，因此可以算作是整个android操作系统的第一个进程； Zygote进程：android系统的根进程，主要作用：可以作用Zygote进程fork出SystemServer进程和各种应用进程； SystemService进程：主要是在这个进程中启动系统的各项服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务等等； 各种应用进程：启动自己编写的客户端应用时，一般都是重新启动一个应用进程，有自己的虚拟机与运行环境； 本文主要介绍一下Zygote进程的启动流程，关于SystenServer进程和各种应用进程的启动方式会在以后的文章中介绍。 init进程在启动Zygote进程时一般都会调用ZygoteInit类的main方法，因此我们这里看一下该方法的具体实现(基于android23源码)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void main(String argv[]) { try { RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = &quot;zygote&quot;; String abiList = null; for (int i = 1; i &lt; argv.length; i++) { if (&quot;start-system-server&quot;.equals(argv[i])) { startSystemServer = true; } else if (argv[i].startsWith(ABI_LIST_ARG)) { abiList = argv[i].substring(ABI_LIST_ARG.length()); } else if (argv[i].startsWith(SOCKET_NAME_ARG)) { socketName = argv[i].substring(SOCKET_NAME_ARG.length()); } else { throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]); } } if (abiList == null) { throw new RuntimeException(&quot;No ABI list supplied.&quot;); } registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) { startSystemServer(abiList, socketName); } Log.i(TAG, &quot;Accepting command socket connections&quot;); runSelectLoop(abiList); closeServerSocket(); } catch (MethodAndArgsCaller caller) { caller.run(); } catch (RuntimeException ex) { Log.e(TAG, &quot;Zygote died with exception&quot;, ex); closeServerSocket(); throw ex; } } 第一行主要是调用enableDdms()，设置DDMS可用，可以发现DDMS启动的时机还是比较早的，在整个Zygote进程刚刚开始要启动额时候就设置可用了。 下面的循环主要是解析main方法的参数获取是否需要启动SystemService进程，获取abi列表，获取scoket连接名称（这里需要注意的是：android系统中进程之间通讯的方式是Binder，但是有一个例外是SystemService进程与Zygote进程之间是通过Socket的方式进行通讯的） 然后调用registerZygoteSocket（String socketName）为Zygote进程注册socket： 123456789101112131415161718192021private static void registerZygoteSocket(String socketName) { if (sServerSocket == null) { int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try { String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); } catch (RuntimeException ex) { throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex); } try { FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); sServerSocket = new LocalServerSocket(fd); } catch (IOException ex) { throw new RuntimeException( &quot;Error binding to local socket '&quot; + fileDesc + &quot;'&quot;, ex); } } } 接着调用系统方法preLoad() 123456789101112static void preload() { Log.d(TAG, &quot;begin preload&quot;); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, &quot;end preload&quot;); } 这其中：preloadClasses()用于初始化Zygote中需要的class类；preloadResources()用于初始化系统资源；preloadOpenGL()用于初始化OpenGL；preloadSharedLibraries()用于初始化系统libraries；preloadTextResources()用于初始化文字资源；prepareWebViewInZygote()用于初始化webview; 然后调用startSystemServer(abiList, socket); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException { long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); /* Hardcoded command line to start the system server */ String args[] = { &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;, &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities, &quot;--nice-name=system_server&quot;, &quot;--runtime-args&quot;, &quot;com.android.server.SystemServer&quot;, }; ZygoteConnection.Arguments parsedArgs = null; int pid; try { parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } /* For child process */ if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } handleSystemServerProcess(parsedArgs); } return true; } 可以看到这段逻辑的执行逻辑就是通过Zygote fork出SystemServer进程。 总结：Zygote进程mian方法主要执行逻辑： 初始化DDMS； 注册Zygote进程的socket通讯； 初始化Zygote中的各种类，资源文件，OpenGL，类库，Text资源等等； 初始化完成之后fork出SystemServer进程； fork出SystemServer进程之后，关闭socket连接； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCache","link":"/2022/08/06/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"Toast加载绘制流程","text":"前面我们分析了Activity、Dialog、PopupWindow的加载绘制流程，相信大家对整个Android系统中的窗口绘制流程已经有了一个比较清晰的认识了，这里最后再给大家介绍一下Toast的加载绘制流程。 其实Toast窗口和Activity、Dialog、PopupWindow有一个不太一样的地方，就是Toast窗口是属于系统级别的窗口，他和输入框等类似的，不属于某一个应用，即不属于某一个进程，所以自然而然的，一旦涉及到Toast的加载绘制流程就会涉及到进程间通讯，看过前面系列文章的同学应该知道，Android间的进程间通讯采用的是Android特有的Binder机制，所以Toast的加载绘制流程也会涉及到Binder进程间通讯。 Toast的显示流程其实内部还是通过Window的窗口机制实现加载绘制的，只不过由于是系统级别的窗口，在显示过程中涉及到了进程间通讯等机制。 下面我们来具体看一下Toast窗口的简单使用。 1Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); 上面的代码是Toast的典型使用方式，通过makeText方法创建出一个Toast对象，然后调用show方法将Toast窗口显示出来。 下面我们来看一下makeText方法的具体实现： 1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) { Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; } 方法体不是很长，在makeText方法中，我们首先通过Toast对象的构造方法，创建了一个新的Toast对象，这样我们就先来看一下Toast的构造方法做了哪些事。 12345678public Toast(Context context) { mContext = context; mTN = new TN(); mTN.mY = context.getResources().getDimensionPixelSize( com.android.internal.R.dimen.toast_y_offset); mTN.mGravity = context.getResources().getInteger( com.android.internal.R.integer.config_toastDefaultGravity); } 可以看到这里初始化了Toast对象的成员变量mContext和mTN，这里的mContext是一个Context类型的成员变量，那mTN是什么东西呢？ 1private static class TN extends ITransientNotification.Stub 从类的源码定义来看，我们知道TN是一个继承自ITransientNotification.Stub的类，这里我们暂时只用知道他的继承关系就好了，知道其是一个Binder对象，可以用于进程间通讯，然后回到我们的makeText方法，在调用了Toast的构造方法创建了Toast对象之后，我们又通过context.getSystemService方法获取到LayoutInflater，然后通过调用LayoutInflater的inflate方法加载到了Toast的布局文件： 123LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); 这里我们可以看一下布局文件的具体代码： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;?android:attr/toastFrameBackground&quot;&gt; &lt;TextView android:id=&quot;@android:id/message&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textAppearance=&quot;@style/TextAppearance.Toast&quot; android:textColor=&quot;@color/bright_foreground_dark&quot; android:shadowColor=&quot;#BB000000&quot; android:shadowRadius=&quot;2.75&quot; /&gt;&lt;/LinearLayout&gt; 可以发现Toast加载的布局文件只有一个LinearLayout布局，并且只包含一个TextView组件。。。。 然后我们通过调用： 1234567TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; 初始化了布局文件，Toast的mNextView和mDuration成员变量并返回Toast类型的result对象。这样我们的Toast对象就构造完成了。 然后我们回到我们的Toast.show方法，调用完这个方法之后就准备开始显示Toast窗口了，我们来具体看一下show方法的具体实现： 12345678910111213141516public void show() { if (mNextView == null) { throw new RuntimeException(&quot;setView must have been called&quot;); } INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try { service.enqueueToast(pkg, tn, mDuration); } catch (RemoteException e) { // Empty } } 首先判断我们的mNextView是否为空，为空的话，显示逻辑就无法进行了，所以这里判断如果mNextView为空的话，就直接抛出异常，不在往下执行。。。。 然后我们执行了： 1INotificationManager service = getService(); 这里的INotificationManager是服务器端NotificationManagerService的Binder客户端，我们可以看一下getService方法的实现方式： 1234567static private INotificationManager getService() { if (sService != null) { return sService; } sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService; } 这里获取了INotificationManager对象，然后我们调用了service.enqueueToast方法，并传递了package，TN对象，duration等参数，这里实际执行的是NotificationManagerService的内部类的INotificationManager.Stub的enqueueToast方法，而我们的NoticationManagerService是在SystemServer进程中执行的，这里的底层其实是通过Binder机制传输数据的，具体的Binder机制相关知识可自行学习。。 好吧，我们在看一下INotificationManager.Stub的enqueueToast方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Override public void enqueueToast(String pkg, ITransientNotification callback, int duration) { ... synchronized (mToastQueue) { int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try { ToastRecord record; int index = indexOfToastLocked(pkg, callback); // If it's already in the queue, we update it in place, we don't // move it to the end of the queue. if (index &gt;= 0) { record = mToastQueue.get(index); record.update(duration); } else { // Limit the number of toasts that any given package except the android // package can enqueue. Prevents DOS attacks and deals with leaks. if (!isSystemToast) { int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) { final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) { count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) { Slog.e(TAG, &quot;Package has already posted &quot; + count + &quot; toasts. Not showing more. Package=&quot; + pkg); return; } } } } record = new ToastRecord(callingPid, pkg, callback, duration); mToastQueue.add(record); index = mToastQueue.size() - 1; keepProcessAliveLocked(callingPid); } // If it's at index 0, it's the current toast. It doesn't matter if it's // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don't // assume that it's valid after this. if (index == 0) { showNextToastLocked(); } } finally { Binder.restoreCallingIdentity(callingId); } } } 可以发现我们首先将我们的ToastRecord（Toast对象在server端的对象）保存到一个List列表mToastQueue中，然后调用了showNextToastLocked方法，这样我们在看一下showNextToastLocked方法的具体实现。 12345678910111213141516171819202122232425void showNextToastLocked() { ToastRecord record = mToastQueue.get(0); while (record != null) { if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try { record.callback.show(); scheduleTimeoutLocked(record); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) { mToastQueue.remove(index); } keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { record = mToastQueue.get(0); } else { record = null; } } } } 这里主要执行了record.callback.show方法，而这里的callback对象就是我们创建Toast对象的时候传递的TN对象，显然的，这了的show方法就是我们的Toast内部类TN的show方法，然后我们调用了scheduleTimeoutLocked方法，这里先看一下scheduleTimeoutLocked方法的实现。 1234567private void scheduleTimeoutLocked(ToastRecord r) { mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay); } 可以发现这里发送了一个异步消息，并且这里的异步消息是在duration时间之后发送的，也就是说我们在Toast端传递的duration参数就是这里的message消息delay发送的时间，而我们发送MESSAGE_TIMEOUT异步消息之后最终会被方法handleTimeout执行。 12345678910private void handleTimeout(ToastRecord record) { if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) { int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) { cancelToastLocked(index); } } } 好吧，方法体里面又调用了cancelToastLocked方法，然后我们看一下cancelToastLocked方法的实现： 12345678910111213141516171819void cancelToastLocked(int index) { ToastRecord record = mToastQueue.get(index); try { record.callback.hide(); } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // don't worry about this, we're about to remove it from // the list anyway } mToastQueue.remove(index); keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { // Show the next one. If the callback fails, this will remove // it from the list, so don't assume that the list hasn't changed // after this point. showNextToastLocked(); } } 好吧，这里又是调用了record.callback.hide方法，显然的这里的hide方法和刚刚的show方法是相似的，都是调用的Toast内部类TN的hide方法，所以这里可以看出Toast的显示与隐藏操作都是在Toast内部类TN的show和hide方法实现的，然后我们调用了: 1mToastQueue.remove(index); 清除这个Toast对象，并继续执行showNextToastLocked方法，直到mToastQueue的大小为0。。。 这样关于Toast窗口的显示与隐藏操作都是在Toast内部类TN的show方法和hide方法中，我们先看一下TN内部类的show方法的具体实现： 12345@Override public void show() { if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow); } 好吧，这里也是发送一个异步消息，我们看一下Runnable类型的mShow的定义。 123456final Runnable mShow = new Runnable() { @Override public void run() { handleShow(); } }; 可以看到再其run方法中调用了handleShow方法，继续看handleShow方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738public void handleShow() { if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView + &quot; mNextView=&quot; + mNextView); if (mView != mNextView) { // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) { context = mView.getContext(); } mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) { mParams.horizontalWeight = 1.0f; } if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) { mParams.verticalWeight = 1.0f; } mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); } } 好吧，在handleShow方法中经过一系列的初始化操作，初始化mWN对象，初始化mView对象，初始化了mParams对象，然后调用了mWM的addView方法，到了这里大家应该就很熟悉了（不熟悉的同学可以看一下Activity的加载绘制流程等文章 android源码解析（十八）–&gt;Activity布局绘制流程&amp;nbsp;&amp;nbsp; android源码解析（十七）–&gt;Activity布局加载流程）通过这个方法就实现了Toast窗口的显示逻辑。 继续看一下TN的hide方法： 12345@Override public void hide() { if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide); } 好吧，和show方法类似，也是发送了一个异步消息，这里看一下Runnable类型的mHide对象的定义： 12345678final Runnable mHide = new Runnable() { @Override public void run() { handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; } }; 可以发现在其run方法中调用了handleHide方法，显然的，与show方法类似，这里的handleHide方法也是执行Toast窗口销毁的逻辑： 1234567891011121314public void handleHide() { if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView); if (mView != null) { // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } mView = null; } } 可以发现，在方法体重调用了mWM.removeView(mView),又是熟悉的代码，通过执行这里的removeView方法，我们可以实现Toast窗口的销毁流程，至此我们就分析完了Toast窗口的显示与销毁流程。 总结： Toast是一个系统窗口，Toast在显示与销毁流程设计到进程间通讯（Binder机制实现） Toast的show方法首先会初始化一个Toast对象，然后将内部对象TN与duration传递给NotificationManagerService，并在NotificationManagerService端维护一个Toast对象列表。 NotificationManagerService接收到Toast的show请求之后，保存Toast对象并回调Toast.TN的show方法具体实现Toast窗口的显示逻辑。 Toast窗口的显示与销毁机制与Activity、Dialog、PopupWIndow都是类似的，都是通过WIndow对象实现的。 NotificationManagerService端在执行show方法执行会发送一个异步消息用于销毁Toast窗口，这个异步消息会在duration时间段之后发出，这样，在设置Toast显示的时间就会被传递到NotificationManagerService端，并在这段时间之后发送异步消息销毁Toast窗口。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程","link":"/2022/08/06/Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"指环王1：魔戒再现.蓝光加长版","text":"[[2000-2010][欧美][奇幻][BT下载][指环王1：魔戒再现.蓝光加长版][BD-MKV/4.03GB][国语双语中英字幕][1080P][奇幻冒险史诗巨制] ◎译 名 指环王1：魔戒再现/魔戒首部曲：魔戒现身/指环王I：护戒使者/魔戒1：护戒联盟 ◎片 名 The Lord of the Rings：The Fellowship of the Ring ◎年 代 2001 ◎国 家 新西兰/美国 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 国英双语 ◎字 幕 中英双字 ◎上映日期 2002-04-04(中国大陆)/2001-12-19(美国) ◎豆瓣评分 8.9/10 from 292224 users ◎豆瓣链接 https://movie.douban.com/subject/1291571/ ◎文件格式 X264+AC3 ◎视频尺寸 1920×1080 ◎文件大小 11.6GB ◎片 长 228min ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 肖恩·宾 Sean Bean 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 伊安·霍姆 Ian Holm 多米尼克·莫纳汉 Dominic Monaghan 萨拉·贝克 Sala Baker 约翰·瑞斯-戴维斯 John Rhys-Davies 【电影简介】 比尔博·巴金斯是100多岁的哈比人，住在故乡夏尔，生性喜欢冒险，在年轻时的一次探险经历中，他从怪物咕噜手中得到了至尊魔戒，这枚戒指是黑暗魔君索伦打造的至尊魔戒，拥有奴役世界的邪恶力量，能够统领其他几枚力量之戒，在3000年前的人类联盟和半兽人大军的战役中，联盟取得了胜利，并得到了至尊魔戒，数千年的辗转后，魔戒落到咕噜手中，被比尔博碰巧得到。 因为和魔戒的朝夕相处，比尔博的心性也受到了影响，在他111岁的生日宴会上，他决定把一切都留给侄子佛罗多(伊莱贾·伍德 饰)，继续冒险。 比尔博的好朋友灰袍巫师甘道夫（伊恩·麦凯伦 饰）知道至尊魔戒的秘密，同时，黑暗魔君索伦已经知道他的魔戒落在哈比族的手中。索伦正在重新建造要塞巴拉多，集结无数的半兽人，准备以大军 夺取魔戒，并且征服全世界。 甘道夫说服佛罗多将魔戒护送到精灵王国瑞文希尔，佛罗多在好朋友山姆、皮平和梅利的陪同下，在跃马旅店得到了刚铎王子阿拉贡的帮助，历经艰难，终于到达了精灵王国。 然而，精灵族并不愿意保管这个邪恶的至尊魔戒，中土各国代表开会讨论，达成意见，准备将至尊魔戒送到末日山脉的烈焰中彻底销毁，佛罗多挺身而出接受了这个任务，这次，陪伴他的除了三个好朋友，还有甘道夫、阿拉贡、精灵莱戈拉斯（奥兰多·布鲁姆 饰）、人类博罗米尔、侏儒金利。 一路上，魔戒远征军除了要逃避索伦爪牙黑骑士和半兽人的追杀之外，更要抵抗至尊魔界本身的邪恶诱惑，前途困难重重。 【电影截图】 指环王1.魔戒再现.国语双语中英字幕.The.Lord.of.the.Rings.The.Fellowship.of.the.Ring.2001.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2022/08/04/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B1%EF%BC%9A%E9%AD%94%E6%88%92%E5%86%8D%E7%8E%B0.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.03GB%5D%5B%E5%9B%BD%5D/"},{"title":"指环王2：双塔奇兵.蓝光加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王2：双塔奇兵.蓝光加长版][BD-MKV/4.81GB][国语双语中英字幕][1080P][豆瓣9.1分史诗巨制] ◎译 名 指环王2：双塔奇兵 / 指环王II：双塔 / 魔戒2：双塔奇谋 / 魔戒二部曲：双城奇谋 ◎片 名 The Lord of the Rings: The Two Towers ◎年 代 2002 ◎产 地 美国 / 新西兰 ◎类 别 剧情 / 动作 / 奇幻 / 冒险 ◎语 言 英语 / 辛达林语 / 古代英语 ◎上映日期 2002-12-05(纽约首映) / 2002-12-18(美国) / 2003-04-25(中国大陆) ◎IMDb评分 8.7/10 from 1369619 users ◎IMDb链接 http://www.imdb.com/title/tt0167261 ◎豆瓣评分 9.1/10 from 410177 users ◎豆瓣链接 https://movie.douban.com/subject/1291572/ ◎片 长 179分钟 ◎导 演 彼得·杰克逊 Peter Jackson ◎编 剧 弗兰·威尔士 Fran Walsh / Philippa Boyens / Stephen Sinclair / 彼得·杰克逊 Peter Jackson / 托尔金 J.R.R. Tolkien ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 克里斯托弗·李 Christopher Lee 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 卡尔·厄本 Karl Urban 凯特·布兰切特 Cate Blanchett 多米尼克·莫纳汉 Dominic Monaghan 大卫·文翰 David Wenham 比利·博伊德 Billy Boyd 布拉德·道里夫 Brad Dourif 伯纳德·希尔 Bernard Hill 约翰·瑞斯-戴维斯 John Rhys-Davies 米兰达·奥图 Miranda Otto ◎标 签 魔幻 | 史诗 | 经典 | 美国 | 战争 | 大片 | 新西兰 | 2002 ◎简 介 第二部在延续第一部风格的同时，故事呈现出多线发展的格局，情节有了更高的观赏性。 第一部结尾，博罗米尔被强兽人杀死之后，两个哈比族人皮平和梅利也被强兽人绑架，阿拉贡、精灵莱戈拉斯（奥兰多?布鲁姆 饰）、侏儒金利一路追踪强兽人，营救皮平和梅利，遇到了“复活”的白袍巫师甘道夫（伊恩?麦凯伦 饰）。此时，投降索伦的白袍巫师萨鲁曼控制了人类洛汉王国的国王，并派出大量的强兽人军队，准备消灭人类。阿拉贡、莱戈拉斯和金利在甘道夫的带领下，帮助洛汉王国对抗邪恶力量的入侵。 幸运的皮平和梅利被会说话的树精救了出来，并且遇到“复活”的甘道夫，在甘道夫的授意下，树精保护了两人的安全，并且带他们参加树精大会，大会上，树精们讨论对待中土大战的态度：是继续当中立者，逆来顺受，还是奋起反抗？ 身负重任的佛罗多(伊莱贾?伍德 饰)和山姆继续向末日山脉前进，一路上被咕噜跟踪，弗罗多依靠至尊魔戒的力量，成为了咕噜的主人，在咕噜的带领下，他们到了末日山脉的入口，黑门。就在他们准备进入之时，博罗米尔的弟弟法莫尔出现，将他们带回了刚铎。弗罗多又遇上了新的危机：法莫尔想利用至尊魔戒的力量对抗萨鲁曼的攻击…… ◎获奖情况 第75届奥斯卡金像奖(2003) 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 最佳剪辑(提名) 迈克·霍顿 最佳视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 最佳音效剪辑 迈克·霍普金斯 / 伊桑·范德莱恩 最佳音响(提名) 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳艺术指导(提名) 格兰特·梅杰 / 丹·汉纳 / 艾伦·李 第56届英国电影学院奖(2003) 电影奖 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 电影奖 最佳导演(提名) 彼得·杰克逊 电影奖 最佳摄影(提名) 安德鲁·莱斯尼 电影奖 最佳剪辑(提名) 迈克·霍顿 / Jabez Olssen 电影奖 最佳化妆/发型(提名) Peter Owen / 彼得·金 / 理查德·泰勒 电影奖 最佳服装设计 恩吉拉·迪克森 / 理查德·泰勒 电影奖 最佳艺术指导(提名) 格兰特·梅杰 电影奖 最佳特殊视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 电影奖 最佳音效(提名) 迈克·亨吉斯 / 迈克·霍普金斯 / 迈克尔·斯曼内科 / 克里斯托弗·博伊斯 / 哈蒙德·匹克 / David Farmer / 伊桑·范德莱恩 电影奖 观众选择奖 第27届日本电影学院奖(2004) 最佳外语片(提名) 第3届美国电影学会奖(2002) 年度佳片 指环王2.双塔奇兵国语双语中英字幕.The.Lord.of.the.Rings.The.Two.Towers.2002.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2022/08/04/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B2%EF%BC%9A%E5%8F%8C%E5%A1%94%E5%A5%87%E5%85%B5.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.81GB%5D%5B%E5%9B%BD%5D/"},{"title":"指环王3：王者无敌.加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王3：王者无敌.加长版][BD-MKV/5.17GB][国英双语中字][1080P][豆瓣9.2高分魔幻巨制] ◎译 名 指环王3：王者无敌/魔戒三部曲：王者再临/指环王III：王者无敌/魔戒3：王者归来/指环王3：国王归来 ◎片 名 The Lord of the Rings: The Return of the King ◎年 代 2003 ◎国 家 美国/新西兰 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 英语/昆雅语/古英语/辛达林语 ◎上映日期 2003-12-01(新西兰首映)/2003-12-17(美国)/2004-03-15(中国大陆) ◎IMDb评分 8.9/10 from 1,064,793 users ◎IMDb链接 http://www.imdb.com/title/tt0167260/ ◎豆瓣评分 9.1/10 from 218,212 users ◎豆瓣链接 http://movie.douban.com/subject/1291552/ ◎片 长 201分钟/251分钟(加长版)/263分钟(蓝光加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 维果·莫腾森 Viggo Mortensen 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 丽芙·泰勒 Liv Tyler 伊恩·麦克莱恩 Ian McKellen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 米兰达·奥图 Miranda Otto 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 多米尼克·莫纳汉 Dominic Monaghan 比利·博伊德 Billy Boyd 马尔顿·索克斯 Marton Csokas 卡尔·厄本 Karl Urban 克里斯托弗·李 Christopher Lee 约翰·瑞斯-戴维斯 John Rhys-Davies ◎简 介 魔幻战争逐渐进入高潮阶段。霍比特人弗拉多（伊利亚·伍德 Elijah Wood 饰）携带着魔戒，与伙伴山姆（Sean Astin 饰）以及狡猾阴暗的咕噜等前往末日山，一路上艰难险阻不断，魔君索伦为阻止魔戒被销毁用尽全力阻挠。另一方面，白袍巫师甘道夫（伊安·麦克莱恩 Ian McKellen 饰）率中土勇士们镇守刚铎首都——白城米那斯提里斯。魔兽大军压境，黑暗与光明的决战即将来临…… 本片是“指环王三部曲”的终结篇，根据英国作家J.R.R.托尔金（J.R.R. Tolkien）同名魔幻巨著《指环王》（The Lord of the Rings）改编，并荣获2004年第76届奥斯卡最佳影片、最佳导演、最佳改编剧本、最佳剪辑、最佳艺术指导、最佳服装设计、最佳化妆、最佳视觉效果、最佳音效、最佳配乐和最佳歌曲等11项大奖。 ◎获奖情况 第76届奥斯卡金像奖 (2004) 最佳影片 Barrie M. Osborne / 弗兰·威尔士 / 彼得·杰克逊 最佳导演 彼得·杰克逊 最佳改编剧本 弗兰·威尔士 / 彼得·杰克逊 / 菲利帕·鲍恩斯 最佳剪辑 Jamie Selkirk 最佳视觉效果 Alex Funke / Jim Rygiel / 乔·莱特瑞 / Randall William Cook 最佳混音 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳美术指导 丹·汉纳 / 格兰特·梅杰 / 艾伦·李 最佳服装设计 Ngila Dickson / 理查德·泰勒 最佳化妆 理查德·泰勒 / 彼得·金 最佳原创配乐 霍华德·肖 最佳原创歌曲 霍华德·肖 / 安妮·蓝妮克丝 / 弗兰·威尔士 第28届日本电影学院奖 (2005) 最佳外语片(提名) 指环王3.王者无敌.国语双语中英字幕.The.Lord.of.the.Rings.The.Return.of.the.King.2003.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2022/08/04/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B3%EF%BC%9A%E7%8E%8B%E8%80%85%E6%97%A0%E6%95%8C.%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV5.17GB%5D%5B%E5%9B%BD%E8%8B%B1%E5%8F%8C%5D/"},{"title":"霍比特人1.意外之旅.蓝光加长版","text":"[2012] [欧美][奇幻][BT下载][霍比特人1.意外之旅.蓝光加长版][BD-MKV/3.58GB][国英双语中英字幕][1080P][特效史诗巨制] ◎译 名 霍比特人1：意外之旅/哈比人：不思议之旅(港)/哈比人：意外旅程(台)/指环王前传：霍比特人(上) ◎片 名 The Hobbit: An Unexpected Journey ◎年 代 2012 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2012-11-28(新西兰首映)/2012-12-14(美国)/2013-02-22(中国大陆) ◎IMDb评分 8.0/10 from 548,633 users ◎IMDb链接 http://www.imdb.com/title/tt0903624 ◎豆瓣评分 8.1/10 from 178,214 users ◎豆瓣链接 http://movie.douban.com/subject/1966182 ◎片 长 169分钟/182分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 肯·斯托特 Ken Stott 格拉汉姆·麦克泰维什 Graham McTavish 詹姆斯·内斯比特 James Nesbitt 迪恩·奥戈曼 Dean O’Gorman 艾丹·特纳 Aidan Turner 雨果·维文 Hugo Weaving 凯特·布兰切特 Cate Blanchett 安迪·瑟金斯 Andy Serkis 西尔维斯特·迈可伊 Sylvester McCoy 克里斯托弗·李 Christopher Lee 伊利亚·伍德 Elijah Wood 伊安·霍姆 Ian Holm 李·佩斯 Lee Pace ◎简 介 中土最后一座矮人王国埃尔波尔，巍峨壮丽，庄严雄伟。老国王索尔积聚大量财富，却引来恶龙史茅革的觊觎和荼毒，最终导致这座城池陷落。许多年后，灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）找到弗罗多的舅舅——霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰），邀请他加入由13名矮人组成的远征队伍。原来史茅革已多年不见声息，背负家国仇恨的矮人王子索林（理查德·阿米蒂奇 Richard Armitage 饰）希望借此机会收复故土。经过一番考虑，巴金斯决定加入。令他想不到的是，远征旅途多灾多难，与索林结下深仇大恨的苍白半兽人及其爪牙阴魂不散，更有食人鬼和石人制造的无数艰险。而在旅途中，巴金斯也意外得到了日后影响整个中土的重要宝物…… 本片根据J.R.R·托尔金的同名原著改编。 霍比特人1.意外之旅.国英双语中英字幕 The.Hobbit.2012.EXTENDED.1080p.BluRay.AC3. x264.mkv.torrent","link":"/2022/08/04/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA1.%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.58GB%5D/"},{"title":"霍比特人2：史矛革之战蓝光加长版","text":"[2013][欧美][动作][BT下载][霍比特人2：史矛革之战蓝光加长版][BD-MKV/3.59GB][国英双语中英字幕][1080P][豆瓣8.1分好评奇幻冒险] ◎译 名 霍比特人2：史矛革之战/霍比特人2：史矛革荒漠/哈比人：荒谷魔龙(港)/哈比人：荒谷恶龙(台)/霍比特人2：斯毛戈荒漠/指环王前传：霍比特人(中) ◎片 名 The Hobbit: The Desolation of Smaug ◎年 代 2013 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2013-12-13(美国)/2014-02-21(中国大陆) ◎IMDb评分 8.0/10 from 413,210 users ◎IMDb链接 http://www.imdb.com/title/tt1170358/ ◎豆瓣评分 8.1/10 from 152,878 users ◎豆瓣链接 http://movie.douban.com/subject/11606328/ ◎片 长 161分钟/186分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 本尼迪克特·康伯巴奇 Benedict Cumberbatch 奥兰多·布鲁姆 Orlando Bloom 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 斯蒂芬·弗雷 Stephen Fry 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 约翰·贝尔 John Bell 马努·贝内特 Manu Bennett 杰德·布罗菲 Jed Brophy 亚当·布朗 Adam Brown 约翰·凯伦 John Callen 瑞安·盖奇 Ryan Gage 马克·哈德洛 Mark Hadlow 皮特·哈姆贝尔顿 Peter Hambleton 斯蒂芬·亨特 Stephen Hunter 威廉姆·吉尔切尔 William Kircher 西尔维斯特·迈可伊 Sylvester McCoy 格拉汉姆·麦克泰维什 Graham McTavish 迪恩·奥戈曼 Dean O’Gorman 米克尔·佩斯勃兰特 Mikael Persbrandt 艾丹·特纳 Aidan Turner ◎简 介 距离孤山越来越近，矮人远征军的道路却变得异常艰险。他们躲过了苍白半兽人的不懈追杀，在幽暗密林前和甘道夫（伊恩·麦凯伦 Ian McKellen 饰）兵分两路，后者前往多尔哥多探寻索伦的动向，而霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）和矮人们先是遭到巨大蜘蛛的袭击，随后又被精灵王子莱戈拉斯（奥兰多·布鲁姆 Orlando Bloom 饰）及其木精灵同伴捕获。比尔博急中生智，利用魔戒救出伙伴，继而引发了木精灵、半兽人和矮人远征军之间精彩纷呈的三方会战。借助巴德（卢克·伊万斯 Luke Evans 饰）的帮助，疲惫的矮人们暂时落脚长湖镇。近在咫尺的孤山城堡，沉睡在财宝中的巨龙即将醒来…… 本片根据J.R.R·托尔金的同名原著改编。 ◎获奖情况 第86届奥斯卡金像奖 (2014) 最佳视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 / Eric Reynolds 最佳音效剪辑(提名) Brent Burge 最佳混音(提名) 迈克·亨吉斯 / 托尼·约翰逊 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 第23届MTV电影奖 (2014) MTV电影奖 年度电影(提名) MTV电影奖 最佳打斗(提名) MTV电影奖 最佳银幕形象转变(提名) 奥兰多·布鲁姆 MTV电影奖 最佳英雄形象(提名) 马丁·弗瑞曼 第16届美国服装设计工会奖 (2014) 奇幻题材电影最佳服装设计(提名) 鲍勃·巴克 / 安·马斯克里 / 理查德·泰勒 第61届美国音效剪辑协会奖 (2014) 金卷轴奖 最佳电影音效剪辑(提名) David Farmer / Chris Ward / Hayden Collow / Craig Tomlinson / Justin Webster / Dave Whitehead / Melanie Graham / John Simpson 金卷轴奖 最佳配乐剪辑(提名) Jonathan Schultz / Steve Gallagher / Nigel Scott / Mark Willsher / Kirsty Whalley 第12届美国视觉效果协会奖 (2014) 最佳特效电影视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 最佳真人电影CG动画角色 大卫·克莱顿 / Eric Reynolds 最佳电影虚拟摄影(提名) Christian Rivers / Thelvin Cabezas 最佳真人电影模拟动画效果(提名) Areito Echevarria 最佳电影视觉效果合成(提名) Giuseppe Tagliavini / Charles Tait / Robin Hollander 第19届美国评论家选择电影奖 (2014) 最佳美术指导(提名) 丹·汉纳 / Ra Vincent 最佳服装设计(提名) 鲍勃·巴克 / Lesley Burkes-Harding / 安·马斯克里 / 理查德·泰勒 最佳化妆(提名) 最佳视觉效果(提名) 动作片最佳女主角(提名) 伊万杰琳·莉莉 第18届金卫星奖 (2014) 电影部门 最佳原创歌曲(提名) 第13届凤凰城影评人协会奖 (2013) 最佳原创配乐(提名) 霍华德·肖 霍比特人2.史矛革之战..国英双语中英字幕.The.Hobbit.2013.EXTENDED.1080p.BluRay.x264.AC3.mkv.torrent","link":"/2022/08/04/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA2%EF%BC%9A%E5%8F%B2%E7%9F%9B%E9%9D%A9%E4%B9%8B%E6%88%98%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.59GB%5D/"},{"title":"霍比特人3.五军之战.蓝光加长版","text":"[2014][欧美][动作][BT下载][霍比特人3.五军之战.蓝光加长版][BD-MKV/3.88GB][国英双语中英双字][1080P][超视效史诗巨制必看] ※※※※※※※ 影片信息 ※※※※※※※ ◎译 名 霍比特人3：五军之战/哈比人：五军之战(港台)/哈比人：奇境再返(台) ◎片 名 The Hobbit: The Battle of the Five Armies ◎年 代 2014 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2014-12-17(美国)/2015-01-23(中国大陆) ◎IMDb评分 7.5/10 from 307,296 users ◎IMDb链接 http://www.imdb.com/title/tt2310332/ ◎片 长 144分钟/164分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 马丁·弗瑞曼 Martin Freeman 伊恩·麦克莱恩 Ian McKellen 理查德·阿米蒂奇 Richard Armitage 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 本尼迪克特·康伯巴奇 Benedict Cumberbatch 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 比利·康诺利 Billy Connolly 凯特·布兰切特 Cate Blanchett 伊安·霍姆 Ian Holm 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 奥兰多·布鲁姆 Orlando Bloom 马努·贝内特 Manu Bennett 艾丹·特纳 Aidan Turner 迪恩·奥戈曼 Dean O’Gorman 格拉汉姆·麦克泰维什 Graham McTavish 斯蒂芬·弗雷 Stephen Fry 米卡埃尔·佩斯布兰特 Mikael Persbrandt ◎简 介 被吵醒的史矛革大闹长湖镇，最终为人类巴德（卢克·伊万斯 Luke Evans 饰）射杀。索林·橡木盾（理查德·阿米蒂奇 Richard Armitage 饰）多年的夙愿终于实现，孤山埃尔波尔重新回到矮人手中。然而这位矮人王子仿佛被史矛革的贪婪和堆成山的黄金迷惑了心窍，他 疯狂地搜寻象征王位的阿肯宝石，不仅撕毁了付给长湖镇报酬的约定，更拒绝了精灵王（李·佩斯 Lee Pace 饰）索要本族国宝的要求，为此导致三族的战争一触即发。与此同时，苍白半兽人阿索格率领大军浩浩荡荡向孤山逼近。得知消息的灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）从中调停斡旋，而被索林视为唯一朋友的霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）则掌握着中土命运的关键。五军会战，爆发在即！ 本片根据J.R.R·托尔金的同名原著改编，为霍比特人系列的最后一部。 ◎获奖情况 第17届美国青少年选择奖 (2015) 最佳科幻/奇幻电影(提名) 第87届奥斯卡金像奖 (2015) 最佳音效剪辑(提名) 霍比特人3.五军之战.国英双语中英双字The.Hobbit.The.Battle.of.the.Five.Armies.2014.EXTENDED.BluRay.1080p.x264.2Audios.mkv.torrent","link":"/2022/08/04/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA3.%E4%BA%94%E5%86%9B%E4%B9%8B%E6%88%98.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.88GB%5D/"},{"title":"activity启动流程(转)","text":"好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等， 首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍： An activity represents a single screen with a user interface. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. Although the activities work together to form a cohesive user experience in the email application, each one is independent of the others. As such, a different application can start any one of these activities (if the email application allows it). For example, a camera application can start the activity in the email application that composes new mail, in order for the user to share a picture. 英文不太好，这里就不献丑了，这里介绍的Activity的大概意思就是说，activity在Android系统中代表的就是一个屏幕，一个App就是由许多个不同的Acitivty组成的，并且不同进程之间的Activity是可以相互调用的。 在介绍Activity的启动流程之前，我们先介绍几个概念： Activity的生命周期 protected void onCreate(Bundle savedInstanceState);protected void onRestart();protected void onStart();protected void onResume();protected void onPause();protected void onStop();protected void onDestory();以上为Activity生命周期中的各个时期的回调方法，在不同的方法中我们可以执行不同的逻辑。关于Activity生命周期的详细介绍可以参考： Android activity的生命周期 Activity的启动模式 activity启动时可以设置不同的启动模式，主要是：standrand，singleTop，singleTask，instance等四种启动模式，不同的启动模式在启动Activity时会执行不同的逻辑，系统会按不同的启动模式将Activity存放到不同的activity栈中。关于Activity启动模式的详细介绍，可以参考： Android任务和返回栈完全解析 Activity的启动进程 在Manifest.xml中定义Activity的时候，Activity默认是属于进程名称为包名的进程的，当然这时候是可以指定Activity的启动进程，所以在Activity启动时首先会检测当前Activity所属的进程是否已经启动，若进程没有启动，则首先会启动该进程，并在该进程启动之后才会执行Activity的启动过程。 Intent启动Activity的方式 Intent启动Activity分为两种，显示启动和隐士启动，显示启动就是在初始化Intent对象的时候直接引用需要启动的Activity的字节码，显示引用的好处就是可以直接告诉Intent对象启动的Activity对象不需要执行intent filter索引需要启动哪一个Activity，但是显示引用不能启动其他进程的Activity对象，因为无法获取其他进程的Activity对象的字节码，而隐式启动则可以通过配置Intent Filter启动其他进程的Activity对象，因此在应用内，我们一般都是使用显示启动的方式启动Activity，而如果需要启动其他应用的Activity时，一般使用隐式启动的方式。 Android Framework层的CS模式通过前几篇文章的介绍我们知道android系统在启动过程中会执行这样的逻辑： Zygote进程 –&gt; SystemServer进程 –&gt; 各种系统服务 –&gt; 应用进程在Actvity启动过程中，其实是应用进程与SystemServer进程相互配合启动Activity的过程，其中应用进程主要用于执行具体的Activity的启动过程，回调生命周期方法等操作，而SystemServer进程则主要是调用其中的各种服务，将Activity保存在栈中，协调各种系统资源等操作。 Android系统进程间通讯Binder机制Android系统存了Zygote进程和SystemServer进程以及各种应用进程等，为了能够实现各种进程之间的通讯，Android系统采用了自己的进程间通讯方式Binder机制。其中主要涉及到了四种角色：Binder Client，Binder Server，Binder Manager， Binder driver。各种角色之间的关系可以参考下面这张图的介绍： 好吧，前面我们介绍了一些Activity启动过程中需要的相关知识点，下面我们开始Activity启动流程的讲解。。。。 还记得前面我们讲过的Launcher启动流程么？可以参考：android源码解析之（十）–&gt;Launcher启动流程在这篇文章中我们说Launcher启动之后会将各个应用包名和icon与app name保存起来，然后执行icon的点击事件的时候调用startActivity方法： 123456789101112131415161718192021222324@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); }protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); }public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以发现，我们在启动Activity的时候，执行的逻辑就是创建一个Intent对象，然后初始化Intent对象，使用隐式启动的方式启动该Acvitity，这里为什么不能使用显示启动的方式呢？ 这是因为Launcher程序启动的Activity一般都是启动一个新的应用进程，该进程与Launcher进程不是在同一个进程中，所以也就无法引用到启动的Activity字节码，自然也就无法启动该Activity了。 继续，我们查看startActivity方法的具体实现： 一:开始请求执行启动Activity MyActivity.startActivity() Activity.startActivity() Activity.startActivityForResult Instrumentation.execStartActivty ActivityManagerNative.getDefault().startActivityAsUser() 在我们的Activity中调用startActivity方法，会执行Activity中的startActivity 1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); } 然后在Activity中的startActivity方法体里调用了startActivity的重载方法，这里我们看一下其重载方法的实现： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 由于在上一步骤中我们传递的Bunde对象为空，所以这里我们执行的是else分支的逻辑，所以这里调用了startActivityForResult方法，并且传递的参数为intent和-1. 注意：通过这里的代码我们可以发现，其实我们在Activity中调用startActivity的内部也是调用的startActivityForResult的。那么为什么调用startActivityForResult可以在Activity中回调onActivityResult而调用startActivity则不可以呢？可以发现其主要的区别是调用startActivity内部调用startActivityForResult传递的传输requestCode值为-1，也就是说我们在Activity调用startActivityForResult的时候传递的requestCode值为-1的话，那么onActivityResult是不起作用的。实际上，经测试requestCode的值小于0的时候都是不起作用的，所以当我们调用startActivityForResult的时候需要注意这一点。 好吧，我们继续往下看，startActivityForResult方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现由于我们是第一次启动Activity，所以这里的mParent为空，所以会执行if分之，然后调用mInstrumentation.execStartActivity方法，并且这里需要注意的是，有一个判断逻辑： 123if (requestCode &gt;= 0) { mStartedActivity = true;} 通过注释也验证了我们刚刚的说法即，调用startActivityForResult的时候只有requestCode的值大于等于0，onActivityResult才会被回调。 然后我们看一下mInstrumentation.execStartActivity方法的实现。在查看execStartActivity方法之前，我们需要对mInstrumentation对象有一个了解？什么是Instrumentation？Instrumentation是android系统中启动Activity的一个实际操作类，也就是说Activity在应用进程端的启动实际上就是Instrumentation执行的，那么为什么说是在应用进程端的启动呢？实际上acitivty的启动分为应用进程端的启动和SystemServer服务进程端的启动的，多个应用进程相互配合最终完成了Activity在系统中的启动的，而在应用进程端的启动实际的操作类就是Intrumentation来执行的，可能还是有点绕口，没关系，随着我们慢慢的解析大家就会对Instrumentation的认识逐渐加深的。 可以发现execStartActivity方法传递的几个参数：this，为启动Activity的对象；contextThread，为Binder对象，是主进程的context对象；token，也是一个Binder对象，指向了服务端一个ActivityRecord对象；target，为启动的Activity；intent，启动的Intent对象；requestCode，请求码；options，参数； 这样就调用了Imstrument.execStartActivity方法了： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 我们发现在这个方法中主要调用ActivityManagerNative.getDefault().startActivity方法，那么ActivityManagerNative又是个什么鬼呢？查看一下getDefault()对象的实现： 123static public IActivityManager getDefault() { return gDefault.get(); } 好吧，相当之简单直接返回的是gDefault.get()，那么gDefault又是什么呢？ 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现： 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 好吧，最后直接返回一个ActivityManagerProxy对象，而ActivityManagerProxy继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的ActivityManagerProxy和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示：Binder接口 –&gt; ActivityManagerNative/ActivityManagerProxy –&gt; ActivityManagerService； 这样，ActivityManagerNative与ActivityManagerProxy相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不同等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。 好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。 继续往下卡，我们调用的是： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这里通过我们刚刚的分析，ActivityManagerNative.getDefault()方法会返回一个ActivityManagerProxy对象，那么我们看一下ActivityManagerProxy对象的startActivity方法： 123456789101112131415161718192021222324252627282930313233public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) { data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { data.writeInt(0); } if (options != null) { data.writeInt(1); options.writeToParcel(data, 0); } else { data.writeInt(0); } mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; } 这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。 以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。 二：ActivityManagerService接收启动Activity的请求 ActivityManagerService.startActivity() ActvityiManagerService.startActivityAsUser() ActivityStackSupervisor.startActivityMayWait() ActivityStackSupervisor.startActivityLocked() ActivityStackSupervisor.startActivityUncheckedLocked() ActivityStackSupervisor.startActivityLocked() ActivityStackSupervisor.resumeTopActivitiesLocked() ActivityStackSupervisor.resumeTopActivityInnerLocked() 好吧，代码量比较大，慢慢看，首先看一下ActivityManagerService.startActivity的具体实现； 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 可以看到，该方法并没有实现什么逻辑，直接调用了startActivityAsUser方法，我们继续看一下startActivityAsUser方法的实现： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，下面我们来看一下这个方法的具体实现： 1234567891011121314151617final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } 这个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法： 1234567891011121314151617final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) { int err = ActivityManager.START_SUCCESS; ... err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); ... return err; } 这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法： 12345678910111213final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) { ... ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) { // Don't set focus on an activity that's going to the back. mService.setFocusedActivityLocked(r, &quot;startedActivity&quot;); } return ActivityManager.START_SUCCESS; } startActivityUncheckedLocked方法中只要执行了不同启动模式不同栈的处理，并最后调用了startActivityLocked的重载方法： 1234567final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) { ... if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } } 这个startActivityLocked方法主要执行初始化了windowManager服务，然后调用resumeTopActivitiesLocked方法： 1234567891011121314151617181920212223242526boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) { if (targetStack == null) { targetStack = mFocusedStack; } // Do targetStack first. boolean result = false; if (isFrontStack(targetStack)) { result = targetStack.resumeTopActivityLocked(target, targetOptions); } for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) { // Already started above. continue; } if (isFrontStack(stack)) { stack.resumeTopActivityLocked(null); } } } return result; } 可以发现经过循环逻辑判断之后，最终调用了resumeTopActivityLocked方法： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后调用： 1234567891011121314151617181920final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) { if (mStackSupervisor.inResumeTopActivity) { // Don't even start recursing. return false; } boolean result = false; try { // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) { mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); } result = resumeTopActivityInnerLocked(prev, options); } finally { mStackSupervisor.inResumeTopActivity = false; } return result; } 继续调用resumeTopActivityInnerLocked方法： 12345678910private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) { ... if (mResumedActivity != null) { if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); } ... return true; } 经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。 三：执行栈顶Activity的onPause方法 ActivityStack.startPausingLocked() IApplicationThread.schudulePauseActivity() ActivityThread.sendMessage() ActivityThread.H.sendMessage(); ActivityThread.H.handleMessage() ActivityThread.handlePauseActivity() ActivityThread.performPauseActivity() Activity.performPause() Activity.onPause() ActivityManagerNative.getDefault().activityPaused(token) ActivityManagerService.activityPaused() ActivityStack.activityPausedLocked() ActivityStack.completePauseLocked() ActivityStack.resumeTopActivitiesLocked() ActivityStack.resumeTopActivityLocked() ActivityStack.resumeTopActivityInnerLocked() ActivityStack.startSpecificActivityLocked 好吧，方法比较多也比较乱，首先来看startPausingLocked方法： 1234567891011121314151617181920212223242526final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... if (prev.app != null &amp;&amp; prev.app.thread != null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev); try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } } else { mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。 这里的ApplicationThread可以和ActivityManagerNative对于一下：通过ActivityManagerNative –&gt; ActivityManagerService实现了应用进程与SystemServer进程的通讯通过AppicationThread &lt;– IApplicationThread实现了SystemServer进程与应用进程的通讯 然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现： 12345678public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges); } 发送了PAUSE_ACTIVITY_FINISHING消息，然后看一下sendMessage的实现方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 调用了其重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现： 123456789101112public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { ... case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...} 可以发现其调用了handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; } 然后调用其重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... mInstrumentation.callActivityOnPause(r.activity); ... return !r.activity.mFinished &amp;&amp; saveState ? r.state : null; } 这样回到了mInstrumentation的callActivityOnPuase方法： 123public void callActivityOnPause(Activity activity) { activity.performPause(); } 呵呵，原来最终回调到了Activity的performPause方法： 1234567891011121314final void performPause() { mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onPause()&quot;); } mResumed = false; } 终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。 然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 可以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，继续看一下activityPausedLocked方法的实现： 1234567final void activityPausedLocked(IBinder token, boolean timeout) { ... if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;)); completePauseLocked(true); ... } 然后执行了completePauseLocked方法： 12345678910111213141516171819202122private void completePauseLocked(boolean resumeNext) { ... if (resumeNext) { final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDown()) { mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null); } else { mStackSupervisor.checkReadyForSleepLocked(); ActivityRecord top = topStack.topRunningActivityLocked(null); if (top == null || (prev != null &amp;&amp; top != prev)) { // If there are no more activities available to run, // do resume anyway to start something. Also if the top // activity on the stack is not the just paused activity, // we need to go ahead and resume it to ensure we complete // an in-flight app switch. mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); } } } ... } 经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第二步中解析的方法中了，这样经过resumeTopActivitiesLocked –&gt;ActivityStack.resumeTopActivityLocked() –&gt;resumeTopActivityInnerLocked –&gt;startSpecificActivityLocked好吧，我们看一下startSpecificActivityLocked的具体实现： 123456789101112131415161718192021222324252627282930313233void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) { // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); } realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } // If a dead object exception was thrown -- fall through to // restart the application. } mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); } 可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。 四：启动Activity所属的应用进程 关于如何启动应用进程，前面的一篇文章已经做了介绍，可参考： android源码解析之（十一）–&gt;应用进程启动流程 这里在简单的介绍一下 ActivityManagerService.startProcessLocked() Process.start() ActivityThread.main() ActivityThread.attach() ActivityManagerNative.getDefault().attachApplication() ActivityManagerService.attachApplication() 好吧，首先看一下startProcessLocked()方法的具体实现： 12345private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) { startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */, null /* entryPoint */, null /* entryPointArgs */); } 然后回调了其重载的startProcessLocked方法： 123456789101112131415private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) { ... boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; + app.processName); checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); ... } 可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名“android.app.ActivityThread”: 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 然后调用了startViaZygote方法： 123456789101112131415161718private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx { synchronized(Process.class) { ... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); } } 继续查看一下zygoteSendArgsAndGetResult方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); int sz = args.size(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); if (arg.indexOf('\\n') &gt;= 0) { throw new ZygoteStartFailedEx( &quot;embedded newlines not allowed&quot;); } writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = inputStream.readInt(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); } result.usingWrapper = inputStream.readBoolean(); return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); } } 可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。 为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。 好了，这时候我们看一下ActivityThread的main方法的实现逻辑。 123456789101112131415161718192021222324public static void main(String[] args) { ... Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。 12345678910private void attach(boolean system) { ... final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } ...} 刚刚我们已经分析过ActivityManagerNative是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的： 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 可以发现其回调了attachApplicationLocked方法，我们看一下这个方法的实现逻辑。 12345678910111213141516171819private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... // See if the top visible activity is waiting to run in this process... if (normalMode) { try { if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } } catch (Exception e) { Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e); badApp = true; } } ... return true; } 该方法执行了一系列的初始化操作，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了，O(∩_∩)O哈哈~ 五：执行启动Acitivity ActivityStackSupervisor.attachApplicationLocked() ActivityStackSupervisor.realStartActivityLocked() IApplicationThread.scheduleLauncherActivity() ActivityThread.sendMessage() ActivityThread.H.sendMessage() ActivityThread.H.handleMessage() ActivityThread.handleLauncherActivity() ActivityThread.performLauncherActivity() Instrumentation.callActivityOnCreate() Activity.onCreate() ActivityThread.handleResumeActivity() ActivityThread.performResumeActivity() Activity.performResume() Instrumentation.callActivityOnResume() Activity.onResume() ActivityManagerNative.getDefault().activityResumed(token) 首先看一下attachApplicationLocked方法的实现： 1234567891011121314151617181920212223242526272829303132boolean attachApplicationLocked(ProcessRecord app) throws RemoteException { final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) { continue; } ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) { if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) { try { if (realStartActivityLocked(hr, app, true, true)) { didSomething = true; } } catch (RemoteException e) { Slog.w(TAG, &quot;Exception in new application when starting activity &quot; + hr.intent.getComponent().flattenToShortString(), e); throw e; } } } } } if (!didSomething) { ensureActivitiesVisibleLocked(null, 0); } return didSomething; } 可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑： 1234567891011121314final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ... app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... return true; } 可以发现与第三步执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLauncherActivity方法，所以真正执行的是ActivityThread中的scheduleLauncherActivity，所以我们看一下ActivityThread中的scheduleLauncherActivity的实现： 1234567891011121314151617181920212223242526272829303132333435@Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); } 好吧，还是那套逻辑，ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法： 1234567891011121314private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); } ... } 可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了。。。 12345678910111213141516171819202122232425262728293031323334353637private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ...Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } ... if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } ... return activity; } 可以发现这里我们需要的Activity对象终于是创建出来了，而且他是以反射的机制创建的，现在还不太清楚为啥google要以反射的方式创建Activity，先不看这些，然后在代码中其调用Instrumentation的callActivityOnCreate方法。 123456public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 然后执行activity的performCreate方法。。。。好吧，都转晕了。。。 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } O(∩_∩)O哈哈~，第二个生命周期方法出来了，onCreate方法。。。。 在回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart();方法，好吧，看一下他的实现方式： 123456789101112131415final void performStart() { mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mFragments.noteStateNotSaved(); mCalled = false; mFragments.execPendingActions(); mInstrumentation.callActivityOnStart(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStart()&quot;); } mFragments.dispatchStart(); mFragments.reportLoaderStart(); mActivityTransitionState.enterReady(this); } 好吧，还是通过Instrumentation调用callActivityOnStart方法： 123public void callActivityOnStart(Activity activity) { activity.onStart(); } 然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O哈哈~ 还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) { final Activity a = r.activity; if (localLOGV) Slog.v( TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) { try { willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); } catch (RemoteException e) { } } if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } } else { // If an exception was thrown when trying to resume, then // just end this activity. try { ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { } } } 可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) { ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r + &quot; finished=&quot; + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) { if (clearHide) { r.hideForNow = false; r.activity.mStartedActivity = false; } try { r.activity.onStateNotSaved(); r.activity.mFragments.noteStateNotSaved(); if (r.pendingIntents != null) { deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; } if (r.pendingResults != null) { deliverResults(r, r.pendingResults); r.pendingResults = null; } r.activity.performResume(); EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName()); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to resume activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } } return r; } 在方法体中，最终调用了r.activity.performResume();方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现： 12345final void performResume() { ... mInstrumentation.callActivityOnResume(this); ... } 好吧，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。 1234567891011121314public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); } } } } O(∩_∩)O哈哈~，第四个生命周期方法出现了，onResume方法。。。 终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有，哈哈，别着急。 有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，咦？对了onStop方法还没回调呢，O(∩_∩)O哈哈~，对了缺少的就是对onStop方法的回调啊。 好吧，具体的逻辑我们下一步再说 六：栈顶Activity执行onStop方法 Looper.myQueue().addIdleHandler(new Idler()) Idler.queueIdle() ActivityManagerNative.getDefault().activityIdle() ActivityManagerService.activityIdle() ActivityStackSupervisor.activityIdleInternalLocked() ActivityStack.stopActivityLocked() IApplicationThread.scheduleStopActivity() ActivityThread.scheduleStopActivity() ActivityThread.sendMessage() ActivityThread.H.sendMessage() ActivityThread.H.handleMessage() ActivityThread.handleStopActivity() ActivityThread.performStopActivityInner() ActivityThread.callCallActivityOnSaveInstanceState() Instrumentation.callActivityOnSaveInstanceState() Activity.performSaveInstanceState() Activity.onSaveInstanceState() Activity.performStop() Instrumentation.callActivityOnStop() Activity.onStop() 回到我们的handleResumeActivity方法，在方法体最后有这样的一代码： 1Looper.myQueue().addIdleHandler(new Idler()); 这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法： 12345678910111213141516171819202122final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { ... // Stop any activities that are scheduled to do so but have been // waiting for the next one to start. for (int i = 0; i &lt; NS; i++) { r = stops.get(i); final ActivityStack stack = r.task.stack; if (stack != null) { if (r.finishing) { stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false); } else { stack.stopActivityLocked(r); } } } ... return r; } 可以发现在其中又调用了ActivityStack.stopActivityLocked方法： 123456789final void stopActivityLocked(ActivityRecord r) { if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, &quot;Stopping: &quot; + r); if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != 0) { ... r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags); ... } } 好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。 123456public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) { sendMessage( showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE, token, 0, configChanges); } 然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。 12345private void handleStopActivity(IBinder token, boolean show, int configChanges) { ... performStopActivityInner(r, info, show, true); ... } 然后我们看一下performStopActivityInner的实现逻辑： 1234567891011121314151617181920212223242526private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... // Next have the activity save its current state and managed dialogs... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } if (!keepShown) { try { // Now we are idle. r.activity.performStop(); } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to stop activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.stopped = true; } } } 好吧，看样子在这个方法中执行了两个逻辑，一个是执行Activity的onSaveInstance方法一个是执行Activity的onStop方法，我们先看一下callCallActivityOnSaveInstanceState的执行逻辑： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 好吧，又是通过Instrumentation来执行。。。 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 又间接调用了Activity的performSaveInstanceState方法： 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 呵呵，这里调用到了，我们以前经常会重写的onSaveInstanceState方法。 然后我们看一下performStopActivityInner中调用到的Activity方法的performStop方法： 1234567891011121314151617181920212223242526272829303132333435363738final void performStop() { mDoReportFullyDrawn = false; mFragments.doLoaderStop(mChangingConfigurations /*retain*/); if (!mStopped) { if (mWindow != null) { mWindow.closeAllPanels(); } if (mToken != null &amp;&amp; mParent == null) { WindowManagerGlobal.getInstance().setStoppedState(mToken, true); } mFragments.dispatchStop(); mCalled = false; mInstrumentation.callActivityOnStop(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStop()&quot;); } synchronized (mManagedCursors) { final int N = mManagedCursors.size(); for (int i=0; i&lt;N; i++) { ManagedCursor mc = mManagedCursors.get(i); if (!mc.mReleased) { mc.mCursor.deactivate(); mc.mReleased = true; } } } mStopped = true; } mResumed = false; } 还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。 123public void callActivityOnStop(Activity activity) { activity.onStop(); } O(∩_∩)O哈哈~，最后一个生命周期方法终于出来了，onStop()….. 总结： Activity的启动流程一般是通过调用startActivity或者是startActivityForResult来开始的 startActivity内部也是通过调用startActivityForResult来启动Activity，只不过传递的requestCode小于0 Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯 ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。 ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。 ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法； ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发； ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作； ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程； ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法； 在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作； ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作； ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法； ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法； ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread； ActivityThread执行真正的onStop方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程","link":"/2022/08/06/activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"activity销毁流程(转)","text":"继续我们的源码解析，上一篇文章我们介绍了Activity的启动流程，一个典型的场景就是Activity a 启动了一个Activity b，他们的生命周期回调方法是：onPause(a) –&gt; onCreate(b) –&gt; onStart(b) –&gt; onResume(b) –&gt; onStop(a)而我们根据源码也验证了这样的生命周期调用序列，那么Activity的销毁流程呢？它的生命周期的调用顺序又是这样的呢？ 这里我们我做一个简单的demo，让一个Activity a启动Activity b，然后在b中调用finish()方法，它们的生命周期执行顺序是： onPause(b)onRestart(a)onStart(a)onResume(a)onStop(b)onDestory(b) 好吧，根据我们测试的生命周期方法的回调过程开始对Activity销毁流程的分析，一般而言当我们需要销毁Activity的时候都会调用其自身的finish方法，所以我们的流程开始是以finish方法开始的。 一：请求销毁当前Activity MyActivity.finish() Activity.finish() ActivityManagerNative.getDefault().finishActivity() ActivityManagerService.finishActivity() ActivityStack.requestFinishActivityLocked() ActivityStack.finishActivityLocked() ActivityStack.startPausingLocked() 首先我们在自己的Activity调用了finish方法，它实际上调用的是Activity的finish方法： 123public void finish() { finish(false);} 然后我们可以发现其调用了finish方法的重载方法，并且传递了一个参数值： 123456789101112131415161718192021222324private void finish(boolean finishTask) { if (mParent == null) { int resultCode; Intent resultData; synchronized (this) { resultCode = mResultCode; resultData = mResultData; } if (false) Log.v(TAG, &quot;Finishing self: token=&quot; + mToken); try { if (resultData != null) { resultData.prepareToLeaveProcess(); } if (ActivityManagerNative.getDefault() .finishActivity(mToken, resultCode, resultData, finishTask)) { mFinished = true; } } catch (RemoteException e) { // Empty } } else { mParent.finishFromChild(this); } } 好吧，这个参数值似乎并没什么用。。。这里就不在讨论了，然后调用了ActivityManagerNative.getDefault().finishActivity方法，好吧，根据上一篇文章的介绍，我们知道了ActivityManagerNative是一个Binder对象，这里调用的方法最终会被ActivityManagerService执行，所以这了的finishActivity最终被执行的是ActivityManagerService.finishActivity方法，好吧，我们来看一下ActivityManagerService的finishActivity方法的执行逻辑。。。 123456@Overridepublic final boolean finishActivity(IBinder token, int resultCode, Intent resultData, boolean finishTask) { ... res = tr.stack.requestFinishActivityLocked(token, resultCode,resultData, &quot;app-request&quot;, true); ...} 这里我们可以发现，经过一系列逻辑判断之后，最终调用了ActivityStack的requestFinishActivityLocked方法，这里应该就是执行finish Activity的逻辑了。 1234567891011121314final boolean requestFinishActivityLocked(IBinder token, int resultCode, Intent resultData, String reason, boolean oomAdj) { ActivityRecord r = isInStackLocked(token); if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(TAG_STATES, &quot;Finishing activity token=&quot; + token + &quot; r=&quot; + &quot;, result=&quot; + resultCode + &quot;, data=&quot; + resultData + &quot;, reason=&quot; + reason); if (r == null) { return false; } finishActivityLocked(r, resultCode, resultData, reason, oomAdj); return true; } 这个方法体里面又调用了finishActivityLocked方法，那我们继续看一下finishActivityLocked方法的实现： 1234567final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData, String reason, boolean oomAdj) { ... startPausingLocked(false, false, false, false); ... return false; } 好吧，在这里调用了startPausingLocked方法，看名字应该是开始要执行Activity的onPause方法请求了，然后我们看一下startPausingLocked方法的实现： 123456789101112131415161718final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 这样从应用程序调用finish方法，ActivityManagerService接收请求并执行startPausingLocked方法。 二：执行当前Activity的onPause方法 IApplicationThread.schedulePauseActivity() ActivityThread.schedulePauseActivity() ActivityThread.sendMessage() ActivityThread.H.sendMessage() ActivityThread.H.handleMessage() ActivityThread.handlePauseActivity() ActivityThread.performPauseActivity() Instrumentation.callActivityOnPause() Activity.performPause() Activity.onPause() ActivityManagerNative.getDefault().activityPaused() ActivityManagerService.activityPaused() ActivityStack.activityPausedLocked() ActivityStack.completePauseLocked() 在方法startPausingLocked中我们调用了：prev.app.thread.schedulePauseActivity这里实际上调用的是IApplicationThread的schedulePauseActivity方法，IApplicationThread也是一个Binder对象，它是ActivityThread中ApplicationThread的Binder client端，所以最终会调用的是ApplicationThread的schedulePauseActivity方法，好吧我们看一下ActivityThread的schedulePauseActivity方法的具体实现： 123456public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges);} 然后调用了ActivityThread的sendMessage方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 然后又回调了sendMessage的重载方法。。 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用mH发送异步消息，然后在mH的handleMessge方法中处理异步消息并调用handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 好吧，这里回调了performPauseActivity方法，上篇文章中我们已经分析过了这段代码： performPauseActivity()Instrumentation.callActivityOnPause()Activity.performPause()Activity.onPause() 这样我们就回调了第一个生命周期方法：onPause。。。 在handlePauseActivity方法中我们调用了ActivityManagerNative.getDefault().activityPaused(token)方法，好吧又是回调ActivityManagerService的方法，这样最终会调用ActivityManagerService的activityPaused方法： 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 这样，我们继续看一下activityPausedLocked方法的实现： 12345final void activityPausedLocked(IBinder token, boolean timeout) { ... completePauseLocked(true); ...} 里面又经过一系列的逻辑判断之后，开始执行completePauseLocked方法： 1234private void completePauseLocked(boolean resumeNext) { ... mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); ... } 这样栈顶Activity的onPause操作就执行完成了，接下来就就是开始执行上一个Activity的onResume操作了。。。 三：执行上一个Activity的onResume操作这样调用了ActivityStackSupervisor.resumeTopActivitiesLocked方法。。，又开始调用这个方法，通过上一篇文章的介绍，我们知道这个方法实际上是执行Activity的初始化，我们看一下其具体的调用过程： ActivityStack.resumeTopActivityLocked() ActivityStack.resumeTopInnerLocked() IApplicationThread.scheduleResumeActivity() ActivityThread.scheduleResumeActivity() ActivityThread.sendMessage() ActivityTherad.H.sendMessage() ActivityThread.H.handleMessage() ActivityThread.H.handleResumeMessage() Activity.performResume() Activity.performRestart() Instrumentation.callActivityOnRestart() Activity.onRestart() Activity.performStart() Instrumentation.callActivityOnStart() Activity.onStart() Instrumentation.callActivityOnResume() Activity.onResume() 好吧，这个过程其实上一篇文章中已经做了介绍，这里不做过多的分析了，通过这样调用过程我们最终执行了当前栈顶Activity上一个Activity的onRestart方法，onStart方法，onResume方法等，下面我们将调用栈顶Activity的onStop方法，onDestory方法。 四：执行栈顶Activity的销毁操作 Looper.myQueue().addIdleHandler(new Idler()) ActivityManagerNative.getDefault().activityIdle() ActivityManagerService.activityIdle() ActivityStackSupervisor.activityIdleInternalLocked() ActivityStack.destroyActivityLocked() IApplicationThread.scheduleDestoryActivity() ActivityThread.scheduleDestoryActivity() ActivityThread.sendMessage() ActivityThread.H.sendMessage() ActivityThread.H.handleMessage() ActivityThread.handleDestoryActivity() ActivityThread.performDestoryActivity() Activity.performStop() Instrumentation.callActivityOnStop() Activity.onStop() Instrumentation.callActivityOnDestory() Activity.performDestory() Acitivity.onDestory() ActivityManagerNative.getDefault().activityDestoryed() ActivityManagerService.activityDestoryed() ActivityStack.activityDestoryedLocked() 我们在ActivityThread.handleResumeActivity方法中调用了Looper.myQueue().addIdleHandler(new Idler())，下面看一下这个方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 内部有一个queueIdle的回调方法，当它被添加到MessageQueue之后就会回调该方法，我们可以发现在这个方法体中调用了ActivityManagerNative.getDefault.activityIdle方法，通过上一篇文章以及上面的讲解，我们应该知道这了最终调用的是ActivityManagerService.activityIdle方法，好吧，这里看一下activityIdle方法的具体实现： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 可以发现这里又调用了ActivityStackSupervisor.activityIdleInternalLocked方法，然后我们看一下activityIdleInternalLocked方法的具体实现： 12345final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { .... stack.destroyActivityLocked(r, true, &quot;finish-idle&quot;); .... } 可以看到这里调用ActivityStack.destroyActivityLocked方法，可以看一下其具体实现： 12345final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) { ... r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags); ... } 好吧，这里又开始执行IApplicationThread.scheduleDestoryActivity方法，上文已经做了说明这里最终调用的是ActivityThread.scheduleDestroyActivity方法，好吧，看一下ActivityThread.scheduleDestryActivity方法的实现： 1234public final void scheduleDestroyActivity(IBinder token, boolean finishing, int configChanges) { sendMessage(H.DESTROY_ACTIVITY, token, finishing ? 1 : 0, configChanges);} 这里有开始执行sendMessage方法，通过一系列的调用sendMessage方法最终调用了handleDestroyActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance); if (r != null) { cleanUpPendingRemoveWindows(r); WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) { if (r.activity.mVisibleFromServer) { mNumVisibleActivities--; } IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) { if (r.onlyLocalRequest) { // Hold off on removing this until the new activity's // window is being added. r.mPendingRemoveWindow = v; r.mPendingRemoveWindowManager = wm; } else { wm.removeViewImmediate(v); } } if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) { WindowManagerGlobal.getInstance().closeAll(wtoken, r.activity.getClass().getName(), &quot;Activity&quot;); } r.activity.mDecor = null; } if (r.mPendingRemoveWindow == null) { // If we are delaying the removal of the activity window, then // we can't clean up all windows here. Note that we can't do // so later either, which means any windows that aren't closed // by the app will leak. Well we try to warning them a lot // about leaking windows, because that is a bug, so if they are // using this recreate facility then they get to live with leaks. WindowManagerGlobal.getInstance().closeAll(token, r.activity.getClass().getName(), &quot;Activity&quot;); } // Mocked out contexts won't be participating in the normal // process lifecycle, but if we're running with a proper // ApplicationContext we need to have it tear down things // cleanly. Context c = r.activity.getBaseContext(); if (c instanceof ContextImpl) { ((ContextImpl) c).scheduleFinalCleanup( r.activity.getClass().getName(), &quot;Activity&quot;); } } if (finishing) { try { ActivityManagerNative.getDefault().activityDestroyed(token); } catch (RemoteException ex) { // If the system process has died, it's game over for everyone. } } mSomeActivitiesChanged = true; } 可以看到这里调用了performDestroyActivity方法，用来执行Avtivity的onDestroy方法： 12345678private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... r.activity.performStop(); ... mInstrumentation.callActivityOnDestroy(r.activity); ... } 然后调用了Activity.performStop()方法，查看performStop方法： 12345final void performStop() { ... mInstrumentation.callActivityOnStop(this); ...} 然后调用了Instrumentation.callActivityOnStop()方法： 123public void callActivityOnStop(Activity activity) { activity.onStop(); } 好吧，终于调用了Activity的onStop方法。。。 我们继续看一下Instrumentation.callActivityOnDestroy()。。。。又是通过Instrumentation来调用Activity的onDestroy方法： 12345public void callActivityOnDestroy(Activity activity) { ... activity.performDestroy(); ...} 然后看一下Activity的performDestroy()方法的实现： 12345678910final void performDestroy() { mDestroyed = true; mWindow.destroy(); mFragments.dispatchDestroy(); onDestroy(); mFragments.doLoaderDestroy(); if (mVoiceInteractor != null) { mVoiceInteractor.detachActivity(); } } O(∩_∩)O哈哈~，终于回调了Activity的onDestroy方法。。。。 总结： Activity的销毁流程是从finish方法开始的 Activity销毁过程是：onPause –&gt; onRestart –&gt; onStart –&gt; onResume –&gt; onStop –&gt; onDestroy Activity的销毁流程是ActivityThread与ActivityManagerService相互配合销毁的 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程","link":"/2022/08/06/activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/"},{"title":"android之HandlerThread(转)","text":"HandlerThread是个什么东西？查看类的定义时有这样一段话： 1Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 意思就是说：这个类的作用是创建一个包含looper的线程。那么我们在什么时候需要用到它呢?加入在应用程序当中为了实现同时完成多个任务，所以我们会在应用程序当中创建多个线程。为了让多个线程之间能够方便的通信，我们会使用Handler实现线程间的通信。这个时候我们手动实现的多线程+Handler的简化版就是我们HandlerThrea所要做的事了。 下面我们首先看一下HandlerThread的基本用法： 12345678910111213141516171819202122232425HandlerThread mHandlerThread = new HandlerThread(&quot;myHandlerThreand&quot;); mHandlerThread.start(); // 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; title = (TextView) findViewById(R.id.title); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Message msg = new Message(); msg.obj = &quot;11111&quot;; mHandler.sendMessage(msg); msg = new Message(); msg.obj = &quot;2222&quot;; mHandler.sendMessage(msg); } }); 我们首先定义了一个HandlerThread对象，是直接通过new的方式产生的，查看其构造方法： 1234public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; } 可以知道HandlerThread继承于Thread，所以说HandlerThread本质上是一个线程，其构造方法主要是做一些初始化的操作。 然后我们调用了mHandlerThread.start()方法，由上我们知道了HandlerThread类其实就是一个Thread，一个线程，所以其start方法内部调用的肯定是Thread的run方法，我们查看一下其run方法的具体实现： 12345678910111213@Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } 我们发现其内部调用了Looper.prepate()方法和Loop.loop()方法，熟悉android异步消息机制的童鞋应当知道，在android体系中一个线程其实是对应着一个Looper对象、一个MessageQueue对象，以及N个Handler对象，具体可参考： android源码解析之（二）–&gt;异步消息机制 所以通过run方法，我们可以知道在我们创建的HandlerThread线程中我们创建了该线程的Looper与MessageQueue； 这里需要注意的是其在调用Looper.loop()方法之前调用了一个空的实现方法：onLooperPrepared(),我们可以实现自己的onLooperPrepared（）方法，做一些Looper的初始化操作； run方法里面当mLooper创建完成后有个notifyAll()，getLooper()中有个wait()，这是为什么呢？因为的mLooper在一个线程中执行，而我们的handler是在UI线程初始化的，也就是说，我们必须等到mLooper创建完成，才能正确的返回getLooper();wait(),notify()就是为了解决这两个线程的同步问题 然后我们调用了： 1234567// 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; 该Handler的构造方法中传入了HandlerThread的Looper对象，所以Handler对象就相当于含有了HandlerThread线程中Looper对象的引用。 然后我们调用handler的sendMessage方法发送消息，在Handler的handleMessge方法中就可以接收到消息了。 最后需要注意的是在我们不需要这个looper线程的时候需要手动停止掉； 12345protected void onDestroy() { super.onDestroy(); mHandlerThread.quit(); } 相对来说HandlerThread还是比较简单的，这里总结一下： HandlerThread本质上是一个Thread对象，只不过其内部帮我们创建了该线程的Looper和MessageQueue； 通过HandlerThread我们不但可以实现UI线程与子线程的通信同样也可以实现子线程与子线程之间的通信； HandlerThread在不需要使用的时候需要手动的回收掉； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2022/08/06/android%E4%B9%8BHandlerThread/"},{"title":"android之IntentService(转)","text":"什么是IntentService？简单来说IntentService就是一个含有自身消息循环的Service，首先它是一个service，所以service相关具有的特性他都有，同时他还有一些自身的属性，其内部封装了一个消息队列和一个HandlerThread，在其具体的抽象方法：onHandleIntent方法是运行在其消息队列线程中，废话不多说，我们来看其简单的使用方法： 定义一个IntentService 123456789101112public class MIntentService extends IntentService{ public MIntentService() { super(&quot;&quot;); } @Override protected void onHandleIntent(Intent intent) { Log.i(&quot;tag&quot;, intent.getStringExtra(&quot;params&quot;) + &quot; &quot; + Thread.currentThread().getId()); }} 在androidManifest.xml中定义service 123&lt;service android:name=&quot;.MIntentService&quot; /&gt; 启动这个service 12345678title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, MIntentService.class); intent.putExtra(&quot;params&quot;, &quot;ceshi&quot;); startService(intent); } }); 可以发现当点击title组件的时候，service接收到了消息并打印出了传递过去的intent参数，同时显示onHandlerIntent方法执行的线程ID并非主线程，这是为什么呢？ 下面我们来看一下service的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public abstract class IntentService extends Service { private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) { super(); mName = name; } /** * Sets intent redelivery preferences. Usually called from the constructor * with your preferred semantics. * * &lt;p&gt;If enabled is true, * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_REDELIVER_INTENT}, so if this process dies before * {@link #onHandleIntent(Intent)} returns, the process will be restarted * and the intent redelivered. If multiple Intents have been sent, only * the most recent one is guaranteed to be redelivered. * * &lt;p&gt;If enabled is false (the default), * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_NOT_STICKY}, and if the process dies, the Intent * dies along with it. */ public void setIntentRedelivery(boolean enabled) { mRedelivery = enabled; } @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } @Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } /** * You should not override this method for your IntentService. Instead, * override {@link #onHandleIntent}, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; } @Override public void onDestroy() { mServiceLooper.quit(); } /** * Unless you provide binding for your service, you don't need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override public IBinder onBind(Intent intent) { return null; } /** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call {@link #stopSelf}. * * @param intent The value passed to {@link * android.content.Context#startService(Intent)}. */ @WorkerThread protected abstract void onHandleIntent(Intent intent);} 怎么样，代码还是相当的简洁的，首先通过定义我们可以知道IntentService是一个Service，并且是一个抽象类，所以我们在继承IntentService的时候需要实现其抽象方法：onHandlerIntent。 下面看一下其onCreate方法： 12345678910111213@Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } 我们可以发现其内部定义一个HandlerIThread（本质上是一个含有消息队列的线程）具体可参考：android源码解析之（四）–&gt;HandlerThread然后用成员变量维护其Looper和Handler，由于其Handler关联着这个HandlerThread的Looper对象，所以Handler的handMessage方法在HandlerThread线程中执行。 然后我们发现其onStartCommand方法就是调用的其onStart方法，具体看一下其onStart方法： 1234567@Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } 很简单就是就是讲startId和启动时接受到的intent对象传递到消息队列中处理，那么我们具体看一下其消息队列的处理逻辑： 1234567891011private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } 可以看到起handleMessage方法内部执行了两个逻辑一个是调用了其onHandlerIntent抽象方法，通过分析其onCreate方法handler对象的创建过程我们知道其handler对象是依附于HandlerThread线程的，所以其handeMessage方法也是在HandlerThread线程中执行的，从而证实了我们刚刚例子中的一个结论，onHandlerIntent在子线程中执行。然后调用了stopSelf方法，这里需要注意的是stopSelf方法传递了msg.arg1参数，从刚刚的onStart方法我们可以知道我们传递了startId，参考其他文章我们知道，由于service可以启动N次，可以传递N次消息，当IntentService的消息队列中含有消息时调用stopSelf(startId)并不会立即stop自己，只有当消息队列中最后一个消息被执行完成时才会真正的stop自身。 通过上面的例子与相关说明，我们可以知道： IntentService是一个service，也是一个抽象类； 继承IntentService需要实现其onHandlerIntent抽象方法； onHandlerIntent在子线程中执行； IntentService内部保存着一个HandlerThread、Looper与Handler等成员变量，维护这自身的消息队列； 每次IntentService后台任务执行完成之后都会尝试关闭自身，但是当且仅当IntentService消息队列中最后一个消息被执行完成之后才会真正的stop自身； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThread","link":"/2022/08/06/android%E4%B9%8BIntentService/"},{"title":"android之Log日志(转)","text":"首先说点题外话，对于想学android framework源码的同学，其实可以在github中fork一份，具体地址：platform_frameworks_base这里面基本都是android framework层的源码了。而且最近发现了一个比较不错的github插件：OctoTree，它 是一个浏览器插件，它可以让你在Github 看代码时，左边栏会出现一个树状结构，就像我们在IDE 一样。当我们看一个项目的结构，或者想看具体的某个文件，这样就会很方便。 怎么样这样查看源代码的话是不是很方面？ 好了说一下我们今天需要介绍的Log对象，它位于android framework层utils包下，是一个final class类：查看其具体定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public final class Log { /** * Priority constant for the println method; use Log.v. */ public static final int VERBOSE = 2; /** * Priority constant for the println method; use Log.d. */ public static final int DEBUG = 3; /** * Priority constant for the println method; use Log.i. */ public static final int INFO = 4; /** * Priority constant for the println method; use Log.w. */ public static final int WARN = 5; /** * Priority constant for the println method; use Log.e. */ public static final int ERROR = 6; /** * Priority constant for the println method. */ public static final int ASSERT = 7; private Log() { } /** * Send a {@link #VERBOSE} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int v(String tag, String msg) { return println(LOG_ID_MAIN, VERBOSE, tag, msg); } /** * Send a {@link #VERBOSE} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int v(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, VERBOSE, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #DEBUG} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int d(String tag, String msg) { return println(LOG_ID_MAIN, DEBUG, tag, msg); } /** * Send a {@link #DEBUG} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int d(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, DEBUG, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send an {@link #INFO} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int i(String tag, String msg) { return println(LOG_ID_MAIN, INFO, tag, msg); } /** * Send a {@link #INFO} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int i(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, INFO, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #WARN} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int w(String tag, String msg) { return println(LOG_ID_MAIN, WARN, tag, msg); } /** * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int w(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, msg + '\\n' + getStackTraceString(tr)); } /* * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param tr An exception to log */ public static int w(String tag, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr)); } /** * Send an {@link #ERROR} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int e(String tag, String msg) { return println(LOG_ID_MAIN, ERROR, tag, msg); } /** * Send a {@link #ERROR} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int e(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, ERROR, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Handy function to get a loggable stack trace from a Throwable * @param tr An exception to log */ public static String getStackTraceString(Throwable tr) { if (tr == null) { return &quot;&quot;; } // This is to reduce the amount of log spew that apps do in the non-error // condition of the network being unavailable. Throwable t = tr; while (t != null) { if (t instanceof UnknownHostException) { return &quot;&quot;; } t = t.getCause(); } StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); tr.printStackTrace(pw); pw.flush(); return sw.toString(); } /** * Low-level logging call. * @param priority The priority/type of this log message * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @return The number of bytes written. */ public static int println(int priority, String tag, String msg) { return println(LOG_ID_MAIN, priority, tag, msg); } /** @hide */ public static final int LOG_ID_MAIN = 0; /** @hide */ public static final int LOG_ID_RADIO = 1; /** @hide */ public static final int LOG_ID_EVENTS = 2; /** @hide */ public static final int LOG_ID_SYSTEM = 3; /** @hide */ public static final int LOG_ID_CRASH = 4; /** @hide */ @SuppressWarnings(&quot;unused&quot;) public static int println(int bufID, int priority, String tag, String msg) { return 0; }} 可以看到其实final 类，所以我们不能通过继承Log类的方式实现自身的日志工具类，一般的我们可以通过定义Log成员变量的方式，封装Log工具方法； 在Log类中我们定义了六种日志级别，分别是：VERBOSE、DEBUG、INFO、WARN、ERROR、ASSERT等六种级别，但是我们平时使用的只有前五种，即VERBOSE,DEBUG,INFO,WARN,ERROR。 通过查看源代码我们发现Log类中所有的静态日志方法Log.v()，Log.d()，Log.i()，Log.w()，Log.e()等方法都是底层都是调用了println方法，然后在github的源码中查看，其实其内部调用的是println_native方法，也就是通过JNI调用底层的c++输出日志； 我们暂时只是分析到这里，至于底层的c++日志输出的具体实现不作分析，总结一下： Log.java是一个final类，所以我们不可以继承Log类来实现自己的日志框架，但是可以通过关联（保存Log成员变量）的方式实现自己的Log工具类； Log.java中定义了六种日志级别，但是我们通常只是使用其中的五种日志级别，分别对应着VERBOSE、DEBUG、INFO、WARN、ERROR，在具体的使用场景下具体分析； 有些同学对android自带的日志框架不太满意，主要是无法定位日志位置，这里可以查看我写的一篇实现自定义日志框架的文章：github项目解析（五）–&gt;android日志框架 日志可以个性化的展示相关信息： 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentService","link":"/2022/08/06/android%E4%B9%8BLog%E6%97%A5%E5%BF%97/"},{"title":"android之LruCache(转)","text":"android开发过程中经常会用到缓存，现在主流的app中图片等资源的缓存策略一般是分两级，一个是内存级别的缓存，一个是磁盘级别的缓存。 作为android系统的维护者google也开源了其缓存方案，LruCache和DiskLruCache。从android3.1开始LruCache已经作为android源码的一部分维护在android系统中，为了兼容以前的版本android的support-v4包也提供了LruCache的维护，如果App需要兼容到android3.1之前的版本就需要使用support-v4包中的LruCache，如果不需要兼容到android3.1则直接使用android源码中的LruCache即可，这里需要注意的是DiskLruCache并不是android源码的一部分。 在LruCache的源码中，关于LruCache有这样的一段介绍： 1A cache that holds strong references to a limited number of values. Each time a value is accessed, it is moved to the head of a queue. When a value is added to a full cache, the value at the end of that queue is evicted and may become eligible for garbage collection. cache对象通过一个强引用来访问内容。每次当一个item被访问到的时候，这个item就会被移动到一个队列的队首。当一个item被添加到已经满了的队列时，这个队列的队尾的item就会被移除。 其实这个实现的过程就是LruCache的缓存策略，即Lru–&gt;(Least recent used)最少最近使用算法。 下面我们具体看一下LruCache的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319public class LruCache&lt;K, V&gt; { private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override {@link #sizeOf}, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); } /** * Sets the size of the cache. * * @param maxSize The new maximum size. */ public void resize(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } synchronized (this) { this.maxSize = maxSize; } trimToSize(maxSize); } /** * Returns the value for {@code key} if it exists in the cache or can be * created by {@code #create}. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. */ public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } /** * Caches {@code value} for {@code key}. The value is moved to the head of * the queue. * * @return the previous value mapped by {@code key}. */ public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } /** * Removes the entry for {@code key} if it exists. * * @return the previous value mapped by {@code key}. */ public final V remove(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V previous; synchronized (this) { previous = map.remove(key); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, null); } return previous; } /** * Called for entries that have been evicted or removed. This method is * invoked when a value is evicted to make space, removed by a call to * {@link #remove}, or replaced by a call to {@link #put}. The default * implementation does nothing. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * @param evicted true if the entry is being removed to make space, false * if the removal was caused by a {@link #put} or {@link #remove}. * @param newValue the new value for {@code key}, if it exists. If non-null, * this removal was caused by a {@link #put}. Otherwise it was caused by * an eviction or a {@link #remove}. */ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {} /** * Called after a cache miss to compute a value for the corresponding key. * Returns the computed value or null if no value can be computed. The * default implementation returns null. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * &lt;p&gt;If a value for {@code key} exists in the cache when this method * returns, the created value will be released with {@link #entryRemoved} * and discarded. This can occur when multiple threads request the same key * at the same time (causing multiple values to be created), or when one * thread calls {@link #put} while another is creating a value for the same * key. */ protected V create(K key) { return null; } private int safeSizeOf(K key, V value) { int result = sizeOf(key, value); if (result &lt; 0) { throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value); } return result; } /** * Returns the size of the entry for {@code key} and {@code value} in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * * &lt;p&gt;An entry's size must not change while it is in the cache. */ protected int sizeOf(K key, V value) { return 1; } /** * Clear the cache, calling {@link #entryRemoved} on each removed entry. */ public final void evictAll() { trimToSize(-1); // -1 will evict 0-sized elements } /** * For caches that do not override {@link #sizeOf}, this returns the number * of entries in the cache. For all other caches, this returns the sum of * the sizes of the entries in this cache. */ public synchronized final int size() { return size; } /** * For caches that do not override {@link #sizeOf}, this returns the maximum * number of entries in the cache. For all other caches, this returns the * maximum sum of the sizes of the entries in this cache. */ public synchronized final int maxSize() { return maxSize; } /** * Returns the number of times {@link #get} returned a value that was * already present in the cache. */ public synchronized final int hitCount() { return hitCount; } /** * Returns the number of times {@link #get} returned null or required a new * value to be created. */ public synchronized final int missCount() { return missCount; } /** * Returns the number of times {@link #create(Object)} returned a value. */ public synchronized final int createCount() { return createCount; } /** * Returns the number of times {@link #put} was called. */ public synchronized final int putCount() { return putCount; } /** * Returns the number of values that have been evicted. */ public synchronized final int evictionCount() { return evictionCount; } /** * Returns a copy of the current contents of the cache, ordered from least * recently accessed to most recently accessed. */ public synchronized final Map&lt;K, V&gt; snapshot() { return new LinkedHashMap&lt;K, V&gt;(map); } @Override public synchronized final String toString() { int accesses = hitCount + missCount; int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0; return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;, maxSize, hitCount, missCount, hitPercent); }} 可以看到LruCache初始化的时候需要使用泛型，一般的我们这样初始化LruCache对象： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 这里我们假设通过String作为key保存bitmap对象，同时需要传递一个int型的maxSize数值，主要用于设置LruCache链表的最大值。 查看其构造方法： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 可以看到其主要的是初始化了maxSize和map链表对象。 然后查看put方法： 12345678910111213141516171819202122public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } 需要传递两个参数：K和V，首先做了一下参数的判断，然后定义一个保存前一个Value值得临时变量，让putCount（put执行的次数）自增，让map的size大小自增。需要注意的是这里的 1previous = map.put(key, value); 我们看一下这里的map.put（）的具体实现： 1234567891011121314151617181920212223242526@Override public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { if (e.hash == hash &amp;&amp; key.equals(e.key)) { preModify(e); V oldValue = e.value; e.value = value; return oldValue; } } // No entry for (non-null) key is present; create one modCount++; if (size++ &gt; threshold) { tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } 将Key与Value的值压入Map中，这里判断了一下如果map中已经存在该key，value键值对，则不再压入map，并将Value值返回，否则将该键值对压入Map中，并返回null； 返回继续put方法： 1234previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } 可以看到这里我们判断map.put方法的返回值是否为空，如果不为空的话，则说明我们刚刚并没有将我么你的键值对压入Map中，所以这里的size需要自减； 然后下面： 123if (previous != null) { entryRemoved(false, key, previous, value); } 这里判断previous是否为空，如果不为空的话，调用了一个空的实现方法entryRemoved()，也就是说我们可以实现自己的LruCache并在添加缓存的时候若存在该缓存可以重写这个方法； 下面调用了trimToSize(maxSize)方法： 1234567891011121314151617181920212223242526272829public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } 该方法主要是判断该Map的大小是否已经达到阙值，若达到，则将Map队尾的元素（最不常使用的元素）remove掉。 总结：LruCache put方法，将键值对压入Map数据结构中，若这是Map的大小已经大于LruCache中定义的最大值，则将Map中最早压入的元素remove掉； 查看get方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } 可以看到参数值为Key，简单的理解就是通过key值从map中取出Value值。具体来说，判断map中是否含有key值value值，若存在，则hitCount（击中元素数量）自增，并返回Value值，若没有击中，则执行create(key)方法，这里看到create方法是一个空的实现方法，返回值为null，所以我们可以重写该方法，在调用get（key）的时候若没有找到value值，则自动创建一个value值并压入map中。 总结： LruCache，内部使用Map保存内存级别的缓存 LruCache使用泛型可以设配各种类型 LruCache使用了Lru算法保存数据（最短最少使用least recent use） LruCache只用使用put和get方法压入数据和取出数据 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Log","link":"/2022/08/06/android%E4%B9%8BLruCache/"},{"title":"android异步消息机制(转)","text":"知乎上看了一篇非常不错的博文：有没有必要阅读ANDROID源码痛定思过，为了更好的深入android体系，决定学习android framework层源码，就从最简单的android异步消息机制开始吧。 （一）Handler的常规使用方式 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity { public static final String TAG = MainActivity.class.getSimpleName(); private TextView texttitle = null; /** * 在主线程中定义Handler，并实现对应的handleMessage方法 */ public static Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;接收到handler消息...&quot;); } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); texttitle = (TextView) findViewById(R.id.texttitle); texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { // 在子线程中发送异步消息 mHandler.sendEmptyMessage(101); } }.start(); } }); }} 可以看出，一般handler的使用方式都是在主线程中定义Handler，然后在子线程中调用mHandler.sendEmptyMessage();方法，然么这里有一个疑问了，我们可以在子线程中定义Handler么？ （二）如何在子线程中定义Handler？ 我们在子线程中定义Handler，看看结果: 123456789101112131415161718texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 点击按钮并运行这段代码： 可以看出来在子线程中定义Handler对象出错了，难道Handler对象的定义或者是初始化只能在主线程中？其实不是这样的，错误信息中提示的已经很明显了，在初始化Handler对象之前需要调用Looper.prepare()方法，那么好了，我们添加这句代码再次执行一次： 12345678910111213141516171819texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Looper.prepare(); Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 再次点击按钮执行该段代码之后，程序已经不会报错了，那么这说明初始化Handler对象的时候我们是需要调用Looper.prepare()的，那么主线程中为什么可以直接初始化Handler呢？ 其实不是这样的，在App初始化的时候会执行ActivityThread的main方法： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 可以看到原来Looper.prepare()方法在这里调用了，所以在其他地方我们就可以直接初始化Handler了。 并且我们可以看到还调用了：Looper.loop()方法，通过参考阅读其他文章我们可以知道一个Handler的标准写法其实是这样的： 12345678910Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); （三）查看Handler源码1）查看Looper.prepare()方法 12345678910111213141516171819// sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * {@link #loop()} after calling this method, and end it by calling * {@link #quit()}. */ public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 可以看到Looper中有一个ThreadLocal成员变量，熟悉JDK的同学应该知道，当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。具体参考：彻底理解ThreadLocal由此可以看出在每个线程中Looper.prepare()能且只能调用一次，这里我们可以尝试一下调用两次的情况。 1234567891011121314/** * 这里Looper.prepare()方法调用了两次*/Looper.prepare();Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); 再次运行程序，点击按钮，执行该段代码：可以看到程序出错，并提示prepare中的Excetion信息。 我们继续看Looper对象的构造方法，可以看到在其构造方法中初始化了一个MessageQueue对象： 1234private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 综上小结（1）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。 2）查看Handler对象的构造方法 12345678910111213141516171819public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 可以看出在Handler的构造方法中，主要初始化了一下变量，并判断Handler对象的初始化不应再内部类，静态类，匿名类中，并且保存了当前线程中的Looper对象。综上小结（2）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。而Handler的构造方法则在Handler内部维护了当前线程的Looper对象 3）查看handler.sendMessage(msg)方法一般的，我们发送异步消息的时候会这样调用： 1mHandler.sendMessage(new Message()); 通过不断的跟进源代码，其最后会调用： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 原来msg.target就是Handler对象本身；而这里的queue对象就是我们的Handler内部维护的Looper对象关联的MessageQueue对象。查看messagequeue对象的enqueueMessage方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 可以看到这里MessageQueue并没有使用列表将所有的Message保存起来，而是使用Message.next保存下一个Message，从而按照时间将所有的Message排序； 4）查看Looper.Loop()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 可以看到方法的内容还是比较多的。可以看到Looper.loop()方法里起了一个死循环，不断的判断MessageQueue中的消息是否为空，如果为空则直接return掉，然后执行queue.next()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } 可以看到其大概的实现逻辑就是Message的出栈操作，里面可能对线程，并发控制做了一些限制等。获取到栈顶的Message对象之后开始执行： 1msg.target.dispatchMessage(msg); 那么msg.target是什么呢？通过追踪可以知道就是我们定义的Handler对象，然后我们查看一下Handler类的dispatchMessage方法： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 可以看到，如果我们设置了callback（Runnable对象）的话，则会直接调用handleCallback方法： 123private static void handleCallback(Message message) { message.callback.run(); } 即，如果我们在初始化Handler的时候设置了callback（Runnable）对象，则直接调用run方法。比如我们经常写的runOnUiThread方法： 123456runOnUiThread(new Runnable() { @Override public void run() { } }); 看其内部实现： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 而如果msg.callback为空的话，会直接调用我们的mCallback.handleMessage(msg)，即handler的handlerMessage方法。由于Handler对象是在主线程中创建的，所以handler的handlerMessage方法的执行也会在主线程中。 综上可以知道：1）主线程中定义Handler，直接执行： 123456Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); }}; 而如果想要在子线程中定义Handler，则标准的写法为： 1234567891011// 初始化该线程Looper，MessageQueue，执行且只能执行一次 Looper.prepare(); // 初始化Handler对象，内部关联Looper对象 Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; // 启动消息队列出栈死循环 Looper.loop(); 2）一个线程中只存在一个Looper对象，只存在一个MessageQueue对象，可以存在N个Handler对象，Handler对象内部关联了本线程中唯一的Looper对象，Looper对象内部关联着唯一的一个MessageQueue对象。 3）MessageQueue消息队列不是通过列表保存消息（Message）列表的，而是通过Message对象的next属性关联下一个Message从而实现列表的功能，同时所有的消息都是按时间排序的。 4）android中两个子线程相互交互同样可以通过Handler的异步消息机制实现，可以在线程a中定义Handler对象，而在线程b中获取handler的引用并调用sendMessage方法。 5）activity内部默认存在一个handler的成员变量，android中一些其他的异步消息机制的实现方法：Handler的post方法： 123456mHandler.post(new Runnable() { @Override public void run() { } }); 查看其内部实现： 1234public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } 可以发现其内部调用就是sendMessage系列方法。。。 view的post方法： 123456789public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); return true; } 可以发现其调用的就是activity中默认保存的handler对象的post方法。 activity的runOnUiThread方法： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 判断当前线程是否是UI线程，如果不是，则调用handler的post方法，否则直接执行run方法。 参考文章：Android异步消息处理机制完全解析，带你从源码的角度彻底理解 Android异步消息处理机制详解及源码分析 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制","link":"/2022/08/06/android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"title":"android异步任务AsyncTask(转)","text":"android的异步任务体系中还有一个非常重要的操作类：AsyncTask，其内部主要使用的是java的线程池和Handler来实现异步任务以及与UI线程的交互。本文主要解析AsyncTask的的使用与源码。 首先我们来看一下AsyncTask的基本使用： 12345678910111213141516171819class MAsyncTask extends AsyncTask&lt;Integer, Integer, Integer&gt; { @Override protected void onPreExecute() { super.onPreExecute(); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } @Override protected void onPostExecute(Integer i) { super.onPostExecute(i); Log.i(&quot;TAG&quot;, &quot;onPostExecute...(开始执行后台任务之后)&quot;); } @Override protected Integer doInBackground(Integer... params) { Log.i(TAG, &quot;doInBackground...(开始执行后台任务)&quot;); return 0; } } 我们定义了自己的MAsyncTask并继承自AsyncTask；并重写了其中的是哪个回调方法：onPreExecute()，onPostExecute（），doInBackground();然后开始调用异步任务： 1new MAsyncTask().execute(); 好了，下面我们开始分析异步任务的执行过程，首先查看一下异步任务的构造方法： 1234567891011121314151617181920212223242526272829303132/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 咋一看AsyncTask的构造方法代码量还是比较多的，但是仔细一看其实这里面只是初始化了两个成员变量：mWorker和mFuture他们分别是：WorkerRunnable和FutureTask，熟悉java的童鞋应该知道这两个类其实是java里面线程池先关的概念。其具体用法大家可以在网上查询，这里具体的细节不在表述，重点是对异步任务整体流程的把握。 总结：异步任务的构造方法主要用于初始化线程池先关的成员变量。 接下来我们看一下execute方法： 1234@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } 这里发现该方法中添加一个@MainThread的注解，通过该注解，可以知道我们在执行AsyncTask的execute方法时，只能在主线程中执行，这里可以实验一下： 12345678new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); new MAsyncTask().execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); 然后执行，但是并没有什么区别，程序还是可以正常执行，我的手机的Android系统是Android5.0，具体原因尚未找到，欢迎有知道答案的童鞋可以相互沟通哈。但是这里需要主要的一个问题是：onPreExecute方法是与开始执行的execute方法是在同一个线程中的，所以如果在子线程中执行execute方法，一定要确保onPreExecute方法不执行刷新UI的方法，否则： 123456@Override protected void onPreExecute() { super.onPreExecute(); title.setText(&quot;########&quot;); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } 12345678910111213141516171819Process: com.example.aaron.helloworld, PID: 659 android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6981) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1034) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.widget.RelativeLayout.requestLayout(RelativeLayout.java:380) at android.view.View.requestLayout(View.java:17704) at android.widget.TextView.checkForRelayout(TextView.java:7109) at android.widget.TextView.setText(TextView.java:4082) at android.widget.TextView.setText(TextView.java:3940) at android.widget.TextView.setText(TextView.java:3915) at com.example.aaron.helloworld.MainActivity$MAsyncTask.onPreExecute(MainActivity.java:53) at android.os.AsyncTask.executeOnExecutor(AsyncTask.java:587) at android.os.AsyncTask.execute(AsyncTask.java:535) at com.example.aaron.helloworld.MainActivity$1$1.run(MainActivity.java:40) at java.lang.Thread.run(Thread.java:818) 若在子线程中执行execute方法，那么这时候如果在onPreExecute方法中刷新UI，会报错，即子线程中不能更新UI。 继续看刚才的execute方法，我们可以发现其内部调用了executeOnExecutor方法： 123456789101112131415161718192021222324@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; } 可以看到其具体的内部实现方法里：首先判断当前异步任务的状态，其内部保存异步任务状态的成员变量mStatus的默认值为Status.PENDING,所以第一次执行的时候并不抛出这两个异常，那么什么时候回进入这个if判断并抛出异常呢，通过查看源代码可以知道，当我们执行了execute方法之后，如果再次执行就会进入这里的if条件判断并抛出异常，这里可以尝试一下： 123456789101112131415161718192021final MAsyncTask mAsyncTask = new MAsyncTask(); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { /*MLog.e(&quot;you have clicked the title textview!!!&quot;); Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivityForResult(intent, 101);*/ new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); mAsyncTask .execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); } }); 这里我们可以看到我们定义了一个AsyncTask的对象，并且每次执行点击事件的回调方法都会执行execute方法，当我们点击第一次的时候程序正常执行，但是当我们执行第二次的时候，程序就崩溃了。若这时候第一次执行的异步任务尚未执行完成则会抛出异常： 1Cannot execute task:the task is already running. 若第一次执行的异步任务已经执行完成，则会抛出异常： 1Cannot execute task:the task has already been executed (a task can be executed only once) 继续往下看，在executeOnExecutor中若没有进入异常分之，则将当前异步任务的状态更改为Running，然后回调onPreExecute()方法，这里可以查看一下onPreExecute方法其实是一个空方法，主要就是为了用于我们的回调实现，同时这里也说明了onPreExecute（）方法是与execute方法的执行在同一线程中。 然后将execute方法的参数赋值给mWorker对象那个，最后执行exec.execute(mFuture)方法，并返回自身。 这里我们重点看一下exec.execute(mFuture)的具体实现，这里的exec其实是AsyncTask定义的一个默认的Executor对象： 1private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 那么，SERIAL_EXECUTOR又是什么东西呢？ 1public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 继续查看SerialExecutor的具体实现： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 可以发现其继承Executor类其内部保存着一个Runnable列表，即任务列表，在刚刚的execute方法中执行的exec.execute(mFuture)方法就是执行的这里的execute方法。这里具体看一下execute方法的实现：1）首先调用的是mTasks的offer方法，即将异步任务保存至任务列表的队尾2）判断mActive对象是不是等于null，第一次运行是null，然后调用scheduleNext()方法3）在scheduleNext()这个方法中会从队列的头部取值，并赋值给mActive对象，然后调用THREAD_POOL_EXECUTOR去执行取出的取出的Runnable对象。4）在这之后如果再有新的任务被执行时就等待上一个任务执行完毕后才会得到执行，所以说同一时刻只会有一个线程正在执行。5）这里的THREAD_POOL_EXECUTOR其实是一个线程池对象。 然后我们看一下执行过程中mWorker的执行逻辑： 1234567891011mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; 可以看到在执行线程池的任务时，我们回调了doInBackground方法，这也就是我们重写AsyncTask时重写doInBackground方法是后台线程的原因。 然后在任务执行完毕之后会回调我们的done方法： 123456789101112131415mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; 这里我们具体看一下postResultIfNotInvoked方法： 123456private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } 其内部还是调用了postResult方法： 1234567private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } 这里可以看到起调用了内部的Handler对象的sendToTarget方法，发送异步消息，具体handler相关的内容可以参考： android源码解析之（二）–&gt;异步消息机制 追踪代码，可以查看AsyncTask内部定义了一个Handler对象： 1234567891011121314151617181920private static class InternalHandler extends Handler { public InternalHandler() { super(Looper.getMainLooper()); } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 可以看到起内部的handleMessage方法，有两个处理逻辑，分别是：更新进入条和执行完成，这里的更新进度的方法就是我们重写AsyncTask方法时重写的更新进度的方法，这里的异步任务完成的消息会调用finish方法： 12345678private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 这里AsyncTask首先会判断当前任务是否被取消，若被取消的话则直接执行取消的方法，否则执行onPostExecute方法，也就是我们重写AsyncTask时需要重写的异步任务完成时回调的方法。 其实整个异步任务的大概流程就是这样子的，其中涉及的知识点比较多，这里总结一下： 异步任务内部使用线程池执行后台任务，使用Handler传递消息； onPreExecute方法主要用于在异步任务执行之前做一些操作，它所在线程与异步任务的execute方法所在的线程一致，这里若需要更新UI等操作，则execute方法不能再子线程中执行。 通过刚刚的源码分析可以知道异步任务一般是顺序执行的，即一个任务执行完成之后才会执行下一个任务。 doInBackground这个方法所在的进程为任务所执行的进程，在这里可以进行一些后台操作。 异步任务执行完成之后会通过一系列的调用操作，最终回调我们的onPostExecute方法 异步任务对象不能执行多次，即不能创建一个对象执行多次execute方法。（通过execute方法的源码可以得知） 所有源码基于android23，中间有什么疏漏欢迎指正。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2022/08/06/android%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1AsyncTask/"},{"title":"android项目构建流程(转)","text":"平时开发过程中我们通过android studio编写完成android项目之后直接点击 Run ‘app’就可以在build/outputs/apk生成可以在android设备中安装的apk文件了，那么整个android源码的构建过程是怎么样的呢？ 我们可以根据Google官方提供的流程图来具体了解构建的过程： 通常的构建过程就是如上图所示，下面是具体描述： 1.AAPT(Android Asset Packaging Tool)工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然assets文件夹中的文件不会被编译，图片及raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹中的资源也会生成资源id。AAPT编译完成之后会生成R.java文件。 2.AIDL工具会将所有的aidl接口转化为java接口。 3.所有的java代码，包括R.java与aidl文件都会被Java编译器编译成.class文件。 4.Dex工具会将上述产生的.class文件及第三库及其他.class文件编译成.dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。 5.ApkBuilder工具会将编译过的资源及未编译过的资源（如图片等）以及.dex文件打包成APK文件。 6.生成APK文件后，需要对其签名才可安装到设备，平时测试时会使用debug keystore，当正式发布应用时必须使用release版的keystore对应用进行签名。 7.如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会减少内存的开销。","link":"/2022/08/06/android%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/08/04/hello-world/"},{"title":"mac环境下，出现brew command not found错误的解决方法","text":"mac 终端下，执行以下命令，即可安装brew： /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 在终端环境下，brew –version 查看brew的版本，也可以验证brew是否安装成功","link":"/2022/08/06/mac%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%87%BA%E7%8E%B0brew%20command%20not%20found%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"apk安装流程(转)","text":"上一篇文章中给大家分析了一下android系统启动之后调用PackageManagerService服务并解析系统特定目录，解析apk文件并安装的过程，这个安装过期实际上是没有图形界面的，底层调用的是我们平时比较熟悉的adb命令，那么我们平时安装apk文件的时候大部分是都过图形界面安装的，那么这种方式安装apk具体的流程是怎样的呢？ 下面我们就来具体看一下apk的具体安装过程，相信大家都知道如果我们想在代码里执行apk的安装，那么一般都是这样： 1234Intent intent = new Intent(Intent.ACTION_VIEW);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.setDataAndType(Uri.parse(&quot;file://&quot; + path),&quot;application/vnd.android.package-archive&quot;);context.startActivity(intent); 这样，我们就会打开安装apk文件的程序并执行安装逻辑了，那么这段代码具体是打开那个activity呢？好吧，从这个问题开始，我们来解析apk的安装流程… 这里跟大姐简单介绍一下android的源码，平时我们使用的android.jar里面的java源码只是android系统源码的一部分，还有好多源码并没有打入到android.jar中，这里为大家推荐一个android源码的地址：https://github.com/android里面根据android系统的不同模块包含了许多android模块的源码。 这里我们找到platform_packages_apps_packageinstaller库，这里面就是android系统安装程序的源码了。 这里我们找到其androidManifest.xml，然后我们来看一下其具体的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.packageinstaller&quot; coreApp=&quot;true&quot;&gt; &lt;original-package android:name=&quot;com.android.packageinstaller&quot; /&gt; ... &lt;application android:label=&quot;@string/app_name&quot; android:allowBackup=&quot;false&quot; android:theme=&quot;@style/Theme.DialogWhenLarge&quot; android:supportsRtl=&quot;true&quot;&gt; &lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.InstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.UninstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/Theme.AlertDialogActivity&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.DELETE&quot; /&gt; &lt;action android:name=&quot;android.intent.action.UNINSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.UninstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.GrantPermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/GrantPermissions&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.ManagePermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:label=&quot;@string/app_permissions&quot; android:theme=&quot;@style/Settings&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_APP_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSION_APPS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.OverlayWarningDialog&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@android:style/Theme.DeviceDefault.Light.Dialog.NoActionBar&quot; /&gt; &lt;provider android:name=&quot;.wear.WearPackageIconProvider&quot; android:authorities=&quot;com.google.android.packageinstaller.wear.provider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;true&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.wear.WarningConfirmationActivity&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot; android:theme=&quot;@style/Settings&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt; 好吧，这里我们大概看一下Activity的定义，这里我们重点看一下PackageInstallerActivity的定义： 123456789101112131415161718192021&lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 恩？这里不就是我们刚刚定义的启动安装Apk activity的intent filter？好吧，所以说一开始我们调用的startActivity其实启动的就是PackageInstallerActivity，那么下面我们就看一下PackageInstellerActivity的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 这里我们主要先看一下PackageInstallerActivity的onCreate方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 可以发现，在onCreate方法中，首先执行一些初始化操作，获取PackageManager和Installer、UserManager等对象，然后会根据当前Intent的信息最一些逻辑判断并弹出消息弹窗，我们可以看一下具体的消息弹窗类型： 12345678private static final int DLG_BASE = 0; private static final int DLG_UNKNOWN_SOURCES = DLG_BASE + 1; private static final int DLG_PACKAGE_ERROR = DLG_BASE + 2; private static final int DLG_OUT_OF_SPACE = DLG_BASE + 3; private static final int DLG_INSTALL_ERROR = DLG_BASE + 4; private static final int DLG_ALLOW_SOURCE = DLG_BASE + 5; private static final int DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES = DLG_BASE + 6; private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7; 可以发现当分析Intent对象的时候，如果可以得到这样几种结果：不知道apk的来源，package信息错误，存储空间不够，安装时报，来源正确，允许未知来源的apk文件，在wear上不支持等，这样根据不同的消息类型会弹出不同的消息弹窗： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119@Override public Dialog onCreateDialog(int id, Bundle bundle) { switch (id) { case DLG_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_dlg_text) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Finishing off activity so that user can navigate to settings manually&quot;); finish(); }}) .setPositiveButton(R.string.settings, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Launching settings&quot;); launchSecuritySettings(); } }) .setOnCancelListener(this) .create(); case DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_admin_dlg_text) .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_PACKAGE_ERROR : return new AlertDialog.Builder(this) .setTitle(R.string.Parse_error_dlg_title) .setMessage(R.string.Parse_error_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_OUT_OF_SPACE: // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText = getString(R.string.out_of_space_dlg_text, appTitle.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.out_of_space_dlg_title) .setMessage(dlgText) .setPositiveButton(R.string.manage_applications, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { //launch manage applications Intent intent = new Intent(&quot;android.intent.action.MANAGE_PACKAGE_STORAGE&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); finish(); } }) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Canceling installation&quot;); finish(); } }) .setOnCancelListener(this) .create(); case DLG_INSTALL_ERROR : // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle1 = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText1 = getString(R.string.install_failed_msg, appTitle1.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.install_failed) .setNeutralButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setMessage(dlgText1) .setOnCancelListener(this) .create(); case DLG_ALLOW_SOURCE: CharSequence appTitle2 = mPm.getApplicationLabel(mSourceInfo); String dlgText2 = getString(R.string.allow_source_dlg_text, appTitle2.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.allow_source_dlg_title) .setMessage(dlgText2) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_CANCELED); finish(); }}) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { SharedPreferences prefs = getSharedPreferences(PREFS_ALLOWED_SOURCES, Context.MODE_PRIVATE); prefs.edit().putBoolean(mSourceInfo.packageName, true).apply(); startInstallConfirm(); } }) .setOnCancelListener(this) .create(); case DLG_NOT_SUPPORTED_ON_WEAR: return new AlertDialog.Builder(this) .setTitle(R.string.wear_not_allowed_dlg_title) .setMessage(R.string.wear_not_allowed_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_OK); finish(); } }) .setOnCancelListener(this) .create(); } return null; } 消息弹窗的主要作用，用于提示用户当前安装apk文件的特性。都知道android系统在android apk文件之前会解析器manifest文件，这个操作也是早onCreate方法中执行的： 1PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); 我们具体看一下getPackageInfo方法的实现： 12345678910public static PackageParser.Package getPackageInfo(File sourceFile) { final PackageParser parser = new PackageParser(); try { PackageParser.Package pkg = parser.parseMonolithicPackage(sourceFile, 0); parser.collectManifestDigest(pkg); return pkg; } catch (PackageParserException e) { return null; } } 好吧，到了这里是不是代码变得很熟悉了？parseMonolithicPackage就是我们上一节分析的android系统解析manifest文件的过程，具体的可参考：http://blog.csdn.net/qq_23547831/article/details/51203482 而collectManifestDigest方法，我们这里简单的介绍一下，其主要是要争apk的签名是否正确。好吧通过这两部我们就把apk文件的manifest和签名信息都解析完成并保存在了Package中。 接着往下走，在所有的解析完成之后我们会在onCreate方法中执行initiateInstall();方法，刚方法的主要作用是初始化安装。 123456789101112131415161718192021222324252627282930313233343536private void initiateInstall() { String pkgName = mPkgInfo.packageName; // Check if there is already a package on the device with this name // but it has been renamed to something else. String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName }); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) { pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; } // Check if package is already installed. display confirmation dialog if replacing pkg try { // This is a little convoluted because we want to get all uninstalled // apps, but this may include apps with just data, and if it is just // data we still want to count it as &quot;installed&quot;. mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.GET_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) { mAppInfo = null; } } catch (NameNotFoundException e) { mAppInfo = null; } mInstallFlowAnalytics.setReplace(mAppInfo != null); mInstallFlowAnalytics.setSystemApp( (mAppInfo != null) &amp;&amp; ((mAppInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0)); // If we have a session id, we're invoked to verify the permissions for the given // package. Otherwise, we start the install process. if (mSessionId != -1) { startInstallConfirm(); } else { startInstall(); } } 好吧，这里面有调用了startInstallConfirm方法，然后我们看一下startInstallConfirm方法的实现: 12345private void startInstallConfirm() { ... //初始化安装确认界面 ...} 好吧，这个方法的实现比较简单，主要的实现逻辑就是现实该activity的用户界面，平时我们安装某一个应用的时候会弹出一个安装确认页面，还有一个确认和取消按钮，有印象么？其实就是在这里执行的界面初始化操作。 好吧，一般情况下在apk安装确认页面，我们会点击确认按钮执行安装逻辑吧？那么这里我们找一下确认按钮的点击事件： 1234567891011121314151617181920212223242526272829public void onClick(View v) { if (v == mOk) { if (mOkCanInstall || mScrollView == null) { mInstallFlowAnalytics.setInstallButtonClicked(); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, true); // We're only confirming permissions, so we don't really know how the // story ends; assume success. mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult( PackageManager.INSTALL_SUCCEEDED); finish(); } else { startInstall(); } } else { mScrollView.pageScroll(View.FOCUS_DOWN); } } else if (v == mCancel) { // Cancel and finish setResult(RESULT_CANCELED); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, false); } mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_CANCELLED_BY_USER); finish(); } } 很明显了，这里当我们点击确认按钮的时候会执行startInstall方法，也就是开始执行安装逻辑： 123456789101112131415161718192021222324252627282930313233private void startInstall() { // Start subactivity to actually install the application Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallAppProgress.class); newIntent.putExtra(InstallAppProgress.EXTRA_MANIFEST_DIGEST, mPkgDigest); newIntent.putExtra( InstallAppProgress.EXTRA_INSTALL_FLOW_ANALYTICS, mInstallFlowAnalytics); String installerPackageName = getIntent().getStringExtra( Intent.EXTRA_INSTALLER_PACKAGE_NAME); if (mOriginatingURI != null) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI); } if (mReferrerURI != null) { newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI); } if (mOriginatingUid != VerificationParams.NO_UID) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid); } if (installerPackageName != null) { newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName); } if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true); newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); } if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); startActivity(newIntent); finish(); } 可以发现，点击确认按钮之后我们调用启用了一个新的Activity–&gt;InstallAppProgress，这个Activity主要用于执行apk的安装逻辑了。 123456789101112131415161718192021222324252627@Override public void onCreate(Bundle icicle) { super.onCreate(icicle); Intent intent = getIntent(); mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); mInstallFlowAnalytics = intent.getParcelableExtra(EXTRA_INSTALL_FLOW_ANALYTICS); mInstallFlowAnalytics.setContext(this); mPackageURI = intent.getData(); final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); throw new IllegalArgumentException(&quot;unexpected scheme &quot; + scheme); } mInstallThread = new HandlerThread(&quot;InstallThread&quot;); mInstallThread.start(); mInstallHandler = new Handler(mInstallThread.getLooper()); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BROADCAST_ACTION); registerReceiver( mBroadcastReceiver, intentFilter, BROADCAST_SENDER_PERMISSION, null /*scheduler*/); initView(); } 可以发现InstallAppProcess这个Activity的onCreate方法中主要初始化了一些成员变量，并调用initView方法，我们在iniTView方法中可以看到： 12345678910void initView() { ... mInstallHandler.post(new Runnable() { @Override public void run() { doPackageStage(pm, params); } }); ...} 经过一些view的初始化操作之后调用了doPackageStage方法，该方法主要是通过调用PackageInstaller执行apk文件的安装，这里就不在详细的介绍了，在apk文件安装完成之后PackageInstaller会发送一个安装完成的广播，刚刚我们在onCreate方法中注册了一个广播接收器，其可以用来接收apk安装完成的广播： 123456789101112private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final int statusCode = intent.getIntExtra( PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (statusCode == PackageInstaller.STATUS_PENDING_USER_ACTION) { context.startActivity((Intent)intent.getParcelableExtra(Intent.EXTRA_INTENT)); } else { onPackageInstalled(statusCode); } } }; 这样apk安装完成之后，这里的广播接收器会接收到广播并执行onPackageInstalled方法，执行后续的处理逻辑，那么我们来看一下onPackageInstalled方法的具体实现逻辑： 12345void onPackageInstalled(int statusCode) { Message msg = mHandler.obtainMessage(INSTALL_COMPLETE); msg.arg1 = statusCode; mHandler.sendMessage(msg); } 好吧，这里是发送Handler异步消息，我们来看一下异步消息的处理逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Handler mHandler = new Handler() { public void handleMessage(Message msg) { switch (msg.what) { case INSTALL_COMPLETE: mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(msg.arg1); if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, msg.arg1); setResult(msg.arg1 == PackageInstaller.STATUS_SUCCESS ? Activity.RESULT_OK : Activity.RESULT_FIRST_USER, result); finish(); return; } // Update the status text mProgressBar.setVisibility(View.INVISIBLE); // Show the ok button int centerTextLabel; int centerExplanationLabel = -1; LevelListDrawable centerTextDrawable = (LevelListDrawable) getDrawable(R.drawable.ic_result_status); if (msg.arg1 == PackageInstaller.STATUS_SUCCESS) { mLaunchButton.setVisibility(View.VISIBLE); centerTextDrawable.setLevel(0); centerTextLabel = R.string.install_done; // Enable or disable launch button mLaunchIntent = getPackageManager().getLaunchIntentForPackage( mAppInfo.packageName); boolean enabled = false; if(mLaunchIntent != null) { List&lt;ResolveInfo&gt; list = getPackageManager(). queryIntentActivities(mLaunchIntent, 0); if (list != null &amp;&amp; list.size() &gt; 0) { enabled = true; } } if (enabled) { mLaunchButton.setOnClickListener(InstallAppProgress.this); } else { mLaunchButton.setEnabled(false); } } else if (msg.arg1 == PackageInstaller.STATUS_FAILURE_STORAGE){ showDialogInner(DLG_OUT_OF_SPACE); return; } else { // Generic error handling for all other error codes. centerTextDrawable.setLevel(1); centerExplanationLabel = getExplanationFromErrorCode(msg.arg1); centerTextLabel = R.string.install_failed; mLaunchButton.setVisibility(View.INVISIBLE); } if (centerTextDrawable != null) { centerTextDrawable.setBounds(0, 0, centerTextDrawable.getIntrinsicWidth(), centerTextDrawable.getIntrinsicHeight()); mStatusTextView.setCompoundDrawablesRelative(centerTextDrawable, null, null, null); } mStatusTextView.setText(centerTextLabel); if (centerExplanationLabel != -1) { mExplanationTextView.setText(centerExplanationLabel); mExplanationTextView.setVisibility(View.VISIBLE); } else { mExplanationTextView.setVisibility(View.GONE); } mDoneButton.setOnClickListener(InstallAppProgress.this); mOkPanel.setVisibility(View.VISIBLE); break; default: break; } } }; 可以发现，当apk安装完成之后，我们会更新UI，显示完成和打开按钮，是不是和我们平时安装apk的逻辑对应上了？这时候我们可以看一下这两个按钮的点击事件。 1234567891011public void onClick(View v) { if(v == mDoneButton) { if (mAppInfo.packageName != null) { Log.i(TAG, &quot;Finished installing &quot;+mAppInfo.packageName); } finish(); } else if(v == mLaunchButton) { startActivity(mLaunchIntent); finish(); } } 好吧，比较简单，点击完成按钮，直接finish掉这个activity，点击打开，则直接调用startActivity启动安装的应用，然后直接finish自身。 总结： 代码中执行intent.setDataAndType(Uri.parse(“file://“ + path),”application/vnd.android.package-archive”);可以调起PackageInstallerActivity； PackageInstallerActivity主要用于执行解析apk文件，解析manifest，解析签名等操作； InstallAppProcess主要用于执行安装apk逻辑，用于初始化安装界面，用于初始化用户UI。并调用PackageInstaller执行安装逻辑； InstallAppProcess内注册有广播，当安装完成之后接收广播，更新UI。显示apk安装完成界面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程","link":"/2022/08/06/apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"},{"title":"onLowMemory执行流程","text":"上篇文章中我们分析了Activity的onSaveInstanceState方法执行时机，知道了Activity在一般情况下，若只是执行onPause方法则不会执行onSaveInstanceState方法，而一旦执行了onStop方法就会执行onSaveInstanceState方法，具体的信息，可以参见onSaveInstanceState方法执行时机：android源码解析（二十四）–&gt;onSaveInstanceState执行时机 这篇文章中同样的我们分析一下Actvity（当然不只是Activity，同样包含Servier，ContentProvider，Application等）的另一个内部方法：onLowMemory。该方法主要用于当前系统可用内存比较低的时候回调使用。 这里简单介绍一下Android系统的内存分配机制。Android系统中一个个的App都是一个个不同的应用进程，拥有各自的JVM与运行时，每个App的进程可使用的内存大小都是固定的，当系统中App打开数量过多时，就会使Android系统的可用内存降低，对于当前正在使用的App而言，可能还需要继续申请系统内存，而我们的剩余系统内存已经不足以被当前App所申请了，这时候系统会自动的清理那些后台进程，进而释放出可用内存用于前台进程的使用，当然这里系统清理后台进程的算法不是我们讨论的重点。这里我们只是大概的分析Android系统回调Activity的onLowMemory方法的流程。 通过前面关于Activity的启动流程分析我们知道ActivityManagerService是整个Android系统的管理中枢，负责Activity，Servier等四大组件的启动与销毁等工作，同样的对于应用进程的管理工作也是在ActivityMaangerServier中完成的，我们知道android系统中有两个比较重要的进程Zygote进程和SystemServer进程，其中Zygote进程是整个Android系统的根进程，其他所有的进程都是通过Zygote进程fork出来的。而SystemServer进程则用于运行各种服务，为其他的应用进程提供各种功能接口等，在前面我们分析过SystemServer进程的启动流程（参考： android源码解析之（九）–&gt;SystemServer进程启动流程）其中在SystemServer的startBootService方法中我们调用了： 12// Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); 方法，看其注释说明，说的是为System进程初始化Application实例，这里我们可以看一下该方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this)); ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this)); ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this)); if (MONITOR_CPU_USAGE) { ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this)); } ServiceManager.addService(&quot;permission&quot;, new PermissionController(this)); ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this)); ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( &quot;android&quot;, STOCK_PM_FLAGS); mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) { ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) { mPidsSelfLocked.put(app.pid, app); } updateLruProcessLocked(app, false, null); updateOomAdjLocked(); } } catch (PackageManager.NameNotFoundException e) { throw new RuntimeException( &quot;Unable to find android system package&quot;, e); } } 这里简单介绍一下ServierManager是一个管理服务的服务，而其addServier方法就是注册各种服务（服务注册到JNI层，具体的关于是如何注册到JNI层的这里暂不做过多的解释）。可以发现在方法体中我们注册了名称为：memInfo的服务MemBinder，MemBinder是一个Binder类型的服务，主要用于检测系统内存情况，这里可以看一下其具体的实现逻辑： 12345678910111213141516171819static class MemBinder extends Binder { ActivityManagerService mActivityManagerService; MemBinder(ActivityManagerService activityManagerService) { mActivityManagerService = activityManagerService; } @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { if (mActivityManagerService.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) { pw.println(&quot;Permission Denial: can't dump meminfo from from pid=&quot; + Binder.getCallingPid() + &quot;, uid=&quot; + Binder.getCallingUid() + &quot; without permission &quot; + android.Manifest.permission.DUMP); return; } mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, &quot; &quot;, args, false, null); } } 查看源码，我们可以发现MemBinder类继承于Binder类也就是说其实一个Binder类型的服务，并且有一个成员方法dump，该方法主要用于执行shell命令，当系统可用内存比较低的时候就会执行了该方法，然后回调到ActivityManagerService中的killAllBackground方法，下面我们重点看一下killAllBackground方法的具体实现： 123456789@Override public void killAllBackgroundProcesses() { ... doLowMemReportIfNeededLocked(null); ... } finally { Binder.restoreCallingIdentity(callingId); } } 可以看到这个方法体中会执行doLowMemReportIfNeededLocked方法，该方法是做什么的呢?我们继续看一下doLowMemReportIfNeededLoced方法的实现： 12345final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) { ... scheduleAppGcsLocked(); ... } 好吧，在这个方法中我们又调用了scheduleAppGcsLocked方法，这样我们就继续看一下scheduleAppGcsLocked方法的实现逻辑： 12345678910111213141516171819/** * Schedule the execution of all pending app GCs. */ final void scheduleAppGcsLocked() { mHandler.removeMessages(GC_BACKGROUND_PROCESSES_MSG); if (mProcessesToGc.size() &gt; 0) { // Schedule a GC for the time to the next process. ProcessRecord proc = mProcessesToGc.get(0); Message msg = mHandler.obtainMessage(GC_BACKGROUND_PROCESSES_MSG); long when = proc.lastRequestedGc + GC_MIN_INTERVAL; long now = SystemClock.uptimeMillis(); if (when &lt; (now+GC_TIMEOUT)) { when = now + GC_TIMEOUT; } mHandler.sendMessageAtTime(msg, when); } } 可以发现这里执行的逻辑就是通过mHandler发送一个msg.what为GC_BACKGROUND_PROCESSES_MSG的异步消息，这样消息体最终会被mHandler的handleMessage方法所执行，继续看一下mHandler的handleMessage方法的执行逻辑： 12345case GC_BACKGROUND_PROCESSES_MSG: { synchronized (ActivityManagerService.this) { performAppGcsIfAppropriateLocked(); } } break; 在mHandler的handleMessage方法中，首先会判断msg的what是否为GC_BACKGROUND_PROCESSES_MSG，然后会执行performAppGcsIfAppropriateLocked方法，这样我们继续看一下performAppGcsIfAppropriateLocked方法的实现： 1234567891011/** * If all looks good, perform GCs on all processes waiting for them. */ final void performAppGcsIfAppropriateLocked() { if (canGcNowLocked()) { performAppGcsLocked(); return; } // Still not idle, wait some more. scheduleAppGcsLocked(); } 可以发现这里首先判断是否能够执行gc操作，若不能继续执行上面的scheduleAppGcsLocked方法，然后继续执行发送异步消息的逻辑，直到变量canGcNowLocked为true，并执行performAppGcsLocked方法，然后return掉，这样我们继续跟踪代码，看一下performAppGcsLocked方法的执行逻辑： 1234567891011121314151617181920212223242526272829303132/** * Perform GCs on all processes that are waiting for it, but only * if things are idle. */ final void performAppGcsLocked() { final int N = mProcessesToGc.size(); if (N &lt;= 0) { return; } if (canGcNowLocked()) { while (mProcessesToGc.size() &gt; 0) { ProcessRecord proc = mProcessesToGc.remove(0); if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory) { if ((proc.lastRequestedGc+GC_MIN_INTERVAL) &lt;= SystemClock.uptimeMillis()) { // To avoid spamming the system, we will GC processes one // at a time, waiting a few seconds between each. performAppGcLocked(proc); scheduleAppGcsLocked(); return; } else { // It hasn't been long enough since we last GCed this // process... put it in the list to wait for its time. addProcessToGcListLocked(proc); break; } } } scheduleAppGcsLocked(); } } 可以发现该方法经过一系列的逻辑判断之后会执行performAppGcLocked方法，我们继续看一下该方法的实现： 123456789101112131415161718/** * Ask a given process to GC right now. */ final void performAppGcLocked(ProcessRecord app) { try { app.lastRequestedGc = SystemClock.uptimeMillis(); if (app.thread != null) { if (app.reportLowMemory) { app.reportLowMemory = false; app.thread.scheduleLowMemory(); } else { app.thread.processInBackground(); } } } catch (Exception e) { // whatever. } } 可以发现最终执行的是app.thread.scheduleLowMemory方法，而这里的app.thread是ActivityThread.ApplicationThread对象，所以这里最终是通过Binder进程间通讯，执行的是ActivityThread.ApplicationThread的scheduleLowMemory方法，好吧让我们看一下ActivityThread.ApplicationThread的scheduleLowMemory方法的实现逻辑… 1234@Override public void scheduleLowMemory() { sendMessage(H.LOW_MEMORY, null); } 在ActivityThread中的scheduleLowMemory方法中并没有执行额外逻辑，而是直接调用了sendMessage方法，继续跟踪方法的执行： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现在sendMessage方法中最终通过一个Handler类型的mH成员变量发送一个异步消息，这样异步消息最终会被mH的handleMessage方法执行。。。。，经过查看源代码我们知道在mH的handleMessage方法中最终调用的是handleLowMemory方法： 12345678910111213141516171819202122final void handleLowMemory() { ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(true, null); final int N = callbacks.size(); for (int i=0; i&lt;N; i++) { callbacks.get(i).onLowMemory(); } // Ask SQLite to free up as much memory as it can, mostly from its page caches. if (Process.myUid() != Process.SYSTEM_UID) { int sqliteReleased = SQLiteDatabase.releaseMemory(); EventLog.writeEvent(SQLITE_MEM_RELEASED_EVENT_LOG_TAG, sqliteReleased); } // Ask graphics to free up as much as possible (font/image caches) Canvas.freeCaches(); // Ask text layout engine to free also as much as possible Canvas.freeTextLayoutCaches(); BinderInternal.forceGc(&quot;mem&quot;); } 可以发现这里通过遍历ComponentCallbacks2并执行了其onLowMemory方法，那么这里的ComponentCallBacks2是什么呢？这里我们查看一下collectComponentCallbacks方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ArrayList&lt;ComponentCallbacks2&gt; collectComponentCallbacks( boolean allActivities, Configuration newConfig) { ArrayList&lt;ComponentCallbacks2&gt; callbacks = new ArrayList&lt;ComponentCallbacks2&gt;(); synchronized (mResourcesManager) { final int NAPP = mAllApplications.size(); for (int i=0; i&lt;NAPP; i++) { callbacks.add(mAllApplications.get(i)); } final int NACT = mActivities.size(); for (int i=0; i&lt;NACT; i++) { ActivityClientRecord ar = mActivities.valueAt(i); Activity a = ar.activity; if (a != null) { Configuration thisConfig = applyConfigCompatMainThread( mCurDefaultDisplayDpi, newConfig, ar.packageInfo.getCompatibilityInfo()); if (!ar.activity.mFinished &amp;&amp; (allActivities || !ar.paused)) { // If the activity is currently resumed, its configuration // needs to change right now. callbacks.add(a); } else if (thisConfig != null) { // Otherwise, we will tell it about the change // the next time it is resumed or shown. Note that // the activity manager may, before then, decide the // activity needs to be destroyed to handle its new // configuration. if (DEBUG_CONFIGURATION) { Slog.v(TAG, &quot;Setting activity &quot; + ar.activityInfo.name + &quot; newConfig=&quot; + thisConfig); } ar.newConfig = thisConfig; } } } final int NSVC = mServices.size(); for (int i=0; i&lt;NSVC; i++) { callbacks.add(mServices.valueAt(i)); } } synchronized (mProviderMap) { final int NPRV = mLocalProviders.size(); for (int i=0; i&lt;NPRV; i++) { callbacks.add(mLocalProviders.valueAt(i).mLocalProvider); } } return callbacks; } 可以发现该方法最终返回类型为ArrayList类型的callBacks而我们的callBacks中保存的是我们应用进程中的Activity，Service，Provider已经Application等。咦？Activity，Service，Provider，Application都是ComponentCallBacks2类型的么？我们看一看一下具体的定义： Actvity的类定义： 12345public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback Service的类定义： 1public abstract class Service extends ContextWrapper implements ComponentCallbacks2 ContentProvider的类定义： 1public abstract class ContentProvider implements ComponentCallbacks2 Application的类定义： 1public class Application extends ContextWrapper implements ComponentCallbacks2 可以发现其都是继承与ComponentCalbacks2，所以其都可以被当做是ComponentCallbacks2类型的变量。而同样是四大组件的BroadcastReceiver，我们可以下其类定义： 1public abstract class BroadcastReceiver 可以看到其并未继承与ComponentCallbacks2，所以并未执行，所以通过这样的分析，我们知道了，最终应用程序中的Activity，Servier，ContentProvider，Application的onLowMemory方法会被执行。而由于我们是在系统内存紧张的时候会执行killAllBackground方法进而通过层层条用执行Activity、Service、ContentProvider、Application的onLowMemory方法，所以我们可以在这些组件的onLowMemory方法中执行了一些清理资源的操作，释放一些内存，尽量保证自身的应用进程不被杀死。 总结： 系统在JNI层会时时检测内存变量，当内存过低时会通过kiilbackground的方法清理后台进程。 经过层层的调用过程最终会执行Activity、Service、ContentProvider、Application的onLowMemory方法。 可以在组件的onLowMemory方法中执行一些清理资源的操作，释放内存防止进程被杀死。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机","link":"/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"onSaveInstanceState执行时机","text":"我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍： This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}. 可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。 通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。 Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考: android源码解析之（十四）–&gt;Activity启动流程，文章中有对Activity生命周期的详细讲解。 好吧，先具体看一下ActivityThread.handlePauseActivity的源码： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; } 可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { callCallActivityOnSaveInstanceState(r); } ... } 可以发现，这里调用了callCallActivityOnSaveInstanceState方法，看名称可以发现这里应该回调的是Activity的onSaveInstanceState方法，但是这里执行之前有一个条件判断，首先会判断这里的Activity是否被finish？应为这时候刚刚执行onPause方法所以这里的mFinished变量为false，所以判断执行callCallActivityOnSaveInstanceState方法只要需要通过saveState变量来判断了，而这里的saveState方法是performPauseActivity方法传递过来的。。。。好吧，我们来看一下调用performPauseActivity方法时saveState变量是如何赋值的。回到我们的handlePauseActivity方法，看一下performPauseActivity方法是如何调用的： 1performPauseActivity(token, finished, r.isPreHoneycomb()); 可以发现saveState boolean变量是通过r.isPreHoneycomb方法赋值的，这里我们看一下IsPreHoneycomb方法是如何实现的： 1234567public boolean isPreHoneycomb() { if (activity != null) { return activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB; } return false; } 可以发现当我们的App设置的targetSdk版本号小于android versionCode 11也就是android3.0的时候返回为true，其他的时候返回为false，也就是说当我们App设置的targetVersion大于android3.0的时候才会执行callCallActivityOnSaveInstanceState方法，好吧，继续看一下callCallActivityOnSaveInstanceState方法是如何实现的： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 可以发现方法体主要调用了mInstrumentation的callActivityOnSaveInstanceState方法，既然这样，我们再来看一下callActivityOnSaveInstanceState方法： 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 这里方法体中又回调了Activity的performSaveInstanceState方法。。。 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 可以看到这里回调了Activity的onSaveInstanceState方法，这样经过一系列的方法回调之后我们就执行了onSaveInstanceState方法。 这样我们当只执行onPause方法的时候一般通过设置targetVersion控制是否执行onSaveInstanceState方法，当设置的targetVersionCode大于android3.0的时候默认不会执行onSaveInstanceState方法。 然后我们看一下当Activity执行onStop方法的时候是否会执行onSaveInstanceState方法，通过之前分析的Activity的启动流程，我们知道Actvitiy执行onStop方法会回调ActivityThread的handleStopActivity，这样我们先看一下handleStopActivity方法的实现： 12345678910111213141516171819private void handleStopActivity(IBinder token, boolean show, int configChanges) { ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; StopInfo info = new StopInfo(); performStopActivityInner(r, info, show, true); if (localLOGV) Slog.v( TAG, &quot;Finishing stop of &quot; + r + &quot;: show=&quot; + show + &quot; win=&quot; + r.window); updateVisibility(r, show); info.activity = r; info.state = r.state; info.persistentState = r.persistentState; mH.post(info); mSomeActivitiesChanged = true; } 然后我们发现在方法performStopActivity方法中调用了performStopActivityInner方法，我们继续看一下performStopActivityInner方法的实现： 12345678910private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } ... } 可以发现还是通过saveState变量来控制是否调用onSaveInstanceState，而这里的saveState变量是在performStopActivityInner方法调用的时候传递的，回到我们的handleStopActivity方法中关于performStopActivityInner调用的代码： 1performStopActivityInner(r, info, show, true); 好吧，这里直接传值为true，这样我们执行Activity的stop方法一定执行onSaveInstanceState方法。 总结 onSaveInstanceState方法是Activity的生命周期方法，主要用于在Activity销毁时保存一些信息。 当Activity只执行onPause方法时（Activity a打开一个透明Activity b）这时候如果App设置的targetVersion大于android3.0则不会执行onSaveInstanceState方法。 当Activity执行onStop方法时，通过分析源码我们知道调用onSaveInstanceState的方法直接传值为true，所以都会执行onSaveInstanceState方法。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程","link":"/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"},{"title":"Windows 10激活码","text":"Windows 10 各版本区别 S版：简化版系统，专为教育市场打造，只能使用微软应用商店的应用，无法运行 exe 程序 家庭版：供家庭用户使用，无法加入 Active Directory 和 Azure AD，不允许远程链接；家庭中文版和单语言版是针对OEM设备的，是家庭版下的2个分支 专业版：供小型企业使用，在家庭版基础上增加了域账号加入、bitlocker、企业商店等功能 企业版：供中大型企业使用，在专业版基础上增加了 DirectAccess，AppLocker 等高级企业功能 教育版：供学校使用 (学校职员、管理人员、老师和学生) 其功能几乎和企业版一样，针对学校授权而已 产品密钥// 这些是产品安装秘钥不是激活秘钥!Windows 10 专业版 VK7JG-NPHTM-C97JM-9MPGT-3V66TWindows 10 专业版VL版 W269N-WFGWX-YVC9B-4J6C9-T83GXWindows 10 企业版 XGVPP-NMH47-7TTHJ-W3FW7-8HV2CWindows 10 企业版VL版 NPPR9-FWDCX-D2C8J-H872K-2YT43Windows 10 教育版 YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBYWindows 10 教育版VL版 NW6C2-QMPVW-D7KKK-3GKT6-VCFB2Windows 10 家庭版 YTMG3-N6DKC-DKB77-7M9GH-8HVX7Windows 10 家庭中文版 N2434-X9D7W-8PF6X-8DV9T-8TYMDWindows 10 专业教育版 8PTT6-RNW4C-6V7J2-C2D3X-MHBPBWindows 10 专业工作站版 DXG7C-N36C4-C4HTG-X4T3X-2YV77Windows 10 专业仅中文版 HNGCC-Y38KG-QVK8D-WMWRK-X86VKWindows 10 专业单语言版 G3KNM-CHG6T-R36X3-9QDG6-8M8K9Windows 10 家庭单语言版 BT79Q-G7N6G-PGBYW-4YWX6-6F4BTWindows 10 远程服务器版 NJCF7-PW8QT-3324D-688JX-2YV66其他版本所有产品密钥请查阅 https://pastebin.com/raw/gVmc5S9c 手动KMS激活命令：管理员身份运行CMD（命令提示符）slmgr /upk slmgr /ipk XXXXX-XXXXX-XXXXX-XXXXX-XXXXXslmgr /skms kms.03k.orgslmgr /atoslmgr.vbs -dlv 激活说明 1、推荐使用激活方法使用KMS 180天激活、激活工具、神龙激活、KMSAuto Net、KMSpico、HEU_KMS_Activator 2、推荐使用Win10 数字权利永久激活工具、HWIDGe、数字权利激活自动批处理版、W10数字许可激活C#版 命令查看Win10等详细激活信息方法 Win+R 输入： slmgr.vbs -dlv 显示：最为详尽的激活信息，包括：激活ID、安装ID、激活截止日期 slmgr.vbs -dli 显示：操作系统版本、部分产品密钥、许可证状态 slmgr.vbs -xpr 显示：是否永久激活 下载说明 推荐大家使用专业版或者企业版，磁力链接可以使用迅雷下载，也可以使用百度网盘进行离线下载； 注：家庭版，供家庭用户使用，无法加入 Active Directory 和 Azure AD，不允许远程链接，家庭中文版和单语言版是针对OEM设备的，是家庭版下的2个分支；专业版，供小型企业使用，在家庭版基础上增加了域账号加入、bitlocker、企业商店等功能；企业版，供中大型企业使用，在专业版基础上增加了 DirectAccess，AppLocker 等高级企业功能；教育版，供学校使用 (学校职员、管理人员、老师和学生) 其功能几乎和企业版一样针对学校授权 激活推荐使用知彼而知己数字许可证激活工具 HEU KMS Activator 下载地址 天翼云盘：https://cloud.189.cn/t/zUjqmiqiiiQj (访问码:lcr3) 百度网盘：https://pan.baidu.com/s/1jGyLKD9fTcCUJgJfyGspbg 提取码: tny3 **Windows 10 VB-20H2 官方 MVS (MSDN) 初始镜像 2021年1月更新 – 19042.746** 123456789101112131415版本名称：Windows 10 20H1 business x64 商业版（教育版、企业版、专业版、专业教育版、专业工作站版等）推荐文件名称：cn_windows_10_business_editions_version_20h2_updated_jan_2021_x64_dvd_b6eb1ee6.isoSHA-1值: AB9B0CAD001FF218AC5DF17BAB973116CC7B418B4D45F3757F2A3F865F8125F7文件大小：5.61GB发布时间：2021-1-24下载地址：ed2k://|file|cn_windows_10_business_editions_version_20h2_updated_jan_2021_x64_dvd_bee6.iso下载说明：此地址为ed2k协议需要使用迅雷下载才能下载此镜像文件网盘失效：教你一招复制上面的ed2k下载地址使用百度网盘离线下载一下秒保存自己网盘","link":"/2022/08/06/window10/"},{"title":"中国近代史主观题","text":"1.中国封建社会的基本特点： 1)在经济上，封建土地所有制占主导地位； 2)在政治上，实行高度中央集权的封建君主专制制度； 3)在文化上，以儒家思想为核心； 4)在社会结构上，是族权和政权相结合的封建宗法等级制度。 2.中国封建社会由盛转衰的主要表现: 1)政治上，中央集权进一步强化，官僚职能扩大； 2)经济上，人口大增长、各级官吏和地主大肆兼并土地，广大农民生活日渐困苦； 3)思想文化上，厉行专制主义，大兴文字狱； 4)军事上，军力衰败，军备废弛； 5)对外关系上，实行闭关锁国政策，严格限制对外贸易，使中国处于与世隔绝的状态。 3.近代中国半殖民地半封建社会的特点： 1)资本－帝国主义日益成为支配中国的决定性力量。 2)中国的封建势力同外国侵略势力相勾结。 3)中国自然经济的基础虽然遭到破坏，但是封建地主的土地所有制依然存在。 4)中国资本主义有所发展，但没有成为中国社会经济的主体。 5)近代中国各地区经济、政治和文化发展是极不平衡的。 4.近代中国社会的主要矛盾及其影响？（过） 1)帝国主义和中华民族的矛盾，封建社会和人民大众的矛盾，帝国主义和中华民族的矛盾是主要矛盾； 2)两对主要矛盾相互交织在一起，贯穿了整个半殖民地半封建社会的始终，对中国社会的发展变化起这决定性作用； 相互关系： 1)当外国列强向中国发动侵略战争时，阶级矛盾降到次要地位，民族矛盾上升到主要地位； 2)当外国侵略者同中国封建政权相勾结，共同镇压中国革命，尤其是封建地主阶级对人民的压迫特别残酷时，阶级矛盾上升为主要矛盾； 5.近代以来中华民族面临的历史任务？（过） 两大历史任务： 1)一是求得民族独立和人民解放； 2)二是实现国家繁荣富强和人民共同富裕； 相互区别： 1)前者要从根本上推翻中国半殖民地半封建社会的统治秩序，着重解决生产关系问题； 2)后者要改变近代中国经济、文化和社会落后的地位和状况，是要充分发展近代民族工商业，着重解决生产力问题； 相互联系： 1)只有完成第一大任务，才能为第二大任务的完成创造条件。 2)争取民族独立和人民解放是实现国家繁荣富强和人民共同富裕的前提条件。 3)争取民族独立和人民解放的最终目的是使中国走向现代化，实现国家繁 4)荣富强和人民共同富裕，是中国民族自立于世界民族之林； 6.太平天国农民战争的历史意义？（过） 1)它沉重打击了封建统治阶级，强烈撼动了清政府的统治根基； 2)它是中国旧式农民战争的最高峰； 3)它冲击了孔子和儒家经典的正统权威。在一定程度上削弱了封建统治的精神支柱； 4)它有力的打击了外国侵略势力，冲击了西方殖民主义在亚洲的统治； 7.太平天国农民战争失败的主要原因？（过） 1)缺乏先进阶级的领导（根本原因）。农民阶级不是新的生产力和生产关系的代表，带有小生产者所固有的阶级局限性； 2)没有科学理论的指导，它是以拜上帝教来发动、组织群众的，但是拜上帝教教义不是科学的思想理论； 3)对外国资本主义列强缺乏理性的认识，笼统地把信奉上帝的西方人都视为“洋兄弟”； 8.简述太平天国定都天京后，先后颁布的两个重要纲领及其特点？（过） 1)1853年冬颁布《天朝田亩制度》，这是一个以解决农民土地问题为中心的比较完整的社会改革方案，最能体现太平天国社会理想； 2)太平天国后期提出《资政新篇》，这是一个带有鲜明资本主义色彩的改革与建设方案； 9.资产阶级思想与封建主义思想第一次正面交锋是维新派和守旧派的论战（过） 1)要不要变法； 2)要不要兴民权、设议院、实行君主立宪； 3)要不要废八股、改科举和兴学堂； 10.资产阶级革命派同改良派论战的主要内容及重要意义？（过） 1)要不要以革命手段推翻清政府（论战焦点）； 2)要不要推翻帝制，实现共和； 3)要不要社会革命； 重要意义：论战以革命派的胜利告终； 划清了革命与改良的界限； 是资产阶级民主思想和三民主义思想得到了更广泛的传播； 11.近代中国工人阶级的特点？（过） 1)深受帝国主义、封建势力和资产阶级三重压迫和剥削，革命性最强； 2)人数虽少，但相对集中，便于形成革命的力量和传播先进的思想； 3)主要由破产农民和家庭手工业者转化而来，同农民有着天然关系，便于结成工农联盟； 12.洋务运动的历史作用？（过） 1)促进了中国早期工业和民族资本主义的发展； 2)开辟了一批新式学堂，派出了最早的留学生，成为中国近代教育的开端； 3)传播了新知识，打开了人们的眼界； 4)引起了社会风气和价值观念的改变； 13.洋务运动失败的主要原因？（过） 1)洋务运动具有封建性； 2)洋务运动对西方列强具有依赖性，企图仰仗西方列强来达到“求强”、“求富”的目的； 3)洋务企业的管理具有腐朽性，对企业采取的是封建衙门式的管理方法； 4)洋务运动的指导思想是“中学为体，西学为用”，只注重西法练兵和办企业，而不去改变落后的政治制度； 14.洋务运动的指导思想和举办的洋务事业是什么？（过） 1)洋务运动的指导思想是“中学为体，西学为用”。 2)兴办近代企业，最早兴办的是军用工业，70年代开始兴办民用企业； 3)建立新式海陆军； 4)创办新式学堂、派遣留学生； 15.戊戌变法的意义：（过） 1)是一次具有爱国救亡意义的变法维新运动， 2)是一场资产阶级性质的的政治改革，也是一次思想启蒙运动， 3)这次变法促进了思想解放，并且对思想文化的发展和促进中国近代社会的进步起了重要推动作用。 16.戊戌失败原因：（过） 根本原因 资产阶级维新派力量过于弱小，即资产阶级的软弱性； 直接原因 1)缺乏正确的理论指导； 2)缺乏坚强的组织领导； 3)脱离广大人民群众，只寄希望于没有实权的皇帝和极少数的官僚； 4)对帝国主义抱有不切实际的幻想； 17.戊戌变法的主要内容： 1)改革政府机构，裁撤冗官，任用维新人士； 2)鼓励私人兴办工矿企业； 3)开办新式学堂吸引人才，翻译西方书籍，传播新思想； 4)创办报刊，开放言论； 5)训练新式陆军海军同时规定，科举考试废除八股文，取消多余的衙门和无用的官职； 18.辛亥革命的历史意义？（过） 1)推翻了清王朝，结束了中国数千年的君主专制统治； 2)创建了中华民国； 3)颁布了中国历史上第一部具有资产阶级共和国宪法性质的《临时约法》，使人民获得了一些民主权利； 4)开创了完全意义上的近代民族民主革命； 5)给中国先进分子以巨大的刺激和深刻的启发，使他们觉悟到必须另谋新的救国救民之路。 19.辛亥革命的历史局限性是什么？（过） 1)没有提出彻底的反对帝国主义和反封建主义的革命纲领； 2)没有充分发动和依靠民众； 3)没有建立坚强的革命政党； 20.新文化运动的历史意义？（过） 1)它是资产阶级民主主义的新文化同封建主义旧文化的斗争，是辛亥革命的思想文化领域的延续，沉重打击了封建专制主义； 2)它大力宣传了民主和科学，启发了人民的理智和民主主义觉悟，将人们从封建专制所造成的蒙昧中解放出来，开启了思想解放的潮流； 3)它为中国先进分子接受马克思主义做了准备，为以五四运动为开端的中国新民主主义革命创造了思想文化上的条件； 21.简述孙中山三民主义学说的主要内容及其意义？ 1)民主主义，包括“驱除鞑虏，恢复中华”。一是以革命手段推翻清王朝，二是变“次殖民地”的中国为独立的中国； 2)民权主义，“创立民国”，指推翻封建君主专制制度，建立资产阶级民主共和国； 3)民生主义，“平均地权”，基本方案是：核定地价，按价征税，涨价归公，按价售卖； 意义： 这是一个比较完备的民主主义的革命纲领，推动了革命思想的传播和革命运动的发展； 22.五四运动的历史特点及意义？（过） 1)是中国近代史上一次彻底反帝国反封建的革命运动； 2)是一场真正群众性的革命运动； 3)促进了马克思主义在中国的广泛传播，促进马克思主义同中国工人运动的结合； 4)五四运动是中国新民主主义革命的开端，无产阶级逐渐替代资产阶级成为近代中国民族民主革命的领导者； 23.八一南昌起义的历史意义是什么？（过） 1)打响了武装反抗国民党反动统治的第一枪， 2)成为了共产党独立领导革命战争、创建人民军队和武装夺取政权的伟大开端； 3)揭开了土地革命战争的序幕； 4)体现了中国共产党人为实行中国人民的根本利益和中国民族的解放事业而前赴后继的革命精神； 24.中国共产党成立的历史意义？（过） 1)它标志着中国革命终于有了一个坚强的领导核心，有了可依赖的组织者和领导者； 2)中国革命从此有了科学的指导思想，中国共产党以马克思列宁主义基本原理观察和分析中国的问题，为中国指明了斗争目标、革命前途和胜利之路； 3)它沟通了中国革命与世界革命的联系，把中华民族的解放运动同世界无产阶级社会主义革命运动相联结，是中国革命有了新的前途； 4)自从有了中国共产党，中国革命的革命就焕然一新了； 25.秋收起义的意义？（过） 1)第一次公开打出了中国共产党的旗帜，进一步表明了中国共产党独立领导革命战争的决心。 2)首创农村包围城市，武装夺取政权的道路。 3)实行“三湾改编”，确立党对军队的绝对领导。 4)总结了战争“十六字诀”(敌进我退，敌驻我扰，敌疲我打，敌退我追)，成为中国军队战略战术体系的第一块基石。 26.三湾改编的主要内容？（过） 1)将原有的一个师缩编为一个团； 2)在部队中建立共产党各级组织，将党的支部建在连上； 3)成立各级士兵委员会，部队内部实行民主管理； 27.1926年至1927年，北伐战争直接打击的目标和战略方针？ 1)北伐的直接目标是打倒帝国主义支持的北洋军阀：吴佩孚、孙传芳、张作霖； 2)北伐的战略方针：首先进军两湖，消灭吴佩孚，然后引兵东向，消灭孙传芳，最后，北上解决张作霖； 28.八七会议的主要内容是什么？ 1)彻底清算大革命后期陈独秀右倾机会主义错误； 2)确立了土地革命和武装斗争的方针； 3)毛泽东提出了“须知政权是由枪杆子中取得的”重要理论； 4)选出了以瞿秋白为首的中央临时政治局； 29.遵义会议集中解决的主要问题及其意义？(过) 1)遵义会议集中解决了当时具有决定意义的军事和组织问题； 2)开始确立了以毛泽东为代表的马克思主义正确线路在党中央的领导地位； 3)在极其危机的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命； 4)成为中国共产党历史上一个生死攸关的转折点；为党和革命事业转危为安、不断打开新局面提供了最重要的保证； 30.洛川会议指定的《抗日救国十条纲领》的主要内容是什么？ 1)要打倒日本帝国主义，关键在于实行全国军事总动员、全国人民的总动员，使抗战成为全面的全民族的抗战； 2)必须改革政治机构，给人民以充分的抗日民主权利，并适当改善工农大众的生活； 3)必须坚持统一战线中无产阶级的领导权，在敌后放手发动独立自主的山地游击战争，在国统区放手发动抗日的群众运动； 31.井冈山根据地创建的历史意义？(过) 1)它点燃了“工农武装割据”的星星之火，为共产党领导的其他各地的起义武装树立了榜样； 2)它从实践上开辟了一条在敌我力量十分悬殊的情况下，共产党深入农村保存和发展革命力量的正确道路； 32.中国工农红军长征胜利的历史意义？(过) 1)是一部伟大的革命英雄主义史诗； 2)它粉碎了国民党“围剿”红军、消灭革命力量的企图，是中国革命转危为安的关键； 3)通过长征，中国革命的大本营放在了西北，这为迎接中国人民抗日救亡的新高潮准备了条件； 4)保存并锤炼了中国革命的骨干力量，这是党和红军极为宝贵的精华； 5)播撒了革命的火种，它为沿途的人民群众宣布，只有在中国共产党的领导下，中国各族人民才能翻身得解放； 6)中国共产党人和红军将士用生命和热血铸就了伟大的长征精神； 33.中国革命统一战线中的两个联盟及其关系是什么？ 1)一个是劳动者的联盟，主要是工人、农民和城市小资产阶级的联盟，这是最基本的、重要的； 2)一个是劳动者与非劳动者的联盟，主要是劳动者民族资产阶级的联盟，包括一部分大资产阶级的暂时联盟，这是辅助的、重要的； 34.中国共产党在全民族抗战中的中流砥柱作用？ 1)中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。中国共产党自成立之日起就把实现中华民族伟大复兴作为自己的历史使命。 2)在抗日战争中，中国共产党坚持全面抗战路线，制定了正确战略策略，开辟广大敌后战场，成为坚持抗战的中坚力量； 3)中国共产党以自己的政治主张，坚定意志、模范行动，支撑起全民族救亡图存的希望，引领着夺取战争胜利的正确方向。成为夺取战争胜利的民族先锋。 35.中国人民抗日战争胜利的主要原因？(过) 1)以爱国主义为核心的伟大民族精神是中国人民抗日战争胜利的决定因素； 2)中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键； 3)全民族抗战是中国人民抗日战争胜利的主要法宝； 4)世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持，是中国人民抗日战争胜利的国际条件； 36.中国人民抗日战争在世界反法西斯战争中的地位？ 1)中国人民抗日战争是世界反法西斯战争的东方主战场。 中国抗战开始最早，持续时间最长，牵制和抗击了日本军国主义的主要兵力，对日本侵略者的彻底覆灭起到了决定性作用； 2)中国人民的持久抗战，遏制了日本的“北进”计划，迟滞了日本的“南进”步伐，达达减轻了其他战场的压力，为盟国军队完成战略转折和实施战略反攻创造了有利条件； 3)中国作为亚太地区盟军对日作战的重要后方基地，为盟军提供了大量战略物资和军事情报，中国军队出锅作战，不近打击了日本，还对盟军给与了实际支援； 1)中国为战胜法西斯、维护世界和平付出了巨大的牺牲，做出了伟大的贡献； 37.中国共产党抗日民族统一战线的策略总方针是什么？ 1)发展进步势力，进步势力主要指工人、农民和城市小资产阶级； 2)争取中间势力，中间势力主要指民族资产阶级、开明绅士和地方实力派； 3)孤立顽固势力，顽固势力主要指大地主大资产阶级的抗日拍，以蒋介石集团为代表的国民党亲英美派； 38.中国新民主主义革命胜利的基本经验？ 建立广泛的统一战线。这是坚持和发展革命的政治基础。 统一战线中存在着两个联盟：一个是劳动者的联盟，一个是劳动者与非劳动者的联盟，必须坚持依靠第一个联盟，争取建立和夸大第二个联盟； 坚持革命的武装斗争，中国革命只能以长期的武装斗争作为主要形式： 中国革命必须走农村包围城市、武装夺取政权的道路；必须建立一直党绝对领导下的新式人民军队； 加强共产党自身的建设，着重从思想上建党：培育和发扬理论与实际相结合、密切联系群众和自我批评的作风； 成为统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的英勇战士，成为中国各族人民拥戴的领导核心； 39.新民主主义社会的五种经济成分及特点？ 1)社会主义性质的国营经济； 2)半社会主义性质的合作社经济； 3)农民和手工业者的个体经济； 4)私人资本主义经济； 5)国家资本主义经济； 特点：既有社会主义因素，又有资本主义因素，本身具有过渡性； 40.在《论持久战》一文中，毛泽东如何阐述抗日战争是持久战，最后胜利属于中国？ 1)中日双发存在着相互矛盾的四个特点：敌强我弱，敌小我大，敌退步我进步，敌寡助我多助； 2)一方面，日本是强国，中国是弱国，强国弱国的对比，决定了抗日战争只能是持久战； 3)一方面，日本是效果，发动的事退步的、野蛮的侵略战争，在国际上失道寡助；而中国是大国，进行的是进步的、正义的反侵略战争，国际上得道多助； 4)中国已经有了代表中华民族和中国人民根本利益的共产党及其领导的人民军队和抗日根据地。因此，最后胜利是中国的； 41.毛泽东在《论持久战》中对抗日战争历史进程的阐述。 1)中国抗日战争将经过战略防御、战略相持、战略反攻三个阶段； 2)战略相持阶段，时中国抗日战争取得最后胜利的最关键的阶段； 3)只要坚持持久抗战、坚持抗日民族统一战线，中国将在这个阶段获得转弱为强的力量； 42.简述中国新民主主义革命取得胜利的主要原因？ 1)一是有了中国工人阶级的先锋队，中国共产党的领导。它以马克思列宁主义基本原理与中国实际相结合的毛泽东思想作为一切工作的指针，制定出符合中国国情和人民利益的纲领、路线、方针和政策；他具有远见，最富有牺牲精神，最坚定，从而赢得了中国人民的衷心拥护； 2)二是人民群众和各界人士的广泛参加和大力支持。工人、农民、城市小资产阶级群众是民主革命的主要力量；随着斗争的发展，民族资产阶级也逐步向共产党靠拢； 3)三是国际无产阶级和人民群众的支持； 43.中国共产党在过渡时期总路线的内容及其特点？ 1)要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、手工业和对资本主义工商业的社会主义改造； 2)这是社会主义建设同社会主义改造同时并举的总路线，体现了生产力和变革生产关系的有机统一； 44.全国解放战争时期，各民主党派与中国共产党团结合作的重要表现？ 1)在重庆谈判和政协会议期间，各民主党派作为“第三方面”，同共产党一起反对国民党反动派的内战、独裁政策，为和平民主二共同努力； 2)在国民党当局撕毁政协协议、发面全面内战后，民主党派中的大多数同共产党保持一致，拒绝参加国民党一手包办的“国民大会”、反对国民党炮制的“宪法”； 45.毛泽东提出的社会主义现代化建设的战略目标和步骤？ 1)社会主义现代化建设的战略目标：把中国建设成为一个具有现代农业、现代工业、现代国防和现代科学强国。 2)社会主义现代化建设的步骤：采取“两步走”的发展战略， 第一步，建立一个独立的比较完整的工业体系和国民经济体系； 第二步，全面实现农业、工业、国防和科学技术的现代化，是中国的经济走向世界前列； 46.新中国建立初期中国共产党面临的主要问题和考验？ 1)能不能保卫住人民胜利的成果，巩固新生的人民政权； 2)能不能战胜严重的经济困难，迅速恢复和发展国民经济； 3)能不能巩固民族独立，维护国家主权和安全。 4)能不能经受住执政的考验，继续保持谦虚、谨慎、不骄、不躁的作风和艰苦奋斗的作风。 47.七大召开 大会提出党的政治路线是： 1)放手发动群众，壮大人民力量，在党的领导下，打败日本侵略者，解放全国人民，建立一个新民主主义的中国。 2)大会强调毛泽东思想为全党的指导思想。 3)大会通过的新党章强调了群众路线和党的民主集中制原则。 4)这次大会是团结的大会，胜利的大会，为抗日战争和夺取新民主主义革命在全国的胜利奠定了基础。 48.毛泽东发表《论十大关系》一文的意义？ 1)它是以毛泽东为主要代表的中国共产党人开始探索中国自己的社会主义建设道路的标志； 2)从经济和政治方面提出了新的指导方针，为中共八大（1956年）的召开做了理论准备； 49.四个现代化？ 农业现代化、工业现代化、国防现代化、科学技术现代化 50.简述1979年3月，邓小平提出的四项基本原则及坚持这些原则的重要性？ 坚持社会主义道路，坚持人民民主专政，坚持共产党领导，坚持马克思列宁主义、毛泽东思想； 这是实现四个现代化的根本气体，如果动摇了其中的任何一项，也就动摇了整个社会主义现代化建设事业； 51.简述毛泽东等老一代革命家探索中国社会主义民主政治建设道路的理论贡献？ 1)要造成一个又有集中又有民权，又有纪律又有自由，又有统一意志，又有个人心情舒畅、生动活泼的政治局面； 2)把正确处理人民内部矛盾作为国家政治生活的主题，坚持人民民主，团结一切可以团结的力量； 3)处理好中国共产党同各民主党派的关系，坚持长期共存、互相监督的方针，巩固和扩大爱国统一战线； 4)切实保障人民当家做主的各项权利，尤其是人民参与国家和社会事务管理的权利； 5)社会主义法制要保护劳动人民利益，保护社会主义经济基础，保护社会主义生产力； 52.中共八大如何分析我国社会主义改造完成后国内的矛盾和主要任务？ 主要矛盾： 1)是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾； 2)是人民对于经济文化迅速发展需要同当前经济文化不能满足人民需要的状况之间的矛盾； 主要任务： 当合全国人民的主要任务是集中力量来解决这个矛盾，把我国尽快从落后的农业国变成先进的工业国； 53.中共八大提出的我国经济建设和政治建设的指导方针时什么？ 1)在经济建设上，大会坚持既反保守又反冒进，即在综合平衡中稳步前进的方针； 2)在政治建设上，大会要求继续加强我国的人民民主专政，加强国内各民族的团结，继续巩固人民民主统一战线，逐步指定完善的法律，建立健全的法制； 54.社会主义改造基本完成的意义？ 1)社会主义改造的基本完成，使社会主义基本经济制度在中国全面地建立起来了，是中国进入社会主义社会的最重要的标志； 2)社会主义改造是在生产关系方面由私有制到公有制的一场伟大的变革，对生产力的发展支持起到了促进作用； 3)通过社会主义改造，中国共产党领导全国各族人民创造性地完成了由新民主主义到社会主义的过渡，实现了中国历史上最深刻的社会制度； 55.中国经历的三次历史性巨变？ 1)第一次是辛亥革命，推翻通知中国几千年的君主专制制度； 2)第二次是中华人民共和国的成立和社会主义制度的建立； 3)第三次是改革开放，为实现社会主义现代化而奋斗； 56.我国农村社会主义改造的过渡性经济组织形式以及其性质是什么？ 1)第一是互助组，这是具有社会主义萌芽性质的经济组织； 2)第二是初级农业生产合作社，这是具有半社会主义性质的经济组织； 3)第三是高级农村生产合作社，这是具有社会主义性质的经济组织； 57.“三个主体，三个补充”的内容是什么？ 1)国家经营和集体经营为主体，一定数量的个体经营为补充； 2)计划生产是主体，一定范围的自由生产为补充； 3)国家市场是主题，一定范围的自由市场为补充； 58.中共十三大指定的社会主义现代化建设“三步走”的战略部署是什么？ 1)第一步，实现国民生产总值比1980年翻一番，解决人民的温饱问题； 2)第二步，到20世纪末，使国民生产总值再增长一倍，人民生产达到小康水平； 3)第三步，到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化； 60.一二九运动及其历史意义是什么？ 1)1935年12月9日，在中国共产党救亡图存、全民抗战的号召和中共北平临时工作委员会的领导下，北平学生举行声势浩大的抗日游戏，遭到国民党军警镇压。 2)一二九运动打击了日本帝国主义侵略中国并吞并华北的计划，促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。 61.中国共产党第十八次全国代表大会关于中国特色社会主义的阐述： 总依据：社会主义初级阶段； 总布局：经济、政治、文化、社会、生态文明建设五位一体； 总任务：实现社会主义现代化和中华民族伟大复兴； 62.简述统筹推进“五位一体”总体布局的内容？ 1)主动适应和引领经济发展新常态； 2)发展社会主义民主政治； 3)发展中国特色社会主义文化； 4)在发展中保障和改善民生； 5)建设美丽中国； 63.简述党和国家在发展中保障和改善民生的具体布局？ 1)不断促进教育发展成功更多更公平惠及全体人民； 1)促进社会公平正义，让广大人民群众共享改革发展成果； 1)多渠道创造就业机会； 1)坚持全覆盖、保基本、多层次、可持续发展，加强城乡社会保障体系建设； 5)加快推进健康中国建设； 6)加强和创新社会治理，完善中国特色社会主义社会治理体系； 64.简述协调推进“四个全面”战略布局的内容？ 1)推进全面深化改革； 2)推进全面依法治国； 3)推进全面建成小康社会； 4)推进全面从严治党； 65.中共十八大后五年来党和国家事业取得了历史性成就、发生了历史性变革，简述其带来的深刻启示？ 1)必须始终坚持全党的理论创新成果武装头脑、指导实践； 2)必须始终维持党中央和全党的核心； 3)必须始终坚持和加强党的全面领导； 66.简述“红船精神”的内容。 1.开天辟地、敢为人先的首创精神； 2.坚定理想、百折不挠的奋斗精神； 3.立党为公、忠臣人民的风险精神； 67.试述改革开放40年来社会主义文化建设的成效。 1.党的理论创新全面推进，中国特色社会主义和中国梦深入人心； 2.加强党对意识形态工作的领导，马克思主义在意识形态领域的指导地位最为鲜明，社会主义核心价值观和中华优秀传统文化广泛弘扬，群众性精神文化创建活动扎实开展； 3.文化事业和文化产业蓬勃发展，文化体制改革不断深入； 4.促进公共文化服务体系建设，公共文化服务水平不断提高； 5.文艺创作持续繁荣，互联网建设管理运用不断完善，全民健身和竞技体育全面发展； 68.1978年关于真理准备问题大讨论的是历史意义？ 1)冲破了“两个凡是”的思想束缚，是一场马克思主义的思想解放运动，成为了拨乱反正和改革开放的思想指导； 2)为党重新确立实事求是的思想路线，纠正长期以来的“左”倾错误，实现历史性的转折做了思想理论准备； 69.简述关于“真理标准问题的大讨论”？ 1)1978年5月11日，《光明日报》发表题为《实践是检验真理的唯一标准》的特邀评论员文章，在全国开始了关于真理标准问题的大讨论； 2)这个评论冲破了“两个凡是”的思想束缚，自始至终得到邓小平、叶剑英、陈云、李先念、胡耀邦等的全力支持； 3)关于真理标准问题的大讨论，是继延安整份之后又一场马克思主义思想解放运动，成为拨乱反正和改革开放的思想先导，为党重新确立实事求是的思想路线， 纠正长期以来的“左倾”错误，实现历史性的转折做了思想理论准备； 70.中共十一届三中全会公报对中国的主要矛盾和主要任务的分析是什么？ 1)大规模的急风暴雨式的群众阶级斗争已经基本结束，对于社会主义社会的阶级斗争，应该按照严格区别和正确处理两类不同性质的矛盾的方针解决， 决不允许混淆两类不同性质矛盾的界限，决不允许损害社会主义现代化建设所需要的安定团结的政治局面； 2)实现四个现代化，要求大幅度地提高生产力，也就必然要求多方面地改变同生产力发展不适应的生产关系和上层建筑，改变一切不适应的管理方式、 活动方式和思想方式，因而是一场深刻的革命； 71.中共十一届三中全会作出的一系列重大决策是什么？ 1)鉴于中国范围的大规模的揭批林彪“四人帮”的群众活动已经基本上胜利完成，全党工作的着重点已经转移到社会主义现代化建设上来； 2)为了适应社会主义现代化建设的需要，全会决定在党的生活和国家政治生活中加强民主，明确党的思想路线，加强党的领导机构和成立中央纪律检查委员会。 3)从现在起，应当把立法工作摆到全国人民代表大会及其常务委员会的重要议程上来； 4)为了保障人民民主，必须加强社会主义法制，使民主制度化、法律化、使这种制度和法律具有稳定性、连续性和极大的权威， 做到有法可依，有法必依，执法必严，违法必究； 72.中国十一届六中全会通过的“第二个历史决议”的主要内容及建议？ 1)决议科学的评价了毛泽东和毛泽东思想的历史地位，支持毛泽东的功绩是第一位的，错误是第二位的； 2)决议对毛泽东思想的科学体系和活的冥婚做了概括； 3)决议从根本上否定了“文化大革命”的理论和实践，对新中国成立以来的重大历史事件作出了基本结论； 4)决议肯定了中国十一届三中全会以来逐步确立的是和中国基本情况的建设社会主义现代化强国的道路，进一步指明了中国社会主义事业和党的工作继续前进的方向； 意义：标志着指导思想上拨乱反正的胜利完成，表明中国共产党是成熟、坚强的马克思主义政党，体现了中国共产党纠正错误、探索新道路的能力； 73.1979年3月，邓小平在理论工作务虚会上提出的四项基本原则及坚持这些原则的重要性？ 1)四项基本原则是指：坚持社会主义道路，坚持人民民主专政，坚持共产党的领导，坚持马克思列宁主义、毛泽东思想； 2)坚持这些原则的重要性：这是实现四个现代化的根本前提。如果动摇了其中的任何一项，那就动摇了整个社会主义现代化建设事业； 74.请陈述《关于建国以来党的若干历史问题的决议》关于毛泽东和毛泽东思想的评价？ 1)毛泽东同志是伟大的马克思主义者，是伟大的无产阶级革命家、战略家和理论家； 2)毛泽东同志的功绩是第一位的，错误是第二位的； 3)毛泽东同志为中国共产党和中国人民解放军的创立和发展，为中国各族人民解放是一的胜利，为中华人民共和国的缔造和中国社会主义事业的发展， 建立了永远不可磨灭的功勋； 4)毛泽东思想是马克思列宁主义在中国的运用和发展是被时间证明了的中国革命和建设的争取的理论原则和经验总结，是中国共产党集体智慧的结晶； 75.1979年4月的中共中央工作会议提出对国民经济进行调整的指导思想是什么？ 1)1979年4月召开的中共中央工作会议，提出对国民经济实行“调整、改革、整顿、提高”的方针，坚决纠正前两年经济工作中的失误， 认真清理长期存在的“左”倾错误影响； 2)会议强调，经济建设必须从国情出发，符合经济规律和自然规律，必须量力而行，循序渐进，经过论证，讲求实效，使发展生产痛改善生活紧密集合； 必须在独立自主、自力更生的基础上，积极开展对外经济合作和经济交流； 76.中国共产党于1983年至1987年开展全面整党的主要任务？ 1)统一思想，纠正一切违反四项基本原则、违反十一届三中全会以来党的路线的“左”的和“右”的错误倾向； 2)整顿作风，纠正各种利用职权谋取私利的行为； 3)加强纪律，加强民主集中制的组织原则，改变党组织的软弱涣散状况； 4)纯洁组织，把坚持反对党、危害党的分子清理出去； 77.试论述邓小平关于政治体制改革的基本思路？ 1)政治体制改革要认证解决官僚主义、权力过分集中、正当部分、事实上存在的领导职务终身制等问题； 2)认真肃清封建主义残余影响和资产阶级思想影响，发展社会主义民主，调动广大人民群众的积极性； 3)政治体制改革是社会主义制度的自我完善； 4)必须以四项基本原则为指导，遵循统一领导、循序渐进的原则； 5)在中国共产党的领导下有步骤、有秩序地推进； 6)必须坚持从本国国情出发，总结本国的实践经验，同时借鉴人类政治文明的有益成果； 7)绝不应照搬西方政治制度的模式，绝不搞资产阶级自由化； 78.中共十二届六中全会提出我国社会主义精神文明建设的根本任务是什么？ 1)培养有理想、有道德、有文化、有纪律的社会主义公民； 2)提高整个中华民族的思想道德素质和科学文化素质； 79.中共十三大提出的“三步走”战略？ 1)第一步，实现国民生产总值比1980年翻一番，解决人民的温饱问题； 2)第二步，到20世纪末，是过敏生产总值再正常一杯，人民生活达到小康水平； 3)第三部，到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化； 为了更好的实现“三步走”的战略，邓提出了“台阶式”发展的思想； 80.中共十三大的历史贡献？ 1)中国共产党第十三次全国代表大会比较系统的阐述了关于社会主义初级阶段的理论，这个论断，包括两层含义。 第一，我国社会已经是社会主义社会。我们必须坚持不能离开社会主义； 第二，我国的社会主义社会还处在初级阶段； 2)中国共产党在社会主义初级阶段的基本路线是， 领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放； 自立更生、艰苦创业、为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗； 3)大会还提出了经济体制改革和社会体制改革的任务和目标； 4)党的十三大正式制定了社会主义现代化建设“三步走”的战略部署； 81.中国共产党在社会主义初级阶段的基本路线是， 1)领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放； 2)自立更生、艰苦创业、为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗； 82.简述邓小平关于中国农业改革和发展“两个飞跃”的思想？ 1)中国社会主义农业的改革和发展会有两个飞跃，第一个飞跃是废除人民公社，实行家庭联产承包为主的责任制，第二个飞跃是发展集体经济； 2)社会主义经济以公有制为主体，农业也一样，最重要以公有制为主体； 3)从长远的观点看，科学技术发展了，管理能力增强了，又会产生一个飞跃； 4)农村经济最终还是要实现集体化和集约化，仅靠双手劳作，仅是一家一户的耕作，不向集体化集约化经济发展，农业现代化的是现实不可能的。 就是过一百年二百年，最终还是要走这条路； 5)这是一个长期发展的历史过程； 83.1992年初，邓小平南方谈话的意义是什么？ 1)邓小平的南方谈话，在重大历史关头，科学地总结了十一届三中全会以来党的基本实践和基本经验； 2)明确回答了长期困扰和束缚人们思想的许多重大认识问题； 3)对整个社会主义现代化建设事业产生了重大而深远的影响； 84.1992年初，邓小平南方谈话中提出的判断改革开放是非的主要标准？ 1)是否有利于发展社会主义社会的生产力； 2)是否有利于增强社会主义国家的综合国力； 3)是否有利于提高人民的生活水平； 85.简述邓小平南巡讲话对社会主义本质的相关阐述？ 1)计划多一点还是时常多一点，不是社会主义与资本主义的本质区别； 2)计划和市场都是经济手段； 3)社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕； 86.邓小平南方会谈关于“两手抓、两手都要硬”的系统阐述？ 1)中国的事情能不能办好，社会主义和改革开放能不能坚持，经济能不能快一点发展起来，国家能不能长治久安，从一定意义上说，关键在人； 2)中国要出问题，还是出在共产党内部； 3)要坚持两手抓，一首抓改革开放，一手抓打击各种犯罪活动； 4)这两只手都要硬； 5)在整个改革开放过程中都要反对腐败； 87.简述争取处理改革、发展、稳定的关系 1)稳定是前提，改革是动力，发展是目的； 2)要把改革的力度、发展的速度和社会可承受的程度协调统一起来，做到在政治和社会稳定中推进改革和发展，在改革和发展的推进中是显现政治和社会的长期稳定； 88.简述邓小平关于社会主义本质的内容？ 1)计划多一点还是时常多一点，不是社会主义与资本主义的本质区别； 2)计划和市场都是经济手段； 3)社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕； 89.改革开发以来，我国社会主义民主政治建设稳步推进的主要表现？ 1)党的领导、人民当家做主、依法治国有机统一的制度建设全面加强，党的领导体制机制不断完善； 2)人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度更加健全； 3)基层民主建设取得重大进展； 4)社会主义协商民主全面展开，爱国统一战线巩固发展，民族宗教工作创新推进； 66.中共十八大后党和国家事业的历史性变革给我们的启示。 1)必须始终坚持全党的理论创新成果武装头脑、指导实践。习近平新时代中国特色社会主义思想，是全党全国各族人民为实现中华民族伟大复兴而奋斗的行动指南，须长期坚持 2)必须始终维持党中央和全党的核心。习近平总书记赢得全党全军全国各族人民的高度评价和中心爱戴，成为党中央的核心、全党的核心。对中国这样的大国，中共这样的搭档，党中央有核心、全党有核心、全国各族人民有核心至关重要。 3)必须始终坚持和加强党的全面领导。这是党和国家的根本所在、命脉所在，是全国各族人民的利益所在、幸福所在。只有坚持和加强党的全面领导、推进全面从严治党，我们才能更好实现中华民族伟大阜新的中国梦。","link":"/2022/08/07/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E4%B8%BB%E8%A7%82%E9%A2%98/"},{"title":"中国近代史大纲","text":"一、第一次鸦片战争时期 1.1839年： 林则徐在广州禁烟。 林则徐编写《四洲志》 6月在虎门海滩销烟。英国政府决定发动侵略中国战争。2.1840年： 6月，鸦片战争爆发，英军从广州转攻厦门，攻陷定海，北犯天津。3.1841年： 1月，琦善同英国签订《穿鼻草约》，道光帝不满，派奕山到广州主持军事，对英作战。关天培在虎门炮台抗击英军，壮烈牺牲。 5月，英军进逼广州，弈山投降。三元里人民进行抗英斗争。 9月，定海再次陷落，三总兵抗敌牺牲。4.1842年： 2月，广东水师提督关天培在虎门与英军战死。 6月，陈化成坚守吴淞口以身报国。 7月，海龄，镇江以身报国。 8月，英舰到达南京江面，清政府被迫签订了《中英南京条约》。魏源编著《海国图志》，提出“师夷长技以制夷”5.1843年： 英国强迫清攻府签订《中英五口通商章程》和《中英虎门条约》，作为《南京条约》的附件。洪秀全创立拜上帝教。6.1844年： 《中美望厦条约》和《中法黄埔条约》签订。7.1851年： 1月11日，洪秀全在广西金田村起义，建号太平天国。 9月，在永安州城建制封王。8.1853年： 3月，太平军占领南京，改名天京;颁布《天朝田亩制度》; 4月，发动北伐与西征。 二、第二次鸦片战争时期 1.1856年： 英国利用“亚罗号事件”、法国利用“马神甫事件”发动第二次鸦片战争；秋，“天京事变”发生，严重地削弱了太平天国的领导和军事力量，成为太平天国由盛转衰的分水岭；2.1858年： 沙俄强迫黑龙江将军奕山签订《爱珲条约》。英法联军占领天津。俄、英、法、美强迫清政府分别签订《天津条约》。3.1859年： 6月，英法公使到北京交换条约文本，蓄意挑衅，炮轰大沽口，史荣椿、乐善捐躯。洪仁圩提出了一个统筹全局的改革方案《资政新篇》4.1860年： 英法联军攻占天津、北京。与英、法《北京条约》签订。 三、洋务运动时期 兴起早期维新思想:王韬、郑观应。最早做出完整表述的是冯桂芬。 1.1861年： 11月，那拉氏发动政变（史称“辛酉政变”或“北京政变”）。 中外反动势力勾结起来，共同镇压太平天国运动； 曾国藩创设安庆军械所。它是洋务派办的第一个军事工业。 清政府设立“总理衙门”，由奕担任总理大臣2.1862年： 太平天国军民进行天京保卫战。 总理衙门设立京师同文馆、清末最早设立的″洋务学堂″3.1864年： 7月，天京被湘军攻破、天京陷落，太平天国失败。4.1872年： 李鸿章在上海设立轮船招商局。它是洋务派办的第一个与民用有关的工业； 陈启源在广东南海商办的继昌隆缫丝厂创立（近代中国第一家缫丝厂）。 5.1883年： 12月，中法战争爆发。6.1884年： 8月下旬，法舰突然袭击马尾军港的福建水师。清政府下诏对法国正式宣战。 10月，刘铭传的清军击退进犯台北的法军。 7.1885年： 3月，法舰进犯浙江镇海。 刘永福黑旗军和越南人民配合，在临洮大败法军，收复十多个州县。 冯子材在镇南关大败法军，乘胜追击，收复谅山等要地。 6月，《中法新约》签订。 19世纪70年代 清政府建成北洋水师19世纪70至80年代 “边疆危机”英国从印度侵人西藏，又从缅甸入侵云南； 法国则从越南侵犯广西； 俄国从中亚人侵新疆；日本吞并琉球、侵犯中国台湾。19世纪90年代资产阶级维新派创办的学会主要有强学会 洋务派兴办军用工业： 1865年，李鸿章筹办上海江南制造总局,当时国内最大的兵工厂；同年,李鸿章在南京设立金陵机器局； 1866年，左宗棠在福建创办福州船政局，附设有船政学堂，是当时国内最大的造船厂； 1867年，崇厚在天津建立天津机器局； 1890年，张之洞在汉阳创办湖北枪炮厂。 民用企业（官督商办）：1873年李鸿章创办轮船招商局、开平矿务局、天津电报局和上海机器织布局 1869年，方举赞在上海开设发昌机器厂，中国民族资本主义产生 1881年，中国人第一条铁路唐胥铁路建成通车 四、维新变法时期 资产阶级思想与封建主义思想第一次正面交锋是维新派和守旧派的论战 论战主要问题： 要不要变法； 要不要兴民权、设议院、实行君主立宪； 要不要废八股、改科举和兴学堂； 1.1888年： 康有为第一次向光绪帝上书，要求变法。成立北洋舰队2.1894年： 朝鲜东学党起义，日本乘机出兵朝鲜，占领汉城。 7月，日军突然袭击在牙山附近的中国运输船和驻军，挑起侵略中国的甲午战争。 左宝贵在平壤战役牺牲。 在黄海战役中，邓世昌、林永升等牺牲。 日军侵入辽东半岛，东北人民英勇抗敌，保卫国土。 孙中山在美国檀香山成立兴中会。喊出了”振兴中华”这个时代的最强音。3.1895年： 在威海卫战役中，北洋海军覆灭。清政府向日本求和，被迫签订中日《马关条约》。 徐骧领导的台湾义军和刘永福配合，抗击日军； 康有为等“公车上书”，反对同日本议和，请求变法。使维新思想发展成为爱国救亡运动。 康有为在北京创办《中外记闻》、严复《救亡决论》，喊出了”救亡”的口号；4.1896年： 康有为写了《新学伪经考》、《孔子改制考》、《人类公理》； 梁启超写了《变法通议》； 谭嗣同写了《仁学》； 严复翻译了《天演论》（”物竞天择”、”适者生存”）等。5.1897年： 德国强占胶州湾，民族危机严重；梁启超任主笔的上海《时务报》、严复主办的天津《国闻报》以及湖南的《湘报》等。严复译述的《天演论》在 《国闻报》上定期发表。 6.1898年： 6月，光绪帝颁布《定国是诏》任康有为为总理衙门章京。接着又派谭嗣同、杨锐、刘光第、林旭等人参预变法。 9月，那拉氏（慈禧太后）发动政变，囚禁光绪帝，杀害谭嗣同、杨锐、刘光第、林旭等六人（即戊戌六君子）。史称“戊戌政变”。戊戌变法失败。 五、八国联军侵华战争时期 1.1899年： 秋，山东平原县义和团在朱红灯领导下举行武装起义“扶清灭洋”；美国提出侵略中国的“门户开放”政策；2.1900年： 夏，在京津地区义和团运动的影响下，其他各地也爆发了义和团运动，全国掀起了反帝反封建斗争的浪潮； 6月，八国联军侵略中国。义和团在廊坊、老龙头车站、紫竹林租界等地抗击八国联军； 围攻北京东交民巷使馆和西什库教堂，在北仑配合清军阻击八国联军； 7月17日至21，沙俄出兵侵略我国东北，制造江东六十四屯惨案 ；与1900年7月16日发生的海兰泡惨案，并称为“庚子俄难”；3.1901年： 9月，《辛丑条约》签订。 六、辛亥革命时期 1.1902年： 2月8日，梁启超创办《新民丛报》； 5月21日，张之洞创立湖北师范学院；2.1903年： 5月27日，邹容著《革命军》，章炳麟为《革命军》作序。 5月，章炳麟的《驳康有为论革命书》在《苏报》上发表。3.1904年： 2月8日，日本偷袭旅顺，日俄战争爆发； 2月15日，华兴会成立； 7月3日，科学补习所在武昌成立； 资产阶级革命团体华兴会、光复会、岳王会、科学补习所成立。 陈天华著《猛回头》和《警世钟》。4.1905年： 中国同盟会在日本东京成立，提出政治纲领，选举孙中山为总理，创办了《民报》。5.1906年： 革命党在萍乡、醴陵、浏阳起义，安源矿工六千人参加斗争，最终失败。6.1907年： 孙中山领导潮州、惠州、钦州、廉州和镇南关起义，旋败。徐锡麟在安徽起义，失败被害。秋瑾准备在浙江响应，被捕慷慨就义。7.1910年： 广州新军起义、黄花岗起义；“皇族内阁”成立8.1911年： 4月，孙中山和黄兴发动广州起义； 5月，保路运动爆发。四川最为激烈； 10月10日，（共进会和文学社）武昌起义爆发。革命首先在武汉三镇取得胜利，成立湖北军政府，改国号为中华民国。9.1912年： 元旦，中华民国临时大总统孙中山在南京就职，宣告中华民国成立。接着成立临时参议院，不久，颁布参议院制定的《中华民国临时约法》、《告 各友邦书》。《中国邻国临时约法》中国历史上第一步具有资产阶级共和国宪法性质的大典； 2月，清帝退位。孙中山辞职，袁世凯窃取了革命果实，接任中华民国临时大总统。宋教仁等准备组织责任内阁，以限制袁世凯的权力：将同盟会改 组为国民党。 10.1913年： 3月，袁世凯派人在上海火车站杀害了宋教仁；非法签订善后大借款； 7月，主要在九江、南京一带，史称“赣宁之役”，称“二次革命”。；11.1914年： 孙中山在日本组织中华革命党，坚持反袁武装斗争； 秋、日本派兵入侵山东，取代德国在山东的侵略地位； 七、新文化运动时期 提倡民主科学，反对专制迷信，主张文学革命1.1915年： 1月，日本提出灭亡中国的《二十一条》。 5月9日，“五九国耻”日，接受《二十一条》； 9月15日，陈独秀创办《青年杂志》，在创刊号上发表《敬告青年》一文，提出民主和科学的口号，掀起新文化运动。 12月12日，袁世凯当上了中华帝国皇帝，改年：号为“洪宪”。 12月15日，蔡锷、唐继尧在云南组织”护国军”，形成护国运动。2.1916年： 袁世凯在绝望中死去。黎元洪继任总统。 总理段祺瑞操纵北京政府实权。 杜亚泉在《东方杂志》上抨击新文化运动，拉开中西文化论战序幕3.1917年： 张勋复辟失败。段祺瑞下令对德宣战，宣布不再恢复《临时约法》和国会。 孙中山在广州发动第一次护法运动。 陈独秀任北大文科学长； 俄国十月革命胜利，极大促进了马克思主义在中国的传播。4.1918年： 鲁迅发表《狂人日记》，号召人民起来推翻吃人的旧社会。 李大钊发表《法、俄革命之比较观》、《庶民的胜利》和《布尔什维主义的胜利》，热情歌颂十月社会主义革命。 5月，护法运动失败，标志着整个中国民族资产阶级领导的旧民主主义革命的终结。5.1919年： 《新青年》出版“马克思研究专号”、李大钊发表《我的马克思主义观》； 5月4日，“五四”运动爆发；巴黎和会上中国外交的失败是直接导火索。 6月，中心转移到上海。“五四运动”是新民主主义革命的开端 邓中夏、高君宇北京大学马克思学说研究会 陈独秀上海马克思主义研究会 新民学会、互助社、觉悟社； 10月，将中华革命党改组为中国国民党；八、第一次国共合作时期 1.1920年： 6月，陈独秀发表《谈政治》站马旗下； 8月，孙中山传令粤军陈炯明回师广东，讨伐桂系军阀金春煊、陆荣延。陈望道第一翻译《共产党宣言》 11月，孙中山领导第二次护法运动 陈独秀在上海创办中国共产党第一个早期组织 ，陈独秀，李汉俊、李达；2.1921年： 7月23日，中共一大在上海召开，标志中国共产党成立； 8月，中国劳动组合书记部成立，中国共产党领导工人运动的专门机关； 9月，孙平广西，统一两广；3.1922年： 1月－3月，香港中国海员大罢工 6月，陈炯明炮轰，孙登永丰舰； 7月，中共二大召开，制定反帝反封建的民主革命纲领， 党的最高纲领是实现社会主义、共产主义 当前阶段的纲领是：打倒军阀,推翻国际帝国主义的压迫; 统一中国为真正民主共和国。 8月9日，孙离广赴上；二次革命战争失败；标志资产阶级领导的旧民主主义革命走到了历史尽头； 9月，安阳路矿工罢工；4.1923年： 2月，京汉铁路工人举行“二七”大罢工；从1922年1月香港海员罢工到1923年2月京汉铁路工人罢工，在中国共产党的领导、组织、推动下，中国掀起了第一个工人运动的髙潮。（包括安源路矿工人罢工、开滦五矿工人罢工） 6月，中共三大在广州召开，决定同国民党合作，建立革命统一战线，标志着第一次国共合作的正式形成5.1924年： 1月，中国国民党“一大”召开，提出“新三民主义”，革命统一战线正式形成；形成了以广州为中心的反对帝国主义和封建军阀的革命新局面； 5月，黄埔军校的建立； 7月，国民党设立农民部，林伯渠、澎湃；广州开办农民运动讲义所，澎湃、阮啸仙、毛泽东； 10月23日，冯玉祥发动北京政变6.1925年： 3月12日，孙中山先生逝世； 5月30日，发生“五卅”惨案，“五卅”反帝运动爆发；7.1925年6月－1926年10月： 香港工人大罢工，当时世界上罢工时间最长的一次；8.1926年： 3月，毛泽东发表《中国社会各阶级的分析》；蒋介石策动“中山舰事件”； 5月，蒋介石提出“整理党务案”； 7月，国民革命军出师北伐，推翻北洋军阀； 9月1日，毛泽东发表《国民革命与农民运动》一文，指出：”农民问题乃国民革命的中心问题”，”所谓国民革命运动，其大部分即是农民运动”。9.1926年10月－1927年3月： 上海工人三次武装起义；10.1927年： 1月，武汉和九江人民收回英租界；国民政府从广州迁到武汉，武汉成为当时全国革命的中心； 3月，毛泽东发表《湖南农民运动考察报告》； 4月12日，蒋介石在上海发动反革命政变；“四·一二”反革命政变； 4月18日，蒋介石在南京成立国民政府； 4月27日至5月9日，中国共产党第五次全国代表大会在武汉召开； 5月，夏斗寅、许克祥叛变 7月15日，汪精卫在武汉召开“分共”会议，制造“七·一五”反革命政变。 第二次国内革命战争爆发；政变后，宁汉合流；国共合作破裂，国民革命失败 8月1日，“八一”南昌起义；打响了武装反抗国民党反动统治的第一枪。这是中国共产党独立领导革命战争、创建人民军队和武装夺取政权的开端。 8月7日，在汉口召开“八七会议”，彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党反动统治的总方针，并选出了以瞿秋白为首的中央临时政治局。 毛泽东在会上强调“政权是由枪杆子中取得的”；八七会议”开始了从大革命失败到土地革命战争兴起的历史性转折。 9月，毛泽东领导湘赣边秋收起义；失败后，三湾改编，明确了共产党对军队的绝对领导，武装夺取政权的保证； 10月，毛泽东率领工农革命军在井冈山创立革命根据地； 12月11日，广州起义； 中国革命由此发展到一个新的阶段，即土地革命战争时期（十年内战时期）；11.1928年： 4月，井冈山会师，成立中国工农红军第四军； 6月，南京国民政府宣布改定新约； 10月和11月，毛泽东写了《中国的红色政权为什么能够存在？》和《井冈山的斗争》，阐述了共产党领导的土地革命、武装斗争与革命根据地建设 者三者之间的辩证统一关系。强调“工农武装割据”的思想； 12月29日，张学良东北易帜，南京国民政府在形式上完成了全国统一12.1930年： 1月，毛泽东在《星星之火，可以燎原》中指出：红军、游击队和红色区域的建设和发展，是半殖民地中国在无产阶级领导之下的农民战争的最高形 式和半殖民地农民斗争发展的必然结果，并且是促进全国革命高潮的最重要因素。 5月，1、毛泽东在《反对本本主义》，阐明了坚持辩证唯物主义的思想路线（即坚持理论与实际相结合的原则）的极端重要性，提出了“没有调 査，没有发言权”和“中国革命斗争的胜利要靠中国同志了解中国情况”的重要思想，表现了毛泽东开辟新道路、创造新理论的革命首创精神。 2、农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义即毛泽东思想的初步形成。 九、抗日战争时期 1.1931年： 9月18日，日本帝国主义发动“九·一八”事变； 11月，中华苏维埃第一次全国代表大会召开，中华苏维埃共和国临时中央政府成立；2.1932年： 1月28日，日本帝国主义发动“一·二八”事变，十九路军奋起抗战； 2月东北全境沦陷； 3月，日本扶植前清逊帝溥仪建立伪满洲国3.1934年： 4月，共产党提出，宋庆龄、何香凝、李杜签名发表了《中国人民对日作战的基本纲领》 10月，工农红军第五次反“围剿”失败，中央革命根据地主力红军开始长征；4.1935年： 1月，遵义会议召开；解决组织问题、军事问题；生死攸关转折点；毛泽东、周恩来、王稼祥负责军事行动； 2月，东北抗日联军建立； 6月，四川懋功，红一，红四会师； 8月1日，中共中央发表八一宣言（《为抗日救国告全国同胞书》）； 10月，陕北吴起镇，中央红军同十五军团胜利会师； 12月9日，“一二·九”运动爆发（反对华北自治、打倒日本帝国主义、停止内战，一致对外）； 12月，中共中央瓦窑堡会议，毛泽东发表《论反对日本帝国主义的策略》，通过了《中央关于目前政治形势与党的任务决议》，阐明党的抗日民族 统一战线的新政策，批判党内的关门主义和对于革命的急性病,系统地解决了党的政治路线上的问题。； 华北事变；5.1936年： 5月，全国各界救国联合会成立； 7月，西康甘孜，红四方面军，红二、六军团会师； 10月，甘肃会宁、静宁将台堡，红一、红二、红四在胜利会师，长征胜利结束；红四张国焘 徐向前 12月，张学良、杨虎城扣押蒋介石，西安事变，抗日民族统一战线初步形成； 毛泽东写了《中国革命战争的战略问题》,总结土地革命战争中党内在军事问题上的大争论，系统地说明了有关中国革命战争战略方面的诸问题。6.1937年： 7月7日，“芦沟桥事变”，抗日战争开始； 7月15日，中共提出国共合作的抗日宣言； 7月28日，赵登禹抗日殉国； 8月13日，日本发动“八·一三”事变，蓄意已久地为扩大侵华战争在中国上海制造的事变； 8月22日，中共洛川会议，会议通过了《关于目前形势和党的任务的决定》颁布《抗日救国十大纲领》； 9月，国民党公布国共合作抗日宣言，抗日民族统一战线建立；八路军平型关大捷； 10月，八路军创立第一个抗日根据地——晋察冀根据地； 12月13日，南京沦陷。日军制造南京大屠杀7.1938年： 3月，李宗仁指挥军队开展徐州会战，台儿庄战役是抗战以来正面战场取得的战果最大的一次胜利； 5月，毛泽东发表《论持久战》； 10月，中共召开六届六中全会，毛泽东明确提出了”马克思主义的中国化”这个命题； 10月，广州、武汉失守，抗战进入相持阶段； 12月，汪精卫投降日本。8.1939年： 1月，五届五中全会，国民党成立”防共委员会”，确定了”防共、限共、溶共、反共”的方针9.1940年： 1月，毛泽东发表《新民主主义论》； 3月，汪精卫伪国民政府在南京成立； 5月，枣宜会战国民党张自忠捐躯； 8－11月，彭德怀指挥八路军发动百团大战；10.1941年： 1月，国民党发动第二次反共高潮——皖南事变； 5月，毛泽东作了《改造我们的学习》的报告； 12月，日军发动太平洋战争，美、英对日宣战，整个世界格局发生变化。11.1941－1942年： 中国共产党采取“三三制”原则， 加强抗日民主政权建设， 实行减租减息政策， 开展大生产运动和整风运动， 进行反“扫荡”斗争，保卫解放区；12.1942年： 1月，中、美、英、苏等26国共同签署《联合国宣言》 缅甸北部对日作战以身殉职的是中国远征军戴安澜13.1944年： 9月，中共参政员林伯渠在国民参政大会提出废除国民党一党专政、召开各党派一会、成立民主联合政府的主张； 十、国共内战时期 1945-1949 1.1945年： 4月，中共“七大”召开；同美国、英国、苏联发起旧金山会议(联合国制宪会议)董必武前往； 8月8日，苏联对日宣战； 8月15日，日本宣布无条件投降； 9月2日，日本正式签订投降书； 8月25日，中共中央在《对目前时局的宣言》中提出的口号是“和平、民主、团结”； 8月28日－10月10日，国共重庆谈判，签订《双十协定》； 9月，“向北发展，向南防御”； 10月中下旬，上党、邯郸战役，粉碎国民党的局部进攻； 12月1日，昆明学生发动“一二·一”爱国运动； 2.1946年： 1月10日，国共两党签订停战协定；政协会议开幕； 2月10日，国民党特务在重庆制造的破坏“庆祝政协成功大会”的事件，校场口惨案 6月，国民党发动全面内战，第三次国内革命战争开始；起点是大局围攻中原解放区； 6月23日，上海人民团体联合会、学生和平存进为反对内战，联合发起组成上海人民和平请愿团，下关惨案； 12月30日，北平学生发动抗议美军暴行的运动； 3.1947年： 2月28日，台湾人民举行“二·二八”起义； 3月－7月，延安保卫战，孟良崮战役，粉碎国民党的重点进攻； 5月20日，全国学生发动“反饥饿、反内战、反迫害”的爱国运动； 6月30日，刘邓大军挺进大别山； 7月，人民解放军开始全国规模的反攻； 9月，中共全国土地会议召开，公布《中国土地法大纲》； 10月10日，《中国人民解放军宣言》发表；打到蒋介石，解放全中国；4.1948年： 9月－11月，辽沈战役； 11月－1949年1月，淮海战役； 12月－1949年1月，平津战役；5.1949年： 1月，将革命进行到底； 3月，西柏坡中共七届二中全会；规定政治、经济、外交基本政策；农业国转变工业国、新民主主义社会转变社会主义社会方向；提出“两个务必”要求； 4月21日，毛泽东、朱德发而进军令，解放军渡江作战； 4月23日，解放南京，国民党反动统治结束； 6月30日，毛泽东发表《论人民民主专政》； 9月21日，中国人民政治协商会议第一届全体会议开幕； 10月1日，中华人民共和国成立，民主革命终结和社会主义革命开始；标志着中国进入了新民主主义社会； 1948 9月－11月 辽沈战役 中国近代史解放战争的“三大战役”之一，战役结束后，中国人民解放军首次在兵力数量方面超越国民党军。 11月－次年1月 淮海战役 淮海战役是三大战役中解放军牺牲最重，歼敌数量最多，政治影响最大、战争样式最复杂的战役。 12月－次年1月 平津战役 解放战争中具有决定意义的三大战役中的最后一个战役。平津战役胜利结束，人民解放军进驻北平城，北平宣告完全解放。 十一、中华人民共和国成立和巩固时期：1949—1953年： 1.1950年： 7月，中国共产党召开七届三中全会，毛做《为争取国家财政经济状况的基本好转而斗争的》报告，创建三个条件，土地改革的完成，现有工商业的调整，国家机构所需经费的大量节减；2.1950年10月—1953年7月， 中国人民志愿军抗美援朝； 中央人民政府颁布《中华人民共和国土地改革法》，规定废除地主阶级封建剥削的土地所有制，实行农民的土地所有制。 毛泽东在《在晋绥干部会议上的讲话》第一次全面、系统地提出了新民主主义革命的总路线和总政策，即“无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命”；3.1950—1952年底： 土地改革。土地改革的完成，彻底废除了我国存在两千多年的封建土地制度，地主阶级被消灭，农民成为土地的主人； 使人民政权更加巩固，农村生产力大大解放，为国家的工业化建设准备了条件；4.1951年： 5月，同西藏地方政府达成关于和平解放西藏办法的协议； 10月，西藏和平解放； 标志着祖国大陆获得了统一，各族人民实现了大团结；5.1951年底-1952年春 开展反贪污、反浪费、反官僚主义的“三反”运动，处决了犯有严重贪污罪的天津地委前任书记刘青山、现任书记张子善；6.1952年 1月26日，五反运动是指建国初期在资本主义工商业者中开的反行贿、反偷税漏税、反盗骗国家财产、反偷工减料、反盗窃国家经济情报的斗争； 十二、向社会主义过渡时期：1953—1956年： 1.1953—1957年： 第一个五年计划。一五计划的完成使我国开始改变了工业落后的面貌，向社会主义工业化迈进； “一化三改”。“一化”即社会主义工业化，就是要发展生产力。 “三改”即对农业、手工业、资本主义工商业的社会主义改造，其中对农业、手工业实行合作化，对资本主义工商业实行公私合营 对资本主义工商业采取利用、限制、改造的政策，对资产阶级采取赎买政策。 在经过委托加工、计划订货、统购包销、委托经销代销等一系列从初级到高级的国家资本主义过渡形式2.1953年底： 周恩来在接见印度代表团时提出和平共处五项原则，成为处理国与国之间关系的基本准则。3.1954年9月： 第一届全国人民代表大会制定了《中华人民共和国宪法》，这是我国第一部社会主义类型的宪法。4.1955年： 周恩来出席万隆会议（亚非国际会议），提出“求同存异”的方针，促进了会议的圆满成功，也促进了中国同亚非各国的团结与合作。 十三、探索建设社会主义道路时期（全面建设社会主义时期）：1956—1966年： 1.1956年： 4月25日，毛在中央政治局扩大会议上作了《论十大关系》的讲话，调动一切积极因素，为社会主义事业服务。为探索适合中国国情的社会主义建设道路提出了许多重要的思想原则，从思想上、理论上为八大的召开作了重要的准备。 8月30日至9月12日，在北京举行了八大预备会议。毛泽东在会上作了《增强党的团结，继承党的传统》的讲话，指出八大召开的目的和宗旨是： 总结七大以来的经验，团结全党，团结国内外一切可以团结的力量，为建设社会主义中国而奋斗。号召全党要继承优良传统，反对主观主义、宗派主义和官僚主义。 中共提出“百花齐放，百家争鸣”的方针，使文学艺术创作出现了崭新的局面。 2.1956年： 中共八大召开。这是探索建设社会主义道路的良好开端。陈云提出“三个主体，三个补充”思想。党和人民当前的主要任务是把我国从落后的农业国变为先进的的工业国； 三大改造完成，实现了把生产资料私有制转变为社会主义公有制的任务，标志着我国初步建立起社会主义的基本制度，进入社会主义初级阶段； 长春第一汽车制造厂建成投产、沈阳机床厂建成投产、北京电子管厂建成投产、沈阳飞机制造厂试制成功；3.1957年： 2月，毛在最高国务会议上发表《关于正确处理人民内部矛盾的问题》讲话，区分和处理敌我和人民内部两类矛盾的学说；强制-专制；民主-说服教育-团批团； 武汉长江大桥通车；青藏、康藏、新藏公路通车；4.1958年： “大跃进”和人民公社化运动开始。这是党在探索建设社会主义道路中的一次严重失误。5.20世纪60年代初： 西藏地区完成民主改革，废除了封建农奴制度，百万农奴翻身当家做了主人，进入社会主义阶段。6.1961年春： 中共八届九中全会，决定对国民经济实行“调整、巩固、充实、提高”方针的会议 党和政府全面调整国民经济 ,恢复发展生产。7.1962年春： 中共重要为统一思想、总结经验教训和明确工作方向召开了“七千人会议”8.1964年： 10月16日：我国第一颗原子弹爆炸成功，打破了帝国主义的核垄断。 12月，周恩来第三届人大第一次会议，四个现代化 十四、“文化大革命”时期：1966—1976年： 1966年： 中国战略导弹部队组建成功，主要担任核反击任务。 1967年： 6月17日中国成功试爆第一枚氢弹 1970年： 我国成功发射第一颗人造地球卫星——东方红1号。 1971年： 7月，基辛格秘密访华。 9月13日，九一三事件，林彪反革命集团被粉碎。 10月25日，第26届联合国大会恢复了我国在联合国的合法席位。 1972年： 2月，尼克松访华，中美双方在上海签署了《中美联合公报》，中美关系开始走向正常化。日本首相田中角荣访华，中日建交。 1973年： 袁隆平在世界上首次育成籼型杂交水稻。 1976年： 10月，粉碎江青反革命集团（“四人帮”），标志“文化大革命”结束。 12月，周恩来第三届人大第一次会议，四个现代化 十五、社会主义现代化建设的新时期（改革开放时期）：1978年至今 1978年： 关于真理标准问题的讨论展开。这是一场深刻的思想解放运动，为十一届三中全会的召开奠定了思想基础。 12月，中共十一届三中全会召开。这是建国以来党的历史上具有深远意义的转折，是改革开放的开端，从此我国进入社会主义现代化建设的新时期。 安徽、四川等地搜索试行农业生产责任制，包干到户、包产到户、包产到组； 1979年： 1月，《告台湾同胞书》； 中美建交。 3月，邓小平在中央理论工作务虚会上明确提出必须坚持四项基本原则。 坚持社会主义道路，坚持人民民主专政，坚持共产党的领导，坚持马克思列宁主义，毛泽东思想。 9月，中共十一届四中全会通过《关于加快农业发展若干问题的决议》 1980年： 5月，邓发表《关于农村政策的谈话》； 我国在广东的深圳,珠海,汕头和福建的厦门建立经济特区，开始对外开放。 1982年： 中共十二大，邓小平提出建设有中国特色的社会主义，全国人大颁布了第四部《中华人民共和国宪法》。 1984年： 12月，中英《关于香港问题的联合申明》 1985年： 3月，《关于科学技术体制改革的决定》 5月，《关于教育体制改革的决定》 1986年： 颁布《中华人民共和国义务教育法》和《中华人民共和国民法通则》。 1987年： 4月，中葡《关于澳门问题的联合生命》 10月25日-11月1日，中共十三大，邓小平阐明了社会主义初级阶段理论，提出了党在社会主义初级阶段的“一个中心、两个基本点”基本路线，即以经济建设为中心，坚持四项基本原则，坚持改革开放。台湾当局调整“三不”政策，两岸关系发生了历史性的变化。制定了下一步经济体制改革和政治体制改革的基本任务和奋斗目标 1990年： 3月，中共十三届六中全会通过了《关于加强党同人民群众的决定》； 3月3日，邓提出“两个飞跃”思想；第一个飞跃是废除人民公社，实行家庭联产承包为主的责任制；第二个飞跃是发展集体经济； 中国首次成功举办亚洲运动会。1990年台湾成立了海峡交流基金会。 1991年： 大陆成立了海峡两岸关系协会。 1992年：扩大改革，开放上海浦东位新的经济特区；海基会与海协会达成“九二共识”，即“海峡两岸均坚持一个中国原则”。 1992年初：邓小平南巡讲话，强调发展才是硬道理。南巡讲话进一步解放了人们的思想，对建设有中国特色的社会主义产生了深远影响。 1992年：中共十四大，提出建立社会主义市场经济体制，确立了邓小平理论在全党的指导地位，形成了以江泽民为核心的第三代领导集体。 1993年：“汪辜会谈”（海协会会长汪道涵和海基会董事长辜振甫在新加坡举行的会谈），将“加强两岸经济交流，互补互利”写入协议，标志着海峡两岸关系的发展迈出了历史性的重要一步。 14. 1995年初：1月，江泽民发表《为促进祖国统一大业的完成而继续奋斗》，提出“八项主张”，成为新时期推进祖国和平统一进程的指导思想。 1997年：7月1日：香港回归，中华人民共和国香港特别行政区正式成立。9月12日至18日，中共十五大，把邓小平理论写入党章，确立为党的指导思想。通过了关于《中国共产党章程修正案》的决议； 1999年：12月20日：澳门回归，中华人民共和国澳门特别行政区正式成立。我国成功发射第一艘无人飞船“神舟一号”。 20世纪90年代：党和政府提出“科教兴国”战略，把九年义务教育作为科教兴国的奠基工程。 20世纪末：中国整体上进入小康社会。 2000年：全国基本普及九年义务教育。 2001年：12月11日，加入世贸组织，标志着对外开放进入一个新阶段。中国在上海成功举办了亚太经合组织会议（APEC会议）。这是中国迄今举行的规模最大、规格最高的多边外交活动。 2002年：11月8日至14日，中共十六大北京召开；高举邓小平理论伟大旗帜，全面贯彻“三个代表”重要思想，继往开来，与时俱进，全面建设小康社会，加快推进社会主义现代化，为开创中国特色社会主义事业新局面而奋斗； 2003年：我国成功发射第一艘载人飞船“神州五号”。 2004年：9月，中共十六届四中全会提出的战略任务是构建社会主义和谐社会； 2005年3月14日第十届人民大表大会三次会议，反分裂国家法； 2007年：10月15日至21日，中共十七大明确指出，高举中国特色社会主义伟大旗帜最根本的是要坚持中国特色社会主义道路、中国特色社会主义理论体制； 2008年：中国成功举办了奥运会和残奥会。 2010年：5月，中央新疆工作会议上中央正式批准霍尔果斯、喀什设立经济特区。 2011年：确立建设社会主义文化强国战旅目标的会议是 2013年：11月，中共十八届三中全会做出《关于全面深化改革若干重大问题的决定》，提出了全面深化改革的知道思想、重要方针、目标任务、政治举措，明确了全面深化改革的总目标、时间表、路线图，成为知道新形势下全面深化改革的纲领性文件； 主要运动： 三元里抗英 1841年5月 广州 三元里人民的抗英斗争 台湾抗日 1874年 台湾 台湾高山族人民抗击日本 义和团抗八 1900年 廊坊 抗击八国联军 二次革命 1913年7月 九江、南京 史称“赣宁之役”，反对袁世凯派人在上海火车站杀害了宋教仁；非法签订善后大借款； 护国运动 1915年12月15日 云南 蔡锷、唐继尧在云南组织”护国军” 护法运动1 1917年-1918年 广州 孙中山在广州发动第一次护法运动。 护法运动2 1920年11月-1922年 广州 标志资产阶级领导的旧民主主义革命走到了历史尽头； 五四运动 1919年5月4日 巴黎和会上中国外交的失败是直接导火索。新民主主义革命的开端； 香港海员罢工 1922年1月 香港 中国工人阶级第一次直接同帝国主义势力进行的有组织的较量；工人运动第一个高潮起点 矿工人罢工 1922年9月 安阳路 安阳路矿工工人罢工 京汉铁路罢工 1923年2月 北京 北京政府调动军警镇压罢工，知道了震惊中外的“二七惨案”；工人运动第一个高潮终点； 五卅惨案 1925年5月30日 上海 “五卅”反帝运动爆发，中国共产党领导中国人民反对帝国主义的伟大革命运动； 香港工人大罢工 25年6月-26年10月 香港 当时世界上罢工时间最长的一次； 中山舰事件 1926年3月20日 广州 包围广州东山的苏联顾问所；驱逐了黄埔军校中及国民革命军中以周恩来为首的共产党员。 整理党务案 1926年5月 蒋介石提出“整理党务案”； 四一二事变 1927年4月12日 上海 蒋中正大规模逮捕、处决中国共产党党员，并取缔苏联顾问。 七一五事变 1927年7月15日 武汉 汪精卫分共事件 南昌起义 1927年8月1日 南昌 打响了武装反抗国民党反动统治的第一枪。 九一八事变 1931年9月18日 东北 日本帝国主义发动“九·一八”事变 一二八事变 1932年1月28日 上海 日本帝国主义发动“一·二八”事变，淞沪会战，蒋光鼐蔡延凯抗击 华北事变 1935年 1935年日本侵略军蚕食侵犯华北地区的一系列事件的统称 一二九运动 1935年12也9日 北平 抗议日本侵占；北平爱国学生举行的抗日游行运动； 西安事变 1936年12月 西安 张学良、杨虎城扣押蒋介石，西安事变，抗日民族统一战线初步形成； 七七事变 1937年7月7日 卢沟桥 抗日战争开始 八一三事变 1937年8月13日 上海 蓄意已久地为扩大侵华战争在中国上海制造的事变 皖南事变 1941年1月 国民党发动第二次反共高潮——皖南事变； 一二一运动 1945年12月1日 昆明 反对内战，争取自由；吹响了国统区爱国学生运动的第一声号角； 校场口惨案 1946年2月10 重庆 庆祝政协成功大会 下关惨案 1946年6月23日 上海 和平请愿团 一二三O运动 1946年12月30日 北平 抗议驻华美军暴行； 五二O运动 1947年5月20日 南京 反饥饿，反内战，挽救教育危机； 二二八 1947年2月28日 台湾 台湾人民举行“二·二八”起义； 三反 1951-1953年 反贪污、反浪费、反官僚主义 五反 文化大革命 66-76年 主要党派： 兴中会 1894年11月 美国檀香山； 中国同盟会 1905年8月 日本东京； 中华革命军 1914年7月 日本东京； 中国国民党 1919年10月 中国上海； 中国劳动组合书记部 1921年8月 中国共产党领导工人运动的专门机关 国民政府 1927年4月18日 蒋介石在南京成立国民政府； 中国国民临时行动委员会 1930年8月9日 以宋庆龄、何香凝、邓演达、黄琪翔等为代表的国民党左派； 伪国民政府 1940年3月 汪精卫伪国民政府在南京成立； 中国民主政团同盟 1941年3月19日 重庆黄炎培； 中国民主建国会 1945年12月16日 重庆； 中国民主促进会 1945年12月30日 上海合作组织 2001年 第一个以中国城市命名的国际组织 中央统一战线工作领导小组 2015年7月 资产阶级革命团体 华兴会、光复会、岳王会、科学补习所 马克思学说研究会 邓中夏、高君宇北京大学 马克思主义研究会 陈独秀上海 农民运动讲义所 澎湃、阮啸仙、毛泽东； 农民部 林伯渠、澎湃 土地革命战争前中期，中国共产党内出现的主要错误倾向： “左”倾盲目主义 瞿秋白 1927.11-1928.4 “左”倾冒险主义 李立三 1930.6-1930.9 “左”倾教条主义 王明 1931.1-1935.1 “右”倾机会主义 “右”倾投降主义 建国后的“大跃进”、“文化大革命”也是“左”的错误 为国捐躯的爱国将领 第一次鸦片战争 关天培 1841.2 虎门 陈化成 1842.6 吴淞西炮台 海龄 1842.7 镇江 第二次鸦片战争 史荣椿 1859.6 大沽炮台 乐善 1859.6 大沽炮台 甲午战争 左宝贵 1894.7 平壤战役 邓世昌 1894.9 黄海 林永升 1894.9 黄海 丁汝昌 1895.2 威海卫 刘步蟾 1895.2 威海卫 抗日战争 赵登禹 抗日牺牲 佟麟阁 抗日牺牲 张自忠 枣宜会战 戴安澜 缅甸抗战 李宗仁 台儿庄战役 谢晋元 上海四行仓库牺牲 蒋光鼐蔡延凯 淞沪会战 解放战争 李公朴、闻一多、杜斌丞民主党派流血； 主要纲领 《天朝田亩制度》 1853年3月 以解决农民土地问题为中心的比较完整的社会改革方案； 《资政新篇》 1859年6月 第一步具有鲜明资本主义色彩的改革、建设方案； 《中华民国临时约法 》 1912年1月1日 中国历史上第一步具有资产阶级共和国宪法性质的大典 《国民革命与农民运动》 1926年9月1日 “农民问题乃国民革命的中心问题”，”所谓国民革命运动，其大部分即是农民运动”。 《井冈山土地法》 1927年-1928年 规定没收一切土地而不是没收地主土地；没收土地归苏维埃政府所有而不是归农民所有； 《星星之火，可以燎原》 1930年1月 红军、游击队和红色区域的建设和发展，是半殖民地中国在无产阶级领导之下的 农民战争的最高形式和半殖民地农民斗争发展的必然结果，并且是促进全国革命高潮的最重要因素。 《反对本本主义》 1930年5月 阐明了坚持辩证唯物主义的思想路线（即坚持理论与实际相结合的原则）的极端重要性，提出了“没有调査，没有 发言权”和“中国革命斗争的胜利要靠中国同志了解中国情况”的重要思想，表现了毛泽东开辟新道路、创造新理论的革命首创精神。 《为抗日救国告全国同胞书》 1935年8月1日 中共中央发表八一宣言（《为抗日救国告全国同胞书》） 《论反对日本帝国主义的策略》 1935年12月 中共中央瓦窑堡会议，阐明党的抗日民族统一战线的新政策，批判党内的关门主义和对于革命的急性 病,系统地解决了党的政治路线上的问题。； 《中国革命战争的战略问题》 1936年12月 总结土地革命战争中党内在军事问题上的大争论，系统地说明了有关中国革命战争战略方面的诸问题。 《抗日救国十大纲领》 1937年8月22日 中共洛川会议，会议通过了《关于目前形势和党的任务的决定》颁布《抗日救国十大纲领》； 《论持久战》 1938年5月 论证了抗战的发展规律，阐明了争取抗战胜利的道路，批判了对抗战的各种错误认识； 《对目前时局的宣言》 1945年8月25日 提出的口号是“和平、民主、团结”； 《中国土地法大纲》 1947年9月 土地会议，规定彻底废除封建性及半封建性剥削的土地制度； 规定实行耕者有其田的土地制度；规定保护民族工商业的发展； 《中国人民解放军宣言》 1947年10月10日 打到蒋介石，解放全中国； 《在晋绥干部会议上的讲话》 1948年4月1日 第一次全面、系统地提出了新民主主义革命的总路线和总政策； 即“无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命”； 《论人民民主专政》 1949年6月30日 毛泽东发表《论人民民主专政》； 《中华人民共和国土地改革法》 1950年6月30 规定废除地主阶级封建剥削的土地所有制，实行农民的土地所有制。 《中华人民共和国宪法》 1954年9月 第一届全国人民代表大会制定了，这是我国第一部社会主义类型的宪法。 《论十大关系》 1956年4月25日 毛在政治局扩会，调动一切积极因素，为社会主义事业服务。“一个不杀，大部不抓” 《关于正确处理人民内部矛盾的问题》1957年2月 区分和处理敌我和人民内部两类矛盾的学说；强制-专制；民主-说服教育-团批团； 《目前形势和我们的任务》 没收封建阶级的土地归农民所有，没收垄断资本归新民主主义国家所有，保护民族工商业 《告各友邦书》 《为促进祖国统一大业的完成而继续奋斗》 《新民主主义论》 1940年1月 《改造我们的学习》 1941年5月 主要大会 1921年7月23日，中共一大 标志中国共产党成立； 纲领是：革命军队必须与无产阶级一起推翻资本家阶级的政权； 确定党的根本政治目的是实行社会革命。 1922年7月16日，中共二大 制定反帝反封建的民主革命纲领； 1923年6月12日，中共三大 决定同国民党合作，建立革命统一战线； 1925年1月11日，中共四大 通过了《对于民族革命运动之议决案》； 陈中央总书记，彭述之任宣传部主任，张国焘任工农部主任，蔡和森、瞿秋白任宣传部委员 1927年4月27日，中共五大 大会通过了《政治形势与党的任务议决案》《土地问题议决案》等； 1928年6月18日，中共六大 1938年9月29日，中共六届六中全会 毛提出了&quot;马克思主义的中国化&quot;这个命题； 1945年4月23日，中共七大 通过了新的党章； 确定以马克思列宁主义与中国革命实践相统一的毛泽东思想作为全党一切工作的指针； 1949年3月5日，中共七届二中全会 规定政治、经济、外交基本政策； 农业国转变工业国、新民主主义社会转变社会主义社会方向； 提出“两个务必”要求； 1950年6月6日，中共七届三中全会 毛做《为争取国家财政经济状况的基本好转而斗争的》报告； 创建三条件，土地改革的完成，现有工商业的调整，国家机构所需经费的大量节减； 1956年4月初，在中共中央书记会议上 毛提出实现马克思主义同中国实际“第二次结合”思想； 1956年9月15日，中共八大 探索建设社会主义道路的开端； 经济建设的指导方针：即反保守又反冒进，在综合平衡中稳步前进； 陈提“三个主体，三个补充”思想； 党和人民主要任务是把我国从落后的农业国变为先进的的工业国； 社会主义改造的基本完成，国内主要矛盾： 1.人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾； 2.人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾； 1957年2月，最高国务会议上（理论准备著作《论十大关系》） 发表《关于正确处理文化内部矛盾的问题》； 指出，社会主义社会的主要矛盾： 1.生产力和生产关系的矛盾； 2.经济基础和上层建筑的矛盾； 毛指出国家政治生活的主题是正确处理人民内部矛盾； 两类不同性质矛盾： 1.敌我之间的矛盾；强制的方法，专政的方法； 2.人民内部之间的矛盾； 1957年6月，全国规模的群众性运动，反右派运动； 1969年4月1日，中共九大， 1973年8月24日，中共十大， 1977年8月12日，中共十一大， 1978年12月18日，中共十一届三中全会 关于真理标准问题的讨论展开; 改革开放; 进入社会主义现代化建设的新时期; 建国以来党的历史上转折点； 两大问题：农民温饱尚未解决和“政社合一” 1978年12月，邓小平在中共中央工作会上发表 《解放思想，实事求是，团结一致向前看》； 1979年4月，中共中央工作会议 提出对国民经济实行“调整、改革、整顿、提高”的方针； 1979年11月，起草《关于建国以来党的若干历史问题的决议》； 1980年，中国中央政治局扩大会议 邓发表了《党和国家领导制度的改革》讲话，提出基本任务（政治体制改革）； 1981年6月，中共十一届六中全会，通过《关于建国以来党的若干历史问题的决议》； 1982年9月1日，中共十二大 邓小平提出建设有中国特色的社会主义社会; 全国人大颁布了第四部《中华人民共和国宪法》; 1984年10月20日，中共十二届三中全会 会议通过了《关于经济体制改革的决定》，我国社会主要经济是在（公有制基础上的有计划的商品经济）； 1985年3月和5月，先后货颁布推进体制改革的重要文件 《关于经济体制改革的决定》《关于教育体制改革的决定》； 1986年9月28日，中共十二届六中全会 作出《关于社会主义精神文明建设指导方针的决议》； 社会主义现代化建设总布局：以经济建设为中心，坚定不移进行经济体制、政治体制、精神文明改革； 1987年10月25日，中共十三大 邓阐明了社会主义初级阶段理论; 提出了党在社会主义初级阶段的“一个中心、两个基本点”基本路线; 1988年3月25日 第七届全国人大第一次会议 通过设立海南省和建立海南经济特区的决议； 1989年10月10日 中共十三届五中全会 指出“邓小平提出的建设有中国特色的社会主义的理论，是毛泽东思想的重要组成部分，是毛泽东思想在新的历史条件下的继承和发展...财富”； 1990年3月 中共十三届六中全会 通过了《关于加强党同人民群众的决定》； 1992年1月18日-2月21日，南方会谈 提出三个“三个有利于”判断标准 1.是否有利于发展社会主义社会的生产力； 2.是否有利于增强社会主义国家的综合国力； 3.是否有利于提高人民的生活水平； 1992年10月12日，中共十四大 提出建立社会主义市场经济体制; 确立了邓小平理论在全党的指导地位; 形成了以江泽民为核心的第三代领导集体。 1993年11月，中共十四届三中全会 通过《关于建设社会主义市场经济体制若干问题的决定》 1995年，江泽民关于发展海峡两岸关系的重要讲话 《为促进祖国统一大业的完成而继续奋斗》 1996年10月7日，中共十四届六中全会 《关于加强社会主义精神文明建设若干重要问题的决议》 强调以科学的理论武装人，以正确的舆论引导人，以高尚的精神塑造人，以优秀的作品鼓舞人； 1997年9月12日，中共十五大 把邓小平理论写入党章; 确立为党的指导思想; 通过了关于《中国共产党章程修正案》的决议； 1998年 中共中央决定在县级以上党政领导班子、领导干部中深入开展讲学习、讲正气、讲政治的教育； 2000年2月，江泽民广东考察工作 提出“三个代表”重要思想的完整的概念； 2000年5月，江泽民在江苏、浙江、上海党建工作座谈会，进一步指出，始终做到“三个代表”是中国共产党的立党之本、执政之基、力量之源； 2001年，加入世界贸易组织 形成的对外开放格局是 全方位，多层次，宽领域； 2001年7月1日，庆祝中国共产党成立80周年大会 江泽民系统阐述“三个代表”的科学内涵和基本内容； 2002年11月8日，中共十六大 将“三个代表”重要思想确立为中国共产党必须长期坚守的指导思想之一； 2003年10月，中共十六届三中全会 科学发展观，第一要义是发展，核心是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾； 2004年5月，胡在纪念邓诞辰一百周年大会上 提出，要高举和平、发展、合作的契机，坚持走和平发展的道路； 2004年9月，中共十六届四中全会 提出的战略任务是（构建社会主义和谐社会）； 通过《关于加强党的执政能力建设的决议》； 2005年10月，中共十六届五中全会 提出了建设社会主义新农村的战略任务，提出了“生产发展、生活宽裕、乡风文明、村容整洁、管理民主”的要求； 指出科学发展观是推动经济社会发展、加快推进社会主义现代化建设必须长期坚持的指导思想； 2005年11月，英国伦敦金融城发表演讲 系统阐述走和平发展道路的基本内涵和重大意义； 2005年，第十届人民大表大会三次会议 反分裂国家法 2005年初-06年上半年 党内开展了以时间“三个代表”重要思想为主要内容的（保持共产党员先进性教育活动） 2007年10月15日，中共十七大 明确指出高举中国特色社会主义伟大旗帜最根本的是要坚持中国特色社会主义道路、中国特色社会主义理论体制； 胡锦涛全面概述了科学发展观的科学内涵和精神实质； 科学发展观入党章； 2008年10月，中共十七届三中全会 通过推进农村改革发展的行动纲领《关于推进农村改革发展若干重大问题的决定》； 2009年9月，中共十七届四中全会 通过总结中国共产党在执政条件下加强自身建设基本经验的文件是《关于加强和改进新形势下党的建设若干重大问题的决定》； 2010年10月，中共十七届五中全会 通过《关于制定国民经济和社会发展第十二个五年规划的建议》； 十二五时期以科学发展为主题，以加快转变经济发展方式为主线，深化改革开放，保障和改善民生， 巩固和扩大应对国际金融危机冲击成果，促进经济长期平稳较快发展和社会河西稳定， 为全面建成小康社会打下具有决定性意义的基础； 2011年10月，中共十七届六中全会 确立建设社会主义文化强国战略目标； 通过《关于深化文化体制改革推动社会主义文化大发展大繁荣若干重大问题的决定》； 提出新形势下推进文化改革发展的指导思想、重要方针、目标任务、政治举措； 我国文化改革发展进入一个新阶段； 2012年11月8日，中共十八大 全面建成小康社会决定性阶段; 审议并通过《中国共产党章程（修正案）》； 总依据：社会主义初级阶段；总布局：经济、政治、文化、社会、生态文明建设五位一体； 总任务：实现社会主义现代化和中华民族伟大复兴； 2013年11月，中共十八届三中全会 发表《关于全面深化改革若干重大问题的决定》，通过了全面深化改革的纲领性文件； 2014年10月，中国十八届四中全会 作出《中共中央关于全面推进依法治国若干重大问题的决定》； 2014年11月，十二届全国人大常委会第十一次会议 通过《关于设立国家宪法日的决定》，12月4日设立国家宪法日； 2015年10月，中国十八界五中全会 审议通过《中共中央关于制定国民经济和社会发展第十三个五年计划的建议》； 提出全面建成小康社会的目标要求； 2016年10月，中共十八届六中全会 审议通过《关于新形势下党内政治生活的若干准则》和《中国共产党党内监督条例》； 2017年10月18日，中共十九大,作了题为《决胜全面建成小康社会 夺取新时代中国特色社会主义伟大胜利》的报告。 主题是：不忘初心，牢记使命，高举中国特色社会主义伟大旗帜，决胜全面建成小康社会， 夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。 是在全面建成小康社会决胜阶段、中国特色社会主义发展关键时期召开的一次十分重要的大会。 2017年，第十二届全国人大常委会第二十九次会议 通过的法律《中华人民共和国国歌法》 文学著作 康有为写了《新学伪经考》、《孔子改制考》、《人类公理》；北京《中外记闻》； 梁启超写了《变法通议》；上海《时务报》；《新民丛报》 谭嗣同写了《仁学》； 严复翻译了《天演论》（”物竞天择”、”适者生存”）等；《救亡决论》，喊出了”救亡”的口号；天津《国闻报》； 张之洞创立湖北师范学院 邹容著《革命军》，章炳麟为《革命军》作序。 章炳麟的《驳康有为论革命书》在《苏报》上发表。 陈天华著《猛回头》和《警世钟》 孙中山创办了《民报》 陈独秀创办《青年杂志》，《敬告青年》，提出民主和科学的口号，掀起新文化运动。 杜亚泉在《东方杂志》上抨击新文化运动，拉开中西文化论战序幕 李大钊发表《法、俄革命之比较观》、《庶民的胜利》和《布尔什维主义的胜利》 鲁迅发表《狂人日记》 《新青年》出版“马克思研究专号”、李大钊发表《我的马克思主义观》； 陈望道第一翻译《共产党宣言》 在20世纪30年代后期和40年代前期，毛泽东撰写了《〈共产党人〉发刊词》、《中国革命和中国共产党》、《新民主主义论》等一批重要的理论著作。新民主主义理论的系统阐明，标志着毛泽东思想得到多方面展开而达到成熟。1937年夏，毛泽东在延安抗日军政大学讲授《实践论》、《矛盾论》，科学地阐明了党的马克思主义的思想路线。平型关大捷 八路军出师以来打的第一个大胜仗台儿庄战役 国民党一大，标志着第一次国共合作的正式形成；形成了以广州为中心的反对帝国主义和封建军阀的革命新局面； 五届五中全会，国民党成立”防共委员会”，确定了”防共、限共、溶共、反共”的方针《瓦窑堡会议》 压力批评党内错误倾向是 左倾冒险主义左倾关门主义；抗日民族统一战线中争取中间实力的主要条件，发展进步实力，争取中间实力，孤立顽固势力七千人会议 总结经验教训、明确工作方向的会是？1935年1月，遵义会议，解决了有决定意义的军事和组织问题，确立毛为代表的马克思主义主线的领导地位，在极其危机的情况下，挽救了中国共产党，挽救了工农红军，挽救了中国革命；中国共产党历史生死攸关转折点。1937年8月22日，洛川会议，会议通过了《关于目前形势和党的任务的决定》颁布《抗日救国十大纲领》；八七会议，在汉口彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党反动统治的总方针，并选出了以瞿秋白为首的中央临时政治局。分共会议1961年春，中共八届九中全会，决定对国民经济实行“调整、巩固、充实、提高”方针的会议1945年4月，旧金山会议，董必武前往同美国、英国、苏联(联合国制宪会议)1946年1月10日，政协会议，国共两党签订停战协定，政协会议开幕；1947年9月，全国土地会议，中共全国土地会议召开，公布《中国土地法大纲》；1955年，万隆会议（亚非国际会议），周恩来出席提出“求同存异”的方针，促进了会议的圆满成功，也促进了中国同亚非各国的团结与合作。1956年4月25日，中央政治局扩大会议，作了《论十大关系》的讲话，调动一切积极因素，为社会主义事业服务。为探索适合中国国情的社会主义建设道路提出了许多重要的思想原则， 从思想上、理论上为八大的召开作了重要的准备。1956年8月30日至9月12日，八大预备会议，毛泽东在会上作了《增强党的团结，继承党的传统》的讲话，指出八大召开的目的和宗旨是： 总结七大以来的经验，团结全党，团结国内外一切可以团结的力量，为建设社会主义中国而奋斗。号召全党要继承优良传统，反对主观主义、宗派主义和官僚主义。1957年2月，最高国务会议，发表《关于正确处理人民内部矛盾的问题》讲话，区分和处理敌我和人民内部两类矛盾的学说；强制-专制；民主-说服教育-团批团；1964年12月21日，第三届人大第一次会议，周恩来提出四个现代化；2001年，亚太经合组织会议，中国在上海成功举办了亚太经合组织会议（APEC会议）；2010年5月，中央新疆工作会议，中央正式批准霍尔果斯、喀什设立经济特区。 提出社会主义新农村的是","link":"/2022/08/07/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E5%A4%A7%E7%BA%B2/"},{"title":"交换变量值","text":"不使用新的变量，交换两个变量的值。比如有两个变量a、b，我们希望交换他们的值。有两种不同的方法：基于加减法： a = a + b b = a - b a = a - b基于异或运算： a = a ^ b b = a ^ b a = a ^ b","link":"/2022/08/10/%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E5%80%BC/"},{"title":"位运算","text":"位运算是把数字用二进制表示之后，对每一位上0或者1的运算。与(&amp;) 0 &amp; 0 = 0 1 &amp; 0 = 0 0 &amp; 1 = 0 1 &amp; 1 = 1或(|) 0 | 0 = 0 1 | 0 = 1 0 | 1 = 1 1 | 1 = 1异或(^) 0 ^ 0 = 0 1 ^ 0 = 1 0 ^ 1 = 1 1 ^ 1 = 0 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变为0。很多二进制问题都可以用这种思路解决。","link":"/2022/08/10/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"免费VPN推荐","text":"免费VPNTop1： Windscribewebsite：https://windscribe.comWindscribe 这是位于加拿大多伦多的的一家VPN公司。关键是Windscribe不仅提供了免费的方案给可以给大家长期使用，而且赠送10G免费的数据可以提供大家使用，我觉得一般如果是正常上网的话已经够用了适用于：Netflix，Hulu，HBO兼容：Windows，macOS，iOS，Firefox，Chrome，Linux免费时长：长期免费流量：10G/月免费节点数：10条推荐指数：❤️❤️❤️❤️❤️ Top2：ProtonVPNwebsite：https://protonvpn.com总部位于瑞士机房座落於歐洲最安全的資料中心，位在距離地表1000 公尺深的地底下。提供军事级别的加密。无限的免费数据，意思是它没有流量限制。免费提供：日本，荷兰和美国这2个国家的服务器。兼容：Windows，macOS，iOS，Android，Linux免费时长：长期（7天高级功能，基础功能长期免费）免费流量：无限免费节点数：3条推荐指数：❤️❤️❤️❤️❤️ Top3：Speedifywebsite：https://speedify.com这是一家位于美国的公司，Speedify每个月为您提供5GB的免费数据，该数据每30天刷新一次。可在50多个国家/地区的1000多个服务器之间提供出色的连接性能，提供完整的加密安全系统，同时该软件的涡轮增压技术可以确保在整个连接时间内速度始终保持其最大可能的性能。免费时长：长期免费流量：2G/月免费节点数：10条推荐指数：❤️❤️❤️ Top4：TunnelBearwebsite：https://www.tunnelbear.com服务器数量： 1,000 | 服务器位置： 20+ | IP地址：不适用 | 支持的最大设备数： 5​​并每月为您提供高达1.5GB的免费数据访问网站在TunnelBear真正的用户友好移动和桌面客户端选项或设置不多低数据限制免费时长：长期免费流量：500M-1.5G/月免费节点数：10条推荐指数：❤️❤️❤️❤️ Top5：Hide.me官网：https://hide.me免费时长：一个月（可延长）免费流量：10G/月免费节点数：4条推荐指数：❤️","link":"/2022/08/07/%E5%85%8D%E8%B4%B9VPN/"},{"title":"各种学习资料，包括一些百度云视频链接还有pdf资料 --搬运工","text":"人生不如意事常八九 共勉 【0】Springboot微服务开发天气预报系统视频教程 https://pan.baidu.com/s/1joz7flyztCq8oklBlsz8dQ 提取密码：cpz7 【1】JAVA300集大型视频教程2018版发布 https://pan.baidu.com/s/1Bqy4mWSD1idd6JmIzS9ZLg 提取密码：llg2 【2】Vue2.5开发去旅游网站App从零基础入门到实战项目 https://pan.baidu.com/s/1DYCoIw_b893KXGkkYt_92Q 提取密码：bgoy 【3】opencv+tensorflow入门人工智能图像处理视频教程+源码下载 https://pan.baidu.com/s/10WefZkTQST094L5UQA7myg 提取密码：7b9w 【4】最新BAT面试真题讲解，想去大厂的别错过 https://pan.baidu.com/s/1ejf2Eh8ZA-T1bWbuT6gw0A 提取密码：mist 【5】Python3异步IO并发编程高级进阶视频教程下载 https://pan.baidu.com/s/1jiRwD5MNPmAKF98nXYzmKg 提取密码：hct4 【6】最新大数据数据分析与挖掘高级工程师第三期视频教程 https://pan.baidu.com/s/1g8xGPag9GiMA4_MEKbxePw 提取密码：z2v3 【7】姜承尧MYSQL,DBA视频课程(44天全)视频教程下载 https://pan.baidu.com/s/19NUjkkvdDZXhw1QG4yX21Q 提取密码：funf 【8】Python+AnsiblePlaybook+Django自动化运维项目实践课程 https://pan.baidu.com/s/1CfOHuaYi_TdPoAUzP9AW1w 提取密码：o3rc 【9】springcloud微服务实践-分布式与原理剖析链路追踪容器 https://pan.baidu.com/s/1g8QoqOnQwjI7N3zDSccr-w 提取密码：ygf5 【10】2018年最新Java高并发知识体系与高并发编程架构课程视频教程下载 https://pan.baidu.com/s/1E1NhSevRqwdnguiKSsOp5A 提取密码：mkh2 【11】2018年最新价值300Python人工智能TensorFlow框架应用实践视频课程下载 https://pan.baidu.com/s/1qYJjFz9aG6M5grMg311uRQ 提取密码：5hzp 【12】谭州学院价值1680元python视频教程12306网站案例vip特训班教程 https://pan.baidu.com/s/1yEQq5W1eSc3NA4XmyNmuJw 提取密码：cipi 【13】下载 https://pan.baidu.com/s/1D6hYdyi4ti2zpnKHVWWbEg 提取密码：glov 【14】Netty实战高性能分布式RPC视频教程下载 https://pan.baidu.com/s/1sDHh_g624MO08MTFIrwEDw 提取密码：mwa6 【15】2018年最新尚学堂Vue2全套学习视频教程下载 https://pan.baidu.com/s/147NvAV-Qse90xvTYDvHBcg 提取密码：wpfg 【16】最新2018疯狂SpringCloud微服务架构实战视频教程 https://pan.baidu.com/s/1jgC0lagtMG7tArATrAAHXg 提取密码：10kf 【17】kotlin高级教程从零开始开发完整安卓商城app https://pan.baidu.com/s/13F_C1aKuJ0ek5Kv-HWdygw 提取密码：krq2 【18】2018年最新疯狂Activiti6视频教程疯狂工作流讲义Activiti6.x视频教程 https://pan.baidu.com/s/1SriGV7tZAeSvYcYb6l_hdQ 提取密码：bzcu 【19】基于MyCat的MySQL高可用读写分离集群实战课程下载 https://pan.baidu.com/s/1DVCf57_O1iMDJkbOGxdnpw 提取密码：6a08 【20】2018年最新Webpack3由浅入深及搭载vue,react,angular框架多维度讲解 https://pan.baidu.com/s/1BYq5qb9fFMSyODlORBQCcw 提取密码：6wf3 【21】2018年最新Spark机器学习课程：智能客户系统项目实战视频教程 https://pan.baidu.com/s/12SrMtvLBlVJGOlOt5NQFjw 提取密码：uu9v 【22】最新离线数据分析平台实战驴妈妈项目实战培训视频教程 https://pan.baidu.com/s/129jhYGDLFzsM7BW5HYdg7Q 提取密码：vhjs 【23】2018年最新尚硅谷java9新特性视频教程下载 https://pan.baidu.com/s/1xC-xPm54rFMLAHYwis1Thg 提取密码：f0v6 【24】最新北风网人工智能+机器学习+深度学习+推荐系统实战第3期视频教程 https://pan.baidu.com/s/1E98ZYCtJ7Mom_tWZT6AM_g 提取密码：3abb 【25】[全栈开发]Vue+DjangoRESTframework打造生鲜电商项目视频教程 https://pan.baidu.com/s/1vFAkTEdydgL-GjdcpeEHGg 提取密码：k00f 【26】2018年最新node.js+ES+Koa2手把手教你开发一个短视频网站视频教程 https://pan.baidu.com/s/1jmxxQ88J_qWsovXkMNeDpQ 提取密码：46yh 【27】基于Java的微信平台开发教程视频下载 https://pan.baidu.com/s/1hMq-J7KFMuDezGSdzX35OA 提取密码：oycw 【28】最新精选蚂蚁-MySQL语句性能优化视频教程下载 https://pan.baidu.com/s/1miVf8Ze 提取密码：w5yt 【29】深度学习实战项目-利用RNN与LSTM网络原理进行唐诗生成视频课程 https://pan.baidu.com/s/1i6jyFtz 提取密码：vrzx 【30】2018年最新微信小游戏开发ES6+小游戏api开发视频教程下载 https://pan.baidu.com/s/1i7mwJCp 提取密码：ndl7 【31】最新甲骨论-Linux大数据及数据库存储视频教程下载 https://pan.baidu.com/s/1smi2oNj 提取密码：ypgn 【32】泰牛2017php基础班大牛班完整视频教程下载 https://pan.baidu.com/s/1ggKGo9d 提取密码：2tqk 【33】2018年最新Java微服务原理课程与改造房产销售平台视频教程 https://pan.baidu.com/s/1jKf8MMi 提取密码：i8ej 【34】使用dubbo、spring-boot等技术实现互联网后台服务项目架构视频教程 https://pan.baidu.com/s/1gg1JiBD 提取密码：1jtk 【35】最新区块链开发入门到精通视频教程下载 https://pan.baidu.com/s/1kW7FTwr 提取密码：hvep 【36】2018年最新价值1699元的深入大数据架构师之路，问鼎40万年薪视频教程下载 https://pan.baidu.com/s/1c3d1RbU 提取密码：22kw 【37】2018年最新java大数据基于storm开发实时流处理器视频教程 https://pan.baidu.com/s/1cOCHPk 提取密码：igw9 【38】2017年最新JAVA-ACE-架构师系列视频课程-RocketMQhttps://pan.baidu.com/s/1ghb9UAf 提取密码：sstz 【39】2017年深度学习项目实战视频课程-Seq2Seq序列生模型视频教程 https://pan.baidu.com/s/1dGEDwSp 提取密码：96eh 【40】2017年最新web前端工程师小白零基础入门到大神全套教程下载 https://pan.baidu.com/s/1dFQ8wgT 提取密码：7g4e 【41】2017年最新python高级模块matplotlib数据可视化分析视频教程 https://pan.baidu.com/s/1kWyRVmB 提取密码：qjaj 【42】价值1680元安卓特训班实战开发百思不得姐app项目教程下载 https://pan.baidu.com/s/1c3adHsc 提取密码：sxvg 【43】2018年最新价值799元Elasticsearch顶尖高手系列：高手进阶篇视频教程 https://pan.baidu.com/s/1mkkSBrU 提取密码：zmjn 【44】2017年最新深度学习框架Caffe使用案例视频课程下载 https://pan.baidu.com/s/1dGFsBnz 提取密码：q4dg 【45】炼数成精大数据的矩阵计算基础课程下载 https://pan.baidu.com/s/1mkaJbpY 提取密码：pnnc 【46】2018年最新redis从入门到精通与分布式架构视频教程下载 https://pan.baidu.com/s/1gggc7Fd 提取密码：img8 【47】2018年最新动力节点Java夜校视频教程下载 https://pan.baidu.com/s/1i6v7013 提取密码：dbnt 【48】全网最新基于ElasticSearch的找房网实战开发企业级房屋搜索网视频教程下载 https://pan.baidu.com/s/1bqUVrsF 提取密码：idjy 【49】Java高性能高并发秒杀系统实战视频教程下载 https://pan.baidu.com/s/1bqVBoqb 提取密码：ztqe 【50】2017最新最系统的PHP面试视频教程下载高薪无忧 https://pan.baidu.com/s/1o81Mu8q 提取密码：da2f 【51】2017年最新炼数成金机器读心术之神经网络与深度学习视频教程下载 https://pan.baidu.com/s/1mhJkQzI 提取密码：pvc6 【52】李兴华系列之Java8、Oracle、JavaScript、HTML5、Spring、Struts、Hibernate系列视频教程下载 https://pan.baidu.com/s/1o7O6ytc 提取密码：icgf 【53】2017年最新Python+scripy实现搜索引擎爬虫课程视频教程下载 https://pan.baidu.com/s/1mhLSFVy 提取密码：n333 【54】最新某某学院大数据工程师视频教程下载 https://pan.baidu.com/s/1o7Cvjwm 提取密码：ximb 【55】2017年Javaweb开发工程师成长之路全套视频教程附配套资料下载 https://pan.baidu.com/s/1qXJcyVa 提取密码：31di 【56】php高性能yii2框架开发高性能高可用负载均衡集群架构商城视频教程下载 https://pan.baidu.com/s/1jIKk70i 提取密码：b9bt 【57】2017最新兄弟连laravel入门到精通+博客实战开发教程下载 https://pan.baidu.com/s/1bZJAW2 提取密码：6p4c 【58】2017年最系统的PHP教程高薪就业视频教程下载 https://pan.baidu.com/s/1o7DG2pW 提取密码：rrds 【59】2017最新大数据10个小时快速入门hadoop3集群实战视频教程 https://pan.baidu.com/s/1hsgtagG 提取密码：dwin 【60】2017年最新Webpack+React全栈工程架构项目实战精讲视频教程下载 https://pan.baidu.com/s/1hsq2s64 提取密码：gprc 【61】2017年最新Uber车辆监控系统设计实战训练营高清视频教程全套附讲义代码 https://pan.baidu.com/s/1nv9Vm5b 提取密码：5bs8 【62】2017年最新DS206人脸识别与分析系统实战训练营硅谷讲师授课高清视频教程全套附讲义代码4周 https://pan.baidu.com/s/1c2LcBsc 提取密码：nv1h 【63】2017年最新React开发Native开发安卓与ios平台的GitHubApp视频教程 https://pan.baidu.com/s/1jI6DiXg 提取密码：7cyk 【64】2017年最新Google面试官亲授java校招面试视频讲解教程下载 https://pan.baidu.com/s/1nuDIkQ1 提取密码：hhnu 【65】Android传感器、无线传输与媒体硬件功能开发视频教程下载 https://pan.baidu.com/s/1bpoA4EV 提取密码：cvh9 【66】最新Kaggle神器之XGBoost从入门到精通高清精品视频教程附代码教程下载 https://pan.baidu.com/s/1nvj6fDR 提取密码：x493 【67】Oracle商业智能BI产品OBIEE11G深入浅出全套视频教程下载 https://pan.baidu.com/s/1o81KXPg 提取密码：f3sg 【68】2017年最新小象学院分布式爬虫第二期视频教程 https://pan.baidu.com/s/1geX7fKB 提取密码：2ac9 【69】mongodb从入门到精通高清视频教程下载 https://pan.baidu.com/s/1cpsdjC 提取密码：3ng4 【70】最新大数据快速数据挖掘平台RapidMiner数据分析视频教程下载 https://pan.baidu.com/s/1bpFE111 提取密码：3z6u 【71】最新Python自然语言分析视频课程下载 https://pan.baidu.com/s/1ge40FbP 提取密码：wa5r 【72】最新尚学堂redis视频教程下载 https://pan.baidu.com/s/1c35hRg 提取密码：gy5j 【73】最新oracle11gDBA开发和应用数据库视频教程下载 https://pan.baidu.com/s/1o7YE5Bk 提取密码：eu68 【74】2017vue2nodemongoKoa2Nuxt/VueSSR全栈开发小程序商城视频教程 https://pan.baidu.com/s/1jIw3lR4 提取密码：bmia 【75】最新python数据分析升级版视频教程下载 https://pan.baidu.com/s/1i5L7LdV 提取密码：bfk7 【76】Python数据分析(机器学习)经典案例视频教程 https://pan.baidu.com/s/1nuUCPlf 提取密码：3ytg 【77】DB2数据库性能优化视频教程下载 https://pan.baidu.com/s/1qYysRDE 提取密码：i1rx 【78】2017年node.js零基础入门到企业级全栈案例开发教程下载 https://pan.baidu.com/s/1eRBopRs 提取密码：ne2a 【79】Hadoop大数据视频教程：真实电商数据仓库全流程开发详解(共46讲)视频教程下载 https://pan.baidu.com/s/1bpMzOyr 提取密码：m3yt 【80】最新老男孩python全栈工程师第2期全套完整版视频教程下载 https://pan.baidu.com/s/1cIycbk 提取密码：cgfm 【81】价值2400元的python全栈开发系列FlaskPythonWeb网站编程视频教程 https://pan.baidu.com/s/1qXATJju 提取密码：huc3 【82】最新python从入门到精通到开发爬虫实例视频教程 https://pan.baidu.com/s/1mirFpeK 提取密码：9gmt 【83】极客学院VIP教程postgresql教程全集视频教程下载 https://pan.baidu.com/s/1i4DjPdF 提取密码：qgga 【84】最新angular4.x框架与redux开发大型企业级管理项目视频教程下载 https://pan.baidu.com/s/1nvEDQNB 提取密码：mqvu 【85】2017年数据分析与机器学习实战到经典案例全套高清视频教程（基于Python3.5anaconda4.2）15G https://pan.baidu.com/s/1nvqXoPN 提取密码：irdj 【86】2017年最新大数据实时分析Storm入门到精通学习路线视频教程 https://pan.baidu.com/s/1pL7OfvP 提取密码：2ze2 【87】使用php高可用webapp后端开发视频教程下载 https://pan.baidu.com/s/1qXTQ5FQ 提取密码：pybc 【88】2017年最新java算法详解与算法开发小游戏视频教程下载 https://pan.baidu.com/s/1dF0GWNn 提取密码：t6tk 【89】2017年9月最新pythonflask开发小视频网站视频教程 https://pan.baidu.com/s/1nuHfvZF 提取密码：pygf 【90】2017年5月炼数成金《MySQLDBA从小白到大神实战》视频教程 https://pan.baidu.com/s/1jHFP8sm 提取密码：qnmj 【91】Vue从入门到精通视频教程 https://pan.baidu.com/s/1pKCX6Wj 提取密码：h6hd 【92】北风网从C++起步到MFC实战VC++软件工程师高端培训(服务器端开发方向)332课全 https://pan.baidu.com/s/1c1SSWKg 提取密码：iw7p 【93】2017最新python3从零基础入门到精讲超清视频教程 https://pan.baidu.com/s/1c2Nd468 提取密码：h46d 【94】2017年最新使用MUI开发跨平台混合APP全套完整视频教程 https://pan.baidu.com/s/1dFxYZ0d 提取密码：9ury 【95】最新人脸识别深度学习项目实战视频教程 https://pan.baidu.com/s/1o8onm2m 提取密码：7aqr 【96】2017年最新Python网络爬虫实战案例视频教程下载共5章34课 https://pan.baidu.com/s/1micMg8w 提取密码：23gt 【97】基于Hadoop，Spark大数据技术的推荐系统算法实战教程 https://pan.baidu.com/s/1dFnP9K1 提取密码：djyk 【98】 https://pan.baidu.com/s/1gf0CGuB 提取密码：4tei 【99】2017年最新云知梦php全栈开发全套视频教程 https://pan.baidu.com/s/1qYPwSsW 提取密码：iv93 【100】Python编程高级进阶视频教程 https://pan.baidu.com/s/1bpnnEph 提取密码：y9sp 【101】2017年5月最新课程小象学院深度学习第四期视频教程 https://pan.baidu.com/s/1o7IzeXk 提取密码：kptc 【102】最新自动聊天机器人项目班实战视频课程下载 https://pan.baidu.com/s/1kU9bNev 提取密码：6p5z 【103】深度学习入门视频课程上篇+下篇下载 https://pan.baidu.com/s/1slG7qxv 提取密码：u2c4 【104】七月在线机器学习算法班9月在线班视频教程 https://pan.baidu.com/s/1nuLiXCl 提取密码：vdkz 【105】最新小象学院机器学习升级版III视频教程下载 https://pan.baidu.com/s/1gfeXSgb 提取密码：dt7t 【106】最新优达学城udacity无人驾驶工程师视频教程 https://pan.baidu.com/s/1c1UUEXi 提取密码：mjbs 【107】2017年深度学习项目实战之对抗生成网络视频课程 https://pan.baidu.com/s/1hs8chxU 提取密码：76mw 【108】2017年深度学习之Tensorflow项目实战视频课程-文本分类 https://pan.baidu.com/s/1c1Kf1wG 提取密码：dt52 【109】2017年kaggle案例实战班视频教程 https://pan.baidu.com/s/1boYu4FX 提取密码：4bhc 【110】深度学习实战决胜AI-强化学习实战系列视频课程 https://pan.baidu.com/s/1eRHZ1yq 提取密码：ifu2 【111】2017年最新从理论到实践机器学习视频教程 https://pan.baidu.com/s/1jHPsHSU 提取密码：xx9x 【112】2017最新基于springsecurity与spingmvc分布式权限管理系统 https://pan.baidu.com/s/1c13keOw 提取密码：xea9 【113】Java高并发程序设计实战视频教程 https://pan.baidu.com/s/1c1CDsnI 提取密码：xsic 【114】Sqoop、Flume、Oozie、Hue大数据工具视频教程 https://pan.baidu.com/s/1bo47OGR 提取密码：hxw7 【115】深入JVM内核—原理、诊断与优化视频教程 https://pan.baidu.com/s/1jIL46PK 提取密码：78yd 【116】Hadoop,Hbase,Hive源码解析与开发实战 https://pan.baidu.com/s/1hsznJsK 提取密码：dpmq 【117】传智播客黑马P2P金融项目网络借贷平台开发实战教程 https://pan.baidu.com/s/1pLieuzL 提取密码：gbxy 【118】2017年7月最新微服务架构的分布式事务解决视频教程 https://pan.baidu.com/s/1bo47p2R 提取密码：94hx 【119】亿级流量电商系统大型高并发与高可用缓存架构实战 https://pan.baidu.com/s/1pLmhZir 提取密码：6aj9 【120】2017Spark2.0大型项目实战：移动电商app交互式数据分析平台 https://pan.baidu.com/s/1o8EAk2Y 提取密码：gcsq 【121】NO89中移动大型分布式redis,solr,Linux,nginx,springmvc,mybatis电商项目 https://pan.baidu.com/s/1qY7K2SW 提取密码：cjj4 【122】SpringBoot从前端到后台打造企业级博客全栈实战视频 https://pan.baidu.com/s/1pKLc2BT 提取密码：8tjw 【123】（2017年）最新深度学习与机器学习 https://pan.baidu.com/s/1c76kgA 提取密码：5qyv 【124】SpringMvc+Spring+Mybatis整合视频教程 http://pan.baidu.com/s/1gfP90Pl 提取密码：kveg 【125】Struts2+Spring3+Hibernate4+Maven+EasyUI整合入门视频教程 http://pan.baidu.com/s/1bpztkOR 提取密码：krbn 【126】elk日志分析视频ELKStack视频教程以及Solr教程 http://pan.baidu.com/s/1qYwQOSc 提取密码：qr9u 【127】徐老师hadoophbasezookeepersparkkafka大数据视频教程 http://pan.baidu.com/s/1miLtQqO 提取密码：97tj 【128】2017年最新项目实战SpringBoot视频教程微服务整合Mybatis http://pan.baidu.com/s/1boMH2Cv 提取密码：gvt5 【129】传智播客最新大数据第3期实战培训完整版视频教程 http://pan.baidu.com/s/1miLZwwg 提取密码：56hs 【130】[大数据]极客学院大数据工程师全套视频代码课件 http://pan.baidu.com/s/1c160ug4 提取密码：6d28 【131】2017新版MySQL加强视频教程46课附课件源码 http://pan.baidu.com/s/1eSouP6U 提取密码：nh8i 【132】Python爬虫项目班从零开始实现爬虫系统 http://pan.baidu.com/s/1i5QiuzV 提取密码：2vpd 【133】Mongodb/Redis/HBaseNoSql视频教程2017数据库自学教程 http://pan.baidu.com/s/1kVytRIB 提取密码：mtnb 【134】Mahout零基础入门到精通实战视频教程（全套）下载 http://pan.baidu.com/s/1kUPNJaJ 提取密码：pvka 【135】2017年最新整理深度学习神经网络算法全套视频教程 http://pan.baidu.com/s/1pLsfdIb 提取密码：vy41 【136】阿里开源分布式框架dubbo&amp;mycat视频教程 https://pan.baidu.com/s/1geZwIYZ 提取密码：h7iw 【137】极客学院python开发工程师视频教程下载 https://pan.baidu.com/s/1miDOboc 提取密码：gwaa 【138】2017最新python教程老男孩Python14期视频教程下载 https://pan.baidu.com/s/1kVbWgzP 提取密码：9hk7 【139】达内2017Web前端全套最新价值2万元视频教程 http://pan.baidu.com/s/1jIA3oma 提取密码：rfqk 【140】达内Java全套最新价值2万元视频教程 https://pan.baidu.com/s/1sl545sx 提取密码：sa8i 【141】SparkMLlib机器学习算法与源码解析 https://pan.baidu.com/s/1pLptvMN 提取密码：ncek 【142】大数据开发之hadoop工程师成长之路零基础到精通下载 https://pan.baidu.com/s/1i4LciTf 提取密码：8z4m 【143】Kafka原理剖析及实战演练视频教程下载 https://pan.baidu.com/s/1mhAgeBA 提取密码：26ny","link":"/2022/08/04/%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%80%E4%BA%9B%E7%99%BE%E5%BA%A6%E4%BA%91%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5%E8%BF%98%E6%9C%89pdf%E8%B5%84%E6%96%99%20--%E6%90%AC%E8%BF%90%E5%B7%A5/"},{"title":"在Mac下启动Tomcat","text":"1.将加压好的 Tomcat 安装包放在某个路径下，重命名为 Tomcat 。（例如我放在了资源库下）2.输入 cd Library/Tomcat/bin 进到 Tomcat 的 bin 目录下3.输入 sudo chmod 755 *.sh 设置权限4.输入 sudo sh startup.sh 启动 Tomcat。在浏览器中输入 localhost:8080 看到 Tomcat 主页即为成功。5.输入 sudo sh shutdown.sh 关闭 Tomcat。","link":"/2022/08/06/%E5%9C%A8Mac%E4%B8%8B%E5%90%AF%E5%8A%A8Tomcat/"},{"title":"安装apk提示Failure [INSTALL_FAILED_TEST_ONLY&#x2F; installPackageL","text":"Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] 平台版本是android 7.0，在adb install *.apk 会提示下面的错误： Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] 方法1： 修改AndroidManifest.xml 中android:testOnly=”true” 改成 android:testOnly=”false”，或者直接去掉。 方法2： adb push *.apk /tmp adb shell pm install -t /tmp/*.apk 方法3： adb install -t *.apk 方法4： Android Studio 3.0 and FLAG_TEST_ONLY 一文中，给出了关于Android studio 3.0中出现问题的说明：Option to indicate this application is only for testing purposes.For example, it may expose functionality or data outside of itself that would cause a security hole, but is useful for testing.This kind of application can not be installed without the INSTALL_ALLOW_TEST flag, which means only through adb install. You cannot install an app with android:testOnly=”true” by conventional means, such as from an Android file manager or from a download off of a Web site Android Studio 3.0 sets android:testOnly=”true” on APKs that are run from the IDE 解决办法：在gradle.properties(项目根目录或者gradle全局配置目录 ~/.gradle/)文件中添加：android.injected.testOnly=false 请转载的朋友表明出处：http://blog.csdn.net/shift_wwx/article/details/78468397","link":"/2022/08/06/%E5%AE%89%E8%A3%85apk%E6%8F%90%E7%A4%BAFailure%20%5BINSTALL_FAILED_TEST_ONLY%20%20installPackageL/"},{"title":"序列化面试题","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243面试相关1. 反序列化后的对象，需要调用构造函数重新构造吗 反序列化调用不会调用构造函数。以存储的二进制数据进行构造2. 序列前的对象与序列化后的对象是什么关系？是(&quot;==&quot;还是equal？是浅复制还是深复制？) 序列化前和序列化后 是两个不同的对象，对象地址发生了改变。调用equal 和 == 返回true。是一个深复制。3. Android里面为什么要设计出Bundle而不是直接用Map结构 Bundle中是使用的Parcel打包数据。Parcel可以实现跨进程通讯。 &lt;!-- more --&gt; Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数 据对应下标，一个对象数组 保存key和value，内部使用二分法对key进行排序，所以在添加、删 除、查找数据的时候，都会使用二分法查找，只适合于小数 据量操作，如果在数据量比较大的情况 下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候， HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据 量，我没见过在两个Activity之 间传递10个以上数据的场景，所以相比之下，在这种情况下使用 ArrayMap保存数据，在操作速度和内存占用上都具有优势， 因此使用Bundle来传递数据，可以保 证更快的速度和更少的内存占用。 另外一个原因，则是在Android中如果使用Intent来携带数据的话， 需要数据是基本类型或者是可 序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。 而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为 了更加快速的进行数据的序列化和反序列化， 系统封装了Bundle类，方便我们进行数据的传输。4. SerialVersionID的作用是什么？ 版本控制5. Android中Intent/Bundle的通信原理及大小限制 大小限制 bundle 在zgote在创建进程的时候，分配了binder的内存大小。binder申请匿名内存有限制。 binder在内核空间创建内存映射时，大小限制在 &lt; 4M intent 1M限制 Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限 制的(有些手机是 2 M)， 而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区 就更小了( 有人以前做过测试，大约一个线程可以占用 128 KB)。 所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时， 你应 该知道怎么解决了6. 为何Intent不能直接在组件间传递对象而要通过序列化机制？ startActivity（intent），activity启动流程要和AMS交互，需要跨进程通讯。只有把数据序列化后，传递。7. 序列化与持久化的关系和区别是什么？ 序列化:跨进程传输数据时，需要使用序列化。 持久化:数据的存储。 Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程 (intent.prepareToLeaveProcess())， 这也就意味着，Intent所携带的数据要能够在不同进程间 传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输， 所以我 们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间 传输。 而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel 容器 ，后者也是Android系统专门推出的用于进程间通信等的接口","link":"/2022/08/04/%E5%BA%8F%E5%88%97%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"应用程序返回按键执行流程","text":"从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。android系统的事件分发流程分为很多部分： Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层 所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。 在Native层android系统的事件流程： Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。 在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。 将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。 Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。 Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。 可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。 在ViewRootImpl层android系统的事件流程 在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现： 123private void dispatchInputEventFinished(int seq, boolean handled) { onInputEventFinished(seq, handled); } 在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中： 12345678910private final class ImeInputEventSender extends InputEventSender { public ImeInputEventSender(InputChannel inputChannel, Looper looper) { super(inputChannel, looper); } @Override public void onInputEventFinished(int seq, boolean handled) { finishedInputEvent(seq, handled, false); } } 可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。 12345678910111213141516171819202122void finishedInputEvent(int seq, boolean handled, boolean timeout) { final PendingEvent p; synchronized (mH) { int index = mPendingEvents.indexOfKey(seq); if (index &lt; 0) { return; // spurious, event already finished or timed out } p = mPendingEvents.valueAt(index); mPendingEvents.removeAt(index); Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size()); if (timeout) { Log.w(TAG, &quot;Timeout waiting for IME to handle input event after &quot; + INPUT_METHOD_NOT_RESPONDING_TIMEOUT + &quot; ms: &quot; + p.mInputMethodId); } else { mH.removeMessages(MSG_TIMEOUT_INPUT_EVENT, p); } } invokeFinishedInputEventCallback(p, handled); } 在方法finishedInputEvent中，经过一系列的处理之后最终调用的是invokeFinishedInputEventCallback方法，所以我们继续看一下invokeFinishedInputEventCallback方法的实现。 1234567891011121314void invokeFinishedInputEventCallback(PendingEvent p, boolean handled) { p.mHandled = handled; if (p.mHandler.getLooper().isCurrentThread()) { // Already running on the callback handler thread so we can send the // callback immediately. p.run(); } else { // Post the event to the callback handler thread. // In this case, the callback will be responsible for recycling the event. Message msg = Message.obtain(p.mHandler, p); msg.setAsynchronous(true); msg.sendToTarget(); } } 可以发现这里我们首先判断PendingEvent的mHandler所在的线程是否是当前线程，若是的话则直接调用p.run方法，若不是的话则发送一个异步消息，而异步消息最终也是执行的p.run方法，所以我们继续看一下PendingEvent的run方法。 12345678@Override public void run() { mCallback.onFinishedInputEvent(mToken, mHandled); synchronized (mH) { recyclePendingEventLocked(this); } } 可以发现在run方法中我们调用了mCallback的onFinishedInputEvent方法，需要说明的是这里的mCallback就是我们ViewRootImpl中的ImeInputStage类对象，而这里的ViewRootImpl对象就是我们的系统当前界面，前面我们分析Activity的加载绘制流程的时候知道Activity中保存了一个Window对象用于表示窗口信息，而Window对象内部就是通过ViewRootImpl对象实现窗口的加载绘制，所以这里的mCallback对象就是我们当前的App获取焦点的窗口的ViewRootImpl中的ImeInputStage对象，然后我们看一下该对象的onFinishedInputEvent方法的实现。 12345678910111213final class ImeInputStage extends AsyncInputStage implements InputMethodManager.FinishedInputEventCallback { ... @Override public void onFinishedInputEvent(Object token, boolean handled) { QueuedInputEvent q = (QueuedInputEvent)token; if (handled) { finish(q, true); return; } forward(q); } } 这样经过一系列的调用之后我们消息的处理逻辑上传至了ViewRootImpl中，而在ViewRootImpl中经过一些列的调用之后我们ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法： 12345678910111213141516171819202122at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4152)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4114)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3807)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3864)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3840)at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4006)at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2272)at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1893)at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1884)at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2249)at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141) 这是通过异常信息打印的堆栈信息，从中我们可以看到在ViewRootImpl中我们经过一系列的调用之后最终执行的是：ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法，这样我们继续看一下processKeyEvent方法。 12345678private int processKeyEvent(QueuedInputEvent q) { ... // Deliver the key to the view hierarchy. if (mView.dispatchKeyEvent(event)) { return FINISH_HANDLED; } ...} 可以看到这里调用了mView的dispatchKeyEvent方法，而我们分析过Activity窗口加载绘制流程，从中我们知道ViewRootImpl中的mView对象就是我们PhoneWindow中的mDecorView对象（DecorView），所以经过层层调用我们最终执行到了DecorView层。 在DecorView层android系统的事件流程 从上面我们知道在ViewRootImpl中我们最终调用了mView.dispatchKeyEvent方法，即执行的是PhoneWindow%DecorView.dispatchKeyEvent方法。 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean dispatchKeyEvent(KeyEvent event) { final int keyCode = event.getKeyCode(); final int action = event.getAction(); final boolean isDown = action == KeyEvent.ACTION_DOWN; if (isDown &amp;&amp; (event.getRepeatCount() == 0)) { // First handle chording of panel key: if a panel key is held // but not released, try to execute a shortcut in it. if ((mPanelChordingKey &gt; 0) &amp;&amp; (mPanelChordingKey != keyCode)) { boolean handled = dispatchKeyShortcutEvent(event); if (handled) { return true; } } // If a panel is open, perform a shortcut on it without the // chorded panel key if ((mPreparedPanel != null) &amp;&amp; mPreparedPanel.isOpen) { if (performPanelShortcut(mPreparedPanel, keyCode, event, 0)) { return true; } } } if (!isDestroyed()) { final Callback cb = getCallback(); final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event); if (handled) { return true; } } return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event) : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event); } 从中我们可以看到如果当前的PhoneWindow不是destroy庄则，则执行cb.dispatchKeyEvent方法，而这里的callback对象就是我们的Activity对象，所以这里最终会执行到Activity的dispatchKeyEvent方法。。。 在Activity层android系统的事件流程 所以我们这里继续看一下Actiivty中的dispatchKeyEvent方法： 12345678910111213141516171819public boolean dispatchKeyEvent(KeyEvent event) { onUserInteraction(); // Let action bars open menus in response to the menu key prioritized over // the window handling it if (event.getKeyCode() == KeyEvent.KEYCODE_MENU &amp;&amp; mActionBar != null &amp;&amp; mActionBar.onMenuKeyEvent(event)) { return true; } Window win = getWindow(); if (win.superDispatchKeyEvent(event)) { return true; } View decor = mDecor; if (decor == null) decor = win.getDecorView(); return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this); } 从中我们可以看到我们首先调用了Activity的window对象的superDispatchKeyEvent方法，而这个方法就是将处理方法下发带Activity中的View，而这里我们分析的是返回按键，显然的View层是无法处理这里的返回按键的，所以win.superDispatchKeyEvent方法返回的是false，所以最终我们执行的是event.dispatch方法。这样我们继续看一下event.dispatch方法的实现。 123456789101112131415public final boolean dispatch(Callback receiver, DispatcherState state, Object target) { switch (mAction) { ... case ACTION_UP: if (DEBUG) Log.v(TAG, &quot;Key up to &quot; + target + &quot; in &quot; + state + &quot;: &quot; + this); if (state != null) { state.handleUpEvent(this); } return receiver.onKeyUp(mKeyCode, this); ... } return false; } 这里我们暂时分析一下ACTION_UP事件，可以发现这里最终调用的是receiver.onKeyUp方法，而这里的receiver就是我们的Actiivty，所以这里又回到了Activity并且执行其onKeyUp方法。 1234567891011public boolean onKeyUp(int keyCode, KeyEvent event) { if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) { if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking() &amp;&amp; !event.isCanceled()) { onBackPressed(); return true; } } return false; } 看onKeyUp方法，我们可以发现当我们按的是返回按键时，其回调了onBackPressed方法，所以我们继续看一下onBackPressed方法。 123456789public void onBackPressed() { if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) { return; } if (!mFragments.getFragmentManager().popBackStackImmediate()) { finishAfterTransition(); } } 可以看到，在onBackPressed方法中，我们最终调用的是finishAfterTransition方法，所以继续看一下这个方法的实现逻辑。 12345public void finishAfterTransition() { if (!mActivityTransitionState.startExitBackTransition(this)) { finish(); } } O(∩_∩)O哈哈~，原来finish方法是在这里调用的，这样我们按下返回按键并抬起之后，经过层层的调用之后最终调用了我们的finish方法，而这个方法就是finish掉Activity的方法，也就解释了我们在App中默认按下返回按键之后Acitivty会被销毁了。 总结： 本文中由于是分析的返回按键的处理流程，所以事件的分发流程没有做说明，下面的文章中会着重介绍Android的事件分发流程； 事件分发流程从Native –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层都是类似的，无论是按键分发流程还是触摸事件分发流程 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程","link":"/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"应用进程Context创建流程(转)","text":"今天讲讲应用进程Context的创建流程，相信大家平时在开发过程中经常会遇到对Context对象的使用，Application是Context，Activity是Context，Service也是Context，所以有一个经典的问题是一个App中一共有多少个Context？ 这个问题的答案是Application + N个Activity + N个Service。 还有就是我们平时在使用Context过程中许多时候由于使用不当，可能会造成内存泄露的情况等等，这个也是需要我们注意的。这里有篇不错的文章： Android Context 是什么？ 好吧，什么叫应用进程Context呢？这是指的是Application所代表的Context的创建流程，还记得我们前几篇写的应用进程创建流程么？ android源码解析之（十一）–&gt;应用进程启动流程最后我们得出结论，应用进程的起始方法是ActivityThread.main方法，好吧， 由于还未讲解Service相关知识，这里暂时讲解一下Activity与Application中Context对象的创建过程。 首先我们就从ActivityThread.main方法开始看一下Application的创建流程。。。 123456public static void main(String[] args) { ... ActivityThread thread = new ActivityThread(); thread.attach(false); ... } 这里我们发现在方法体中我们创建了一个ActivityThread对象并执行了attach方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { ViewRootImpl.addFirstDrawHandler(new Runnable() { @Override public void run() { ensureJitEnabled(); } }); android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { mgr.releaseSomeActivities(mAppThread); } catch (RemoteException e) { } } } }); } else { ... } } 这里看一下重点实现，我们可以发现在方法体中调用了ActivityManagerNative.getDefault().attachApplication(mAppThread)看过我的前几篇文章的童鞋应该知道这里就是一个Binder进程间通讯，其实上执行的是ActivityManagerService.attachApplication方法，具体的可以参考前几篇文章的介绍，好吧，既然这样我们看一下ActivityManagerService.attachApplication方法的具体实现。 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 然后这里面又调用了attachApplicationLocked方法： 12345678private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat,getCommonServicesLocked(app.isolated),mCoreSettingsObserver.getCoreSettingsLocked()); ... 可以看到这里面又调用了IApplication.bindApplication，从方法名称中我们可以看出这里应该是绑定Application的方法，跟上面的ActivityManangerNative类似的，前面几篇文章中我们已经做过介绍，IApplicationThread是ActivityThread中ApplicationThread binder对象的客户端，所以这里最终调用的是ApplicationThread的bindApplication方法，既然这样，我们来看一下ApplicationThread的bindApplication的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) { if (services != null) { // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); } setCoreSettings(coreSettings); /* * Two possible indications that this package could be * sharing its runtime with other packages: * * 1.) the sharedUserId attribute is set in the manifest, * indicating a request to share a VM with other * packages with the same sharedUserId. * * 2.) the application element of the manifest has an * attribute specifying a non-default process name, * indicating the desire to run in another packages VM. * * If sharing is enabled we do not have a unique application * in a process and therefore cannot rely on the package * name inside the runtime. */ IPackageManager pm = getPackageManager(); android.content.pm.PackageInfo pi = null; try { pi = pm.getPackageInfo(appInfo.packageName, 0, UserHandle.myUserId()); } catch (RemoteException e) { } if (pi != null) { boolean sharedUserIdSet = (pi.sharedUserId != null); boolean processNameNotDefault = (pi.applicationInfo != null &amp;&amp; !appInfo.packageName.equals(pi.applicationInfo.processName)); boolean sharable = (sharedUserIdSet || processNameNotDefault); // Tell the VMRuntime about the application, unless it is shared // inside a process. if (!sharable) { VMRuntime.registerAppInfo(appInfo.packageName, appInfo.dataDir, appInfo.processName); } } AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableOpenGlTrace = enableOpenGlTrace; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; sendMessage(H.BIND_APPLICATION, data); } 好吧，最后调用了ActivityThread.sendMessage()… 123private void sendMessage(int what, Object obj) { sendMessage(what, obj, 0, 0, false); } 然后我们看一下其sendMessage的重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现这里调用了mH的sendMessage方法，最后通过Handler的异步消息机制被mH的handleMessage方法处理，然后根据Message.what选择处理分支，最终调用了ActivityThread的handleBindApplication方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private void handleBindApplication(AppBindData data) { ... // 创建Instrumentation if (data.instrumentationName != null) { InstrumentationInfo ii = null; try { ii = appContext.getPackageManager(). getInstrumentationInfo(data.instrumentationName, 0); } catch (PackageManager.NameNotFoundException e) { } if (ii == null) { throw new RuntimeException( &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName); } mInstrumentationPackageName = ii.packageName; mInstrumentationAppDir = ii.sourceDir; mInstrumentationSplitAppDirs = ii.splitSourceDirs; mInstrumentationLibDir = ii.nativeLibraryDir; mInstrumentedAppDir = data.info.getAppDir(); mInstrumentedSplitAppDirs = data.info.getSplitAppDirs(); mInstrumentedLibDir = data.info.getLibDir(); ApplicationInfo instrApp = new ApplicationInfo(); instrApp.packageName = ii.packageName; instrApp.sourceDir = ii.sourceDir; instrApp.publicSourceDir = ii.publicSourceDir; instrApp.splitSourceDirs = ii.splitSourceDirs; instrApp.splitPublicSourceDirs = ii.splitPublicSourceDirs; instrApp.dataDir = ii.dataDir; instrApp.nativeLibraryDir = ii.nativeLibraryDir; LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false); ContextImpl instrContext = ContextImpl.createAppContext(this, pi); try { java.lang.ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate instrumentation &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } mInstrumentation.init(this, instrContext, appContext, new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher, data.instrumentationUiAutomationConnection); if (mProfiler.profileFile != null &amp;&amp; !ii.handleProfiling &amp;&amp; mProfiler.profileFd == null) { mProfiler.handlingProfiling = true; File file = new File(mProfiler.profileFile); file.getParentFile().mkdirs(); Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024); } } else { mInstrumentation = new Instrumentation(); } ... / If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... try { mInstrumentation.onCreate(data.instrumentationArgs); } catch (Exception e) { throw new RuntimeException( &quot;Exception thrown in onCreate() of &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } try { mInstrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } finally { StrictMode.setThreadPolicy(savedPolicy); } } 这个方法的方法体比较长，我们挑重点的看，可以看到方法体中系统通过反射机制创建了Instrumentation对象，并执行了init方法，执行了Insrtumentation对象的初始化。然后我们调用了LockedApk.makeApplication方法创建了Application对象，我们来看一下其具体的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { if (mApplication != null) { return mApplication; } Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) { appClass = &quot;android.app.Application&quot;; } try { java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) { initializeJavaContextClassLoader(); } ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); } catch (Exception e) { if (!mActivityThread.mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to instantiate application &quot; + appClass + &quot;: &quot; + e.toString(), e); } } mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) { try { instrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!instrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) { final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) { continue; } rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); } return app; } 可以发现这里也是以反射的机制创建了Application对象，并创建了一个ContextImpl对象，并将Application与ContextImpl建立关联。。。 继续回到我们的ActivityThread的handleBindApplication方法，在创建了Application对象之后我们调用了Instrumentation的onCreate方法，然后调用了Instrumentation的callApplicationOnCreate方法，我们来看一下其具体实现： 123public void callApplicationOnCreate(Application app) { app.onCreate(); } 咋样？原来Application的onCreate生命周期方法是在这里回调滴啊。 这样我们整个Application的创建执行流程就讲解完了。 总结： 应用进程启动 –&gt; 创建Instrumentation –&gt; 创建Application对象 –&gt; 创建Application相关的ContextImpl对象； ActivityThread.main方法–&gt; ActivityManagerService.bindApplication方法 –&gt; ActivityThread.handleBindApplication –&gt; 创建Instrumentation，创建Application； 每个应用进程对应一个Instrumentation，对应一个Application； Instrumentation与Application都是通过java反射机制创建； Application创建过程中会同时创建一个ContextImpl对象，并建立关联； 接下来我们来看一下Acitivty中的Context创建流程，大家都知道我们Activity的具体创建过程是在ActivityThread的performLaunchActivity,可参见： android源码解析之（十四）–&gt;Activity启动流程，这里我们看一下其具体的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } if (!r.activity.mFinished) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } ... return activity; } 这里简要说明一下，Activity也是系统通过反射机制创建的，然后我们通过LockedApk.makeApplication创建一个Application，通过查看源码我们知道若这时候LockedApk中的mApplication不为空则直接返回当前的mApplication又因为当我们创建应用进程的时候Application已经被创建，所以当创建Activity的时候这时候Application肯定不为空，所以这时候返回的就是应用进程创建的时候创建的Application，这也从侧面说明了一个应用进程对应着一个Application。然后我们通过createBaseContextForActivity创建了一个ContextImpl对象。 123456789101112131415161718192021222324252627282930private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) { int displayId = Display.DEFAULT_DISPLAY; try { displayId = ActivityManagerNative.getDefault().getActivityDisplayId(r.token); } catch (RemoteException e) { } ContextImpl appContext = ContextImpl.createActivityContext( this, r.packageInfo, displayId, r.overrideConfig); appContext.setOuterContext(activity); Context baseContext = appContext; final DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance(); // For debugging purposes, if the activity's package name contains the value of // the &quot;debug.use-second-display&quot; system property as a substring, then show // its content on a secondary display if there is one. String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;); if (pkgName != null &amp;&amp; !pkgName.isEmpty() &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) { for (int id : dm.getDisplayIds()) { if (id != Display.DEFAULT_DISPLAY) { Display display = dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id)); baseContext = appContext.createDisplayContext(display); break; } } } return baseContext; } 可以发现这里创建了一个ContextImpl对象，并通过ContextImpl的setOuterContext方法，让该ContextImpl持有了Activity的引用，继续往下看，我们调用了activity.attach方法，查看一下该方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 除了一下初始化操作之外，还调用了attachBaseContext方法，让Activity持有了ContextImpl的引用，这样就相当于Activity与ContextImpl对象相互持有了对方的引用，并且Activity是继承与Context。 总结： Activity中创建ContextImpl对象的具体实现在ActivityThread的performLauncherAcitivty方法中； Activity的创建伴随着ContextImpl的创建，二者相互持有对方的引用； 创建Activity –&gt; 创建Activity相关ContextImpl对象； 创建应用进程 –&gt; 创建Application –&gt; 创建Application相关ContextImpl对象； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程","link":"/2022/08/06/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"应用进程启动流程(转)","text":"转载请标明出处：一片枫叶的专栏 在android guide中有这样的一段关于android应用程序进程的描述： 1By default, every application runs in its own Linux process. Android starts the process when any of the application's components need to be executed, then shuts down the process when it's no longer needed or when the system must recover memory for other applications. 每一个android应用默认都是在他自己的linux进程中运行。android操作系统会在这个android应用中的组件需要被执行的时候启动这个应用进程，并且会在这个应用进程没有任何组件执行或者是系统需要为其他应用申请更多内存的时候杀死这个应用进程。所以当我们需要启动这个应用的四大组件之一的时候如果这个应用的进程还没有启动，那么就会先启动这个应用程序进程。 本节主要是通过分析Activity的启动过程介绍应用程序进程的启动流程。 在上一篇文章中我们简要的介绍了Launcher的启动流程，在SystemServer进程执行完成，各种系统服务启动完成之后，会调用ActivityManagerService中的systemReady()方法，在systemReady（）方法中会执行Launcher启动的相关逻辑了，具体可以参考： android源码解析之（十）–&gt;Launcher启动流程 Launcher应用程序在启动过程中会通过PackageManagerService服务请求查询系统所有的已安装应用的包名，图标和应用名称等信息，然后填充到Launcher中的Adapter中，这样点击某一项应用图标的时候就可以根据该图标的包名和启动Activity的类名初始化Intent对象，然后调用startActivity(Intent)启动相关的应用程序了。 其实android中应用进程可以通过许多方式启动，比如启动一个Activity，启动一个Service，启动一个ContentProvider或者是一个BroadcastReceiver，也就是说我们可以通过启动四大组件的方式启动应用进程，在应用进程没有启动的时候，如果我们通过启动这些组件，这时候系统会判断当前这些组件所需要的应用进程是否已经启动，若没有的话，则会启动应用进程。 这里我们通过Launcher简单分析一下应用进程的启动流程。通过上一篇Launcher启动流程，我们知道每一个launcher中的图标对应着一个应用报名和启动activity类名，查看LauncherActivity中的图标点击事件: 1234protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); } 在通过应用包名和启动activity类名构造完成Intent之后，我们调用了startActivity方法来启动这个activity，很明显的，当前这个应用并没有启动，也就是说我们调用的startActivity方法不单单为我们启动了这个activity也同时在启动activity之前启动了这个应用进程，好了，那我们这里就以这个方法为入口分析一下应用进程的启动流程。 跟踪代码到Activity，发现其调用了startActivity的重载方法： 1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); } 继续跟进： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 很明显的我们此时传递的options为空： 123public void startActivityForResult(Intent intent, int requestCode) { startActivityForResult(intent, requestCode, null); } 好吧，最后调用的还是这个重载方法： 123456789101112131415161718192021222324252627public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现这里调用了mInstrumentation.execStartActivity方法，这里先简单介绍一下Instrumentation对象，他是Android系统中应用程序端操作Activity的具体操作类，这里的操作段是相对于ActivityManagerService服务端来说的。也就是说当我们在执行对Activity的具体操作时，比如回调生命周期的各个方法都是借助于Instrumentation类来实现的。 好了，下面我们继续看一下Instrumentation的execStartActivity方法： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 这里主要关注这个代码： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这断代码实际上是进程间通讯，我们可以发现ActivityManagerNative继承于Binder接口，所以ActivityManagerNative就是一个Binder对象，然后上面一节我们介绍SystemServer进程的时候对ActivityManagerService有过了解，发现其继承于ActivityManagerNative，好吧，了解过Binder机制的童鞋就知道了，ActivityManagerService就是这个Binder机制的服务器端而ActivityManagerNative就是这个Binder机制的客户端，所以我们这里调用的startActivity实际上是讲参数传递给ActivityManagerService并执行ActivityManagerService的startActivity方法。 既然这样，我们看一下ActivityManagerService的startActivity方法： 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 调用了startActivityAsUser方法，然后我们继续看一下startActivityAsUser方法： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 继续查看startActivityMayWait方法： 1234567891011121314151617181920final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } } 这个方法的逻辑比较多，我们重点关注的是其调用了startActivityLocked方法，也就是说在初始化其他逻辑之后，这个方法会调用startActivityLocked方法： 123err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); 代码量也是比较大的，在方法体中调用了startActivityUncheckedLocked方法，然后我们继续跟进startActivityUncheckedLocked方法： 1targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); 然后我们查看startActivityLocked方法的实现： 123if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } 可以发现其调用了resumeTopActivitiesLocked方法： 1stack.resumeTopActivityLocked(null); 继续跟进： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后我们看一下resumeTopActivityLocked方法的实现： 1result = resumeTopActivityInnerLocked(prev, options); 继续查看resumeTopActivityInnerLocked方法的实现： 1mStackSupervisor.startSpecificActivityLocked(next, true, true); 可以发现在方法体中执行了相关逻辑判断与初始化操作之后调用了startSpecificActivityLocked方法： 12mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); 可以发现在方法体中调用了startProcessLocked方法，从名字可以看出来这个方法就是启动进程的。 12345678910final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) { return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */); } 查看startProcessLocked方法的实现： 1234checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;); startProcessLocked( app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, &quot;startProcess: done starting proc!&quot;); 查看startProcessLocked方法的具体实现； 123456checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); 查看关键代码，这里调用了Process.start方法： 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 这里的processClass就是要启动的进程的名称，这里传递的就是ActivityThread： 1&quot;android.app.ActivityThread&quot; 具体的Process启动进程的Native层代码这里不做过多的分析，这个方法就是启动了AcitivtyThread进程并执行了ActivityThread的main方法，所以我们经常说的进程的启动方法就是ActivityThread的main方法就是这里体现的。 总结： android应用进程会在需要启动其组件的时候启动，当没有任何组件运行或者是系统内存较低的时候应用进程会被杀死。 在启动应用四大组件的时候若发现当前应用的进程没有启动，则会首先启动应用程序的进程。 我们可以为应用程序配置多个进程，每个进程都有自己的JVM和运行环境，各个进程之间的通讯需要通过Binder机制。 Launcher启动的过程也是先启动Launcher进程再启动其Activity组件。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程","link":"/2022/08/06/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"截屏事件流程","text":"今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。 我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。 在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** {@inheritDoc} */ @Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { ... final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; } 然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理： 123456789101112131415161718192021222324252627282930313233343536@Override public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { if (!mSystemBooted) { // If we have not yet booted, don't let key events do anything. return 0; } ... // Handle special keys. switch (keyCode) { case KeyEvent.KEYCODE_VOLUME_DOWN: case KeyEvent.KEYCODE_VOLUME_UP: case KeyEvent.KEYCODE_VOLUME_MUTE: { if (mUseTvRouting) { // On TVs volume keys never go to the foreground app result &amp;= ~ACTION_PASS_TO_USER; } if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { if (down) { if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } } else { mScreenshotChordVolumeDownKeyTriggered = false; cancelPendingScreenshotChordAction(); } } ... return result; } 可以发现这里首先判断当前系统是否已经boot完毕，若尚未启动完毕，则所有的按键操作都将失效，若启动完成，则执行后续的操作，这里我们只是关注音量减少按键和电源按键组合的处理事件。另外这里多说一句想安卓系统的HOME按键事件，MENU按键事件，进程列表按键事件等等都是在这里实现的，后续中我们会陆续介绍这方面的内容。 回到我们的interceptKeyBeforeQueueing方法，当我用按下音量减少按键的时候回进入到：case KeyEvent.KEYCODE_VOLUME_MUTE分支并执行相应的逻辑，然后同时判断用户是否按下了电源键，若同时按下了电源键，则执行： 12345678if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } 可以发现这里的interceptScreenshotChrod方法就是系统准备开始执行截屏操作的开始，我们继续看一下interceptcreenshotChord方法的实现。 123456789101112131415private void interceptScreenshotChord() { if (mScreenshotChordEnabled &amp;&amp; mScreenshotChordVolumeDownKeyTriggered &amp;&amp; mScreenshotChordPowerKeyTriggered &amp;&amp; !mScreenshotChordVolumeUpKeyTriggered) { final long now = SystemClock.uptimeMillis(); if (now &lt;= mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS &amp;&amp; now &lt;= mScreenshotChordPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) { mScreenshotChordVolumeDownKeyConsumed = true; cancelPendingPowerKeyAction(); mHandler.postDelayed(mScreenshotRunnable, getScreenshotChordLongPressDelay()); } } } 在方法体中我们最终会执行发送一个延迟的异步消息，请求执行截屏的操作而这里的延时时间，若当前输入框是打开状态，则延时时间为输入框关闭时间加上系统配置的按键超时时间，若当前输入框没有打开则直接是系统配置的按键超时处理时间，可看一下getScreenshotChordLongPressDelay方法的具体实现。 12345678private long getScreenshotChordLongPressDelay() { if (mKeyguardDelegate.isShowing()) { // Double the time it takes to take a screenshot from the keyguard return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER * ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } return ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout(); } 回到我们的interceptScreenshotChord方法，发送了异步消息之后系统最终会被我们发送的Runnable对象的run方法执行，这里关于异步消息的逻辑可参考：android源码解析之（二）–&gt;异步消息机制 这样我们看一下Runnable类型的mScreenshotRunnable的run方法的实现: 123456private final Runnable mScreenshotRunnable = new Runnable() { @Override public void run() { takeScreenshot(); } }; 好吧，方法体中并未执行其他操作，直接就是调用了takeScreenshot方法，这样我们继续看一下takeScreenshot方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void takeScreenshot() { synchronized (mScreenshotLock) { if (mScreenshotConnection != null) { return; } ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;, &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;); Intent intent = new Intent(); intent.setComponent(cn); ServiceConnection conn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { synchronized (mScreenshotLock) { if (mScreenshotConnection != this) { return; } Messenger messenger = new Messenger(service); Message msg = Message.obtain(null, 1); final ServiceConnection myConn = this; Handler h = new Handler(mHandler.getLooper()) { @Override public void handleMessage(Message msg) { synchronized (mScreenshotLock) { if (mScreenshotConnection == myConn) { mContext.unbindService(mScreenshotConnection); mScreenshotConnection = null; mHandler.removeCallbacks(mScreenshotTimeout); } } } }; msg.replyTo = new Messenger(h); msg.arg1 = msg.arg2 = 0; if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; try { messenger.send(msg); } catch (RemoteException e) { } } } @Override public void onServiceDisconnected(ComponentName name) {} }; if (mContext.bindServiceAsUser( intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) { mScreenshotConnection = conn; mHandler.postDelayed(mScreenshotTimeout, 10000); } } } 可以发现这里通过反射机制创建了一个TakeScreenshotService对象然后调用了bindServiceAsUser，这样就创建了TakeScreenshotService服务并在服务创建之后发送了一个异步消息。好了，我们看一下TakeScreenshotService的实现逻辑。 1234567891011121314151617181920212223242526272829303132public class TakeScreenshotService extends Service { private static final String TAG = &quot;TakeScreenshotService&quot;; private static GlobalScreenshot mScreenshot; private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case 1: final Messenger callback = msg.replyTo; if (mScreenshot == null) { mScreenshot = new GlobalScreenshot(TakeScreenshotService.this); } mScreenshot.takeScreenshot(new Runnable() { @Override public void run() { Message reply = Message.obtain(null, 1); try { callback.send(reply); } catch (RemoteException e) { } } }, msg.arg1 &gt; 0, msg.arg2 &gt; 0); } } }; @Override public IBinder onBind(Intent intent) { return new Messenger(mHandler).getBinder(); }} 可以发现在在TakeScreenshotService类的定义中有一个Handler成员变量，而我们在启动TakeScreentshowService的时候回发送一个异步消息，这样就会执行mHandler的handleMessage方法，然后在handleMessage方法中我们创建了一个GlobalScreenshow对象，然后执行了takeScreenshot方法，好吧，继续看一下takeScreentshot方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Takes a screenshot of the current display and shows an animation. */ void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) { // We need to orient the screenshot correctly (and the Surface api seems to take screenshots // only in the natural orientation of the device :!) mDisplay.getRealMetrics(mDisplayMetrics); float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels}; float degrees = getDegreesForRotation(mDisplay.getRotation()); boolean requiresRotation = (degrees &gt; 0); if (requiresRotation) { // Get the dimensions of the device in its native orientation mDisplayMatrix.reset(); mDisplayMatrix.preRotate(-degrees); mDisplayMatrix.mapPoints(dims); dims[0] = Math.abs(dims[0]); dims[1] = Math.abs(dims[1]); } // Take the screenshot mScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } // Optimizations mScreenBitmap.setHasAlpha(false); mScreenBitmap.prepareToDraw(); // Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); } 可以看到这里后两个参数：statusBarVisible，navBarVisible是否可见，而这两个参数在我们PhoneWindowManager.takeScreenshot方法传递的： 1234if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; 可见若果mStatusBar可见，则传递的statusBarVisible为true，若mNavigationBar可见，则传递的navBarVisible为true。然后我们在截屏的时候判断nStatusBar是否可见，mNavigationBar是否可见，若可见的时候则截屏同样将其截屏出来。继续回到我们的takeScreenshot方法，然后调用了： 12// Take the screenshotmScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); 方法，看注释，这里就是执行截屏事件的具体操作了，然后我看一下SurfaceControl.screenshot方法的具体实现，另外这里需要注意的是，截屏之后返回的是一个Bitmap对象，其实熟悉android绘制机制的童鞋应该知道android中所有显示能够显示的东西，在内存中表现都是Bitmap对象。 1234567public static Bitmap screenshot(int width, int height) { // TODO: should take the display as a parameter IBinder displayToken = SurfaceControl.getBuiltInDisplay( SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN); return nativeScreenshot(displayToken, new Rect(), width, height, 0, 0, true, false, Surface.ROTATION_0); } 好吧，这里调用的是nativeScreenshot方法，它是一个native方法，具体的实现在JNI层，这里就不做过多的介绍了。继续回到我们的takeScreenshot方法，在调用了截屏方法screentshot之后，判断是否截屏成功： 12345if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } 若截屏之后，截屏的bitmap对象为空，这里判断截屏失败，调用了notifyScreenshotError方法，发送截屏失败的notification通知。 123456789101112131415161718192021static void notifyScreenshotError(Context context, NotificationManager nManager) { Resources r = context.getResources(); // Clear all existing notification, compose the new notification and show it Notification.Builder b = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_failed_title)) .setContentTitle(r.getString(R.string.screenshot_failed_title)) .setContentText(r.getString(R.string.screenshot_failed_text)) .setSmallIcon(R.drawable.stat_notify_image_error) .setWhen(System.currentTimeMillis()) .setVisibility(Notification.VISIBILITY_PUBLIC) // ok to show outside lockscreen .setCategory(Notification.CATEGORY_ERROR) .setAutoCancel(true) .setColor(context.getColor( com.android.internal.R.color.system_notification_accent_color)); Notification n = new Notification.BigTextStyle(b) .bigText(r.getString(R.string.screenshot_failed_text)) .build(); nManager.notify(R.id.notification_screenshot, n); } 然后继续看takeScreenshot方法，判断截屏的图像是否需要旋转，若需要的话，则旋转图像： 1234567891011121314if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } 在takeScreenshot方法的最后若截屏成功，我们调用了： 123// Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); 开始截屏的动画，好吧，看一下动画效果的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Starts the animation after taking the screenshot */ private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible, boolean navBarVisible) { // Add the view for the animation mScreenshotView.setImageBitmap(mScreenBitmap); mScreenshotLayout.requestFocus(); // Setup the animation with the screenshot just taken if (mScreenshotAnimation != null) { mScreenshotAnimation.end(); mScreenshotAnimation.removeAllListeners(); } mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams); ValueAnimator screenshotDropInAnim = createScreenshotDropInAnimation(); ValueAnimator screenshotFadeOutAnim = createScreenshotDropOutAnimation(w, h, statusBarVisible, navBarVisible); mScreenshotAnimation = new AnimatorSet(); mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim); mScreenshotAnimation.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Save the screenshot once we have a bit of time now saveScreenshotInWorkerThread(finisher); mWindowManager.removeView(mScreenshotLayout); // Clear any references to the bitmap mScreenBitmap = null; mScreenshotView.setImageBitmap(null); } }); mScreenshotLayout.post(new Runnable() { @Override public void run() { // Play the shutter sound to notify that we've taken a screenshot mCameraSound.play(MediaActionSound.SHUTTER_CLICK); mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null); mScreenshotView.buildLayer(); mScreenshotAnimation.start(); } }); } 好吧，经过着一些列的操作之后我们实现了截屏之后的动画效果了，这里暂时不分析动画效果，我们看一下动画效果之后做了哪些？还记不记的一般情况下我们截屏之后都会收到一个截屏的notification通知？这里应该也是在其AnimatorListenerAdapter的onAnimationEnd方法中实现的，也就是动画执行完成之后，我们看一下其saveScreenshotInWorkerThread方法的实现： 1234567891011121314151617/** * Creates a new worker thread and saves the screenshot to the media store. */ private void saveScreenshotInWorkerThread(Runnable finisher) { SaveImageInBackgroundData data = new SaveImageInBackgroundData(); data.context = mContext; data.image = mScreenBitmap; data.iconSize = mNotificationIconSize; data.finisher = finisher; data.previewWidth = mPreviewWidth; data.previewheight = mPreviewHeight; if (mSaveInBgTask != null) { mSaveInBgTask.cancel(false); } mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager, R.id.notification_screenshot).execute(data); } 好吧，这里主要逻辑就是构造了一个SaveImageInBackgroundTask对象，看样子发送截屏成功的通知应该是在这里实现的，我们看一下SaveImageInBackgroundTask构造方法的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data, NotificationManager nManager, int nId) { ... // Show the intermediate notification mTickerAddSpace = !mTickerAddSpace; mNotificationId = nId; mNotificationManager = nManager; final long now = System.currentTimeMillis(); mNotificationBuilder = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? &quot; &quot; : &quot;&quot;)) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setWhen(now) .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color)); mNotificationStyle = new Notification.BigPictureStyle() .bigPicture(picture.createAshmemBitmap()); mNotificationBuilder.setStyle(mNotificationStyle); // For &quot;public&quot; situations we want to show all the same info but // omit the actual screenshot image. mPublicNotificationBuilder = new Notification.Builder(context) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setCategory(Notification.CATEGORY_PROGRESS) .setWhen(now) .setColor(r.getColor( com.android.internal.R.color.system_notification_accent_color)); mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build()); Notification n = mNotificationBuilder.build(); n.flags |= Notification.FLAG_NO_CLEAR; mNotificationManager.notify(nId, n); // On the tablet, the large icon makes the notification appear as if it is clickable (and // on small devices, the large icon is not shown) so defer showing the large icon until // we compose the final post-save notification below. mNotificationBuilder.setLargeIcon(icon.createAshmemBitmap()); // But we still don't set it for the expanded view, allowing the smallIcon to show here. mNotificationStyle.bigLargeIcon((Bitmap) null); } 可以发现在构造方法的后面狗仔了一个NotificationBuilder对象，然后发送了一个截屏成功的Notification，这样我们在截屏动画之后就收到了Notification的通知了。 总结： 在PhoneWindowManager的dispatchUnhandledKey方法中处理App无法处理的按键事件，当然也包括音量减少键和电源按键的组合按键 通过一系列的调用启动TakeScreenshotService服务，并通过其执行截屏的操作。 具体的截屏代码是在native层实现的。 截屏操作时候，若截屏失败则直接发送截屏失败的notification通知。 截屏之后，若截屏成功，则先执行截屏的动画，并在动画效果执行完毕之后，发送截屏成功的notification的通知。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程","link":"/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"clash托管配置文件格式不正确rules[0] [RULE SET,Reject,AdBlock] error:unsupported rule type RULE-SET","text":"更新了一波config后发现打开无响应，删除 .config/clash之后可以正常打开 然后通过url来导入 yaml文件的时候提示 托管配置文件格式不正确:rules[0]RULE-SET,Reject,AdBlock error: unsupported rule type RULE-SET 后把脚本内下面这段删了 现在可以正常使用了 rules: RULE-SET,Reject,AdBlock RULE-SET,Special,DIRECT RULE-SET,Netflix,Netflix RULE-SET,Spotify,Spotify RULE-SET,YouTube,YouTube RULE-SET,Disney Plus,Disney RULE-SET,Bilibili,AsianTV RULE-SET,iQiyi,AsianTV RULE-SET,Letv,AsianTV RULE-SET,Netease Music,AsianTV RULE-SET,Tencent Video,AsianTV RULE-SET,Youku,AsianTV RULE-SET,WeTV,AsianTV RULE-SET,ABC,GlobalTV RULE-SET,Abema TV,GlobalTV RULE-SET,Amazon,GlobalTV RULE-SET,Apple News,GlobalTV RULE-SET,Apple TV,GlobalTV RULE-SET,Bahamut,GlobalTV RULE-SET,BBC iPlayer,GlobalTV RULE-SET,DAZN,GlobalTV RULE-SET,Discovery Plus,GlobalTV RULE-SET,encoreTVB,GlobalTV RULE-SET,Fox Now,GlobalTV RULE-SET,Fox+,GlobalTV RULE-SET,HBO,GlobalTV RULE-SET,Hulu Japan,GlobalTV RULE-SET,Hulu,GlobalTV RULE-SET,Japonx,GlobalTV RULE-SET,JOOX,GlobalTV RULE-SET,KKBOX,GlobalTV RULE-SET,KKTV,GlobalTV RULE-SET,Line TV,GlobalTV RULE-SET,myTV SUPER,GlobalTV RULE-SET,Pandora,GlobalTV RULE-SET,PBS,GlobalTV RULE-SET,Pornhub,GlobalTV RULE-SET,Soundcloud,GlobalTV RULE-SET,ViuTV,GlobalTV RULE-SET,Telegram,Telegram RULE-SET,Steam,Steam RULE-SET,Speedtest,Speedtest RULE-SET,PayPal,PayPal RULE-SET,Microsoft,Microsoft RULE-SET,PROXY,Proxy RULE-SET,Apple,Apple RULE-SET,Domestic,Domestic RULE-SET,Domestic IPs,Domestic RULE-SET,LAN,DIRECT GEOIP,CN,Domestic MATCH,Others","link":"/2022/08/06/%E6%89%98%E7%AE%A1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E7%A1%AE/"},{"title":"排序算法分类","text":"稳定的冒泡排序（bubble sort）— O(n2)鸡尾酒排序（cocktail sort,双向的冒泡排序）—O(n2)插入排序（insertion sort）—O(n2)桶排序（bucket sort）—O(n);需要O(k)额外空间计数排序（counting sort）—O(n+k);需要O(n+k)额外空间归并排序（merge sort）—O(n log n);需要O(n)额外空间原地归并排序— O（n2）二叉排序树排序（binary tree sort）— O(n log n)期望时间; O(n2)最坏时间;需要O(n)额外空间鸽巢排序（pigeonhole sort）—O(n+k);需要O(k)额外空间基数排序（radix sort）—O(n·k);需要O(n)额外空间侏儒排序（gnome sort）— O(n2)图书馆排序（library sort）— O(n log n) with high probability,需要(1+ε)n额外空间不稳定选择排序（selection sort）—O(n2)希尔排序（shell sort）—O(n log n)如果使用最佳的现在版本组合排序— O(n log n)堆排序（heap sort）—O(n log n)平滑排序（smooth sort）— O(n log n)快速排序（quick sort）—O(n log n)期望时间, O(n2)最坏情况;对于大的、乱数列表一般相信是最快的已知排序内省排序（introsort）—O(n log n)耐心排序（patience sort）—O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子串行（longest increasing subsequence）不实用的排序算法Bogo排序— O(n × n!)，最坏的情况下期望时间为无穷。Stupid排序—O(n3);递归版本需要O(n2)额外存储器珠排序（bead sort）— O(n) or O(√n),但需要特别的硬件Pancake sorting—O(n),但需要特别的硬件臭皮匠排序（stooge sort）算法简单，但需要约n^2.7的时间","link":"/2022/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/"},{"title":"快速手动搭建SS服务器简明详细教程","text":"优惠购买搬瓦工搬瓦工VPS相对其它的云服务产商来说，性价比高，使用起来速度快。通过优惠码购买还能再降低最多 %6 的一些费用。在这基础上使用优惠码可以少一些费用，根据你对配置的需要进行选择服务器，以下是可以获取优惠码的链接： 搬瓦工配置 搬瓦工费用 优惠链接 20G KVM – PROMO SSD硬盘: 20 GB RAID-10 RAM内存: 1024 MB CPU处理器: 2x Intel Xeon Transfer流量: 1 TB/mo 连接速度: 1 Gigabit Multiple locations $25.99/半年 点击进入 *SPECIAL 40G KVM PROMO V3 - LOS ANGELES - CN2 * SSD硬盘: 40 GB RAID-10 RAM内存: 2048 MB CPU处理器: 1x Intel Xeon Transfer流量: 2000 GB/月 连接速度: 1 Gigabit 洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 $27.99/季 点击进入 *SPECIAL 20G KVM PROMO V3 - LOS ANGELES - CN2 * SSD硬盘: 20 GB RAID-10 RAM内存: 1024 MB CPU处理器: 1x Intel Xeon Transfer流量: 1000 GB/月 连接速度: 1 Gigabit 洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 $29.99 /半年 点击进入 80G KVM – PROMO SSD硬盘: 80 GB RAID-10 RAM内存: 4 GB CPU处理器: 4x Intel Xeon Transfer流量: 3 TB/mo 连接速度: 1 Gigabit Multiple locations $19.99/月 点击进入 20G KVM – PROMO SSD硬盘: 20 GB RAID-10 RAM内存: 1024 MB CPU处理器: 2x Intel Xeon Transfer流量: 1 TB/mo 连接速度: 1 Gigabit Multiple locations $49.99/年 点击进入 40G KVM – PROMO SSD硬盘: 40 GB RAID-10 RAM内存: 2 GB CPU处理器: 3x Intel Xeon Transfer流量: 2 TB/mo 连接速度: 1 Gigabit Multiple locations $99.99/年 点击进入 160G KVM – PROMO SSD硬盘: 160 GB RAID-10 RAM内存: 8 GB CPU处理器: 5x Intel Xeon Transfer流量: 4 TB/mo 连接速度: 1 Gigabit Multiple locations $39.99/月 点击进入 3200G KVM – PROMO SSD硬盘: 320 GB RAID-10 RAM内存: 16 GB CPU处理器: 6x Intel Xeon Transfer流量: 5 TB/mo 连接速度: 1 Gigabit Multiple locations $79.99/月 点击进入 进入之后就可以获取优惠码了，选择完之后不要急着点击 「Add to Cart」。 这时候就可以获取隐藏的优惠码了，我们对着这个网页：鼠标右击--&gt;查看网页源代码。 接着 Ctrl + F 搜索 code ，这时候你就会看到 Try this promo code: xxxx，这里的xxxx就是优惠吗，把它复制下来。 页面的 Location 就是选择服务器的地址，到时访问谷歌的时候会显示你当前访问的地址。好了，我们点击「Add to Cart」。 接下来，进入结算页面，我们刚才复制的优惠码就派上用场了，将你刚刚复制的优惠码复制进去然后点击 「Validate Code」，看！是不是优惠了！一般人不知道这种操作: 接着点击「CheckOut」完成付款即可。付款的时候选择 Alipay 就可以使用支付宝付款。 获取搬瓦工服务器的ip，端口，账号密码购买完毕后你就拥有一台你自己的服务器了，接着点击Services下的MyServices，可以看到你的服务器： 我们点击「KiwiVM Control Panel」进入管理界面： 可以看到你服务器的信息: 有了搬瓦工服务器的IP地址和端口,我们就可以连接了： 账号是root，密码可以在这里获取： 使用 SSH 工具连接到搬瓦工服务器 远程连接工具我一直用的是 SecureCRT , 当然你也可以使用其它的 SSH 工具。破解版的SecureCRT可以在百度网盘这里获取： 链接: https://pan.baidu.com/s/11W4WHjCjmiNw6einQNrcPg 提取码: tyux 开始快读搭建ss服务器安装 wget ：12yum install wget 执行安装ss：12wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 获取shadowsocks.sh读取权限12chmod +x shadowsocks.sh 设置ss密码端口和加密方式当你输入./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log后就可以设置密码和端口号了： 设置完密码和端口号之后，我们选择加密方式，这里选择 7： 接着按任意键进行安装。 安装ss完成等一会之后，就安装完成了，它会给你显示你需要连接vpn的信息： 可以看到需要连接ss的ip地址，密码，端口，和加密方式。 将这些信息保存起来，那么这时候你就可以使用它们来科学上网啦。 使用Shadowsocks打开 Shadowsocks 客户端，输入ip地址，密码，端口，和加密方式。接着点击确定，右下角会有个小飞机按钮，右键–&gt;启动代理。 这时候就可以科学上网了。 访问以下 Youtube 和 Google 试试看，速度还可以的： 使用BBR加速器让访问速度加速，飞起来！使用 BBR 加速工具。 安装 BBR12wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 获取读写权限12chmod +x bbr.sh 启动BBR安装12./bbr.sh 接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。 重新启动之后，输入 lsmod | grep bbr 如果看到 tcp_bbr 就说明 BBR 已经启动了。 再访问一下 Youtube，1080p 超高清，很顺畅不卡顿！ 本文为转载，出处 https://www.cnbanwagong.com/6.html","link":"/2022/08/04/%E6%90%AC%E7%93%A6%E5%B7%A5%E5%BF%AB%E9%80%9F%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BASS(Shadowsocks)%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"搭建 WordPress 博客教程（超详细）","text":"本文转自：Nonecy 的小黑屋链接：http://blog.studymany.com/2018/07/29/create-wordpress-blog/ 需要 一台服务器 一个域名，直接通过ip访问好傻好傻的样子，哈哈。 linux知识 肯折腾 具体步骤第一步购买服务器，国内阿里云的云服务器挺不错的，国外的就更多了，这一步就不介绍了，不懂得的自己上网搜。接下来操作需要： 远程连接服务器Windows 用户 以Xshell为例。 下载安装Xshell，官网链接。 安装完成后新建会话（Alt+N）。依次填写图中信息。名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address，端口号选择22。 连接 点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username（一般都是root），密码为之前的Password（这个建议直接复制粘贴过来，系统给的有点复杂） 用户身份验证 填写完之后点击确定。然后点击连接。出现其他提示的话选择接受就可以了。这时你就可以看到一个命令控制台了。这时就算连接成功了。 Mac OS 用户 打开终端或者iTerm2等。 1ssh root@45.32.195.77 然后输入密码即可。 安装nginx，mysql，php建议使用lnmp一键安装包安装，方便快捷。如果不用一键安装包，我估计得研究这一块的东西大概一周吧。下面以一键安装包为例。 获取lnmp一键安装包链接 lnpm官网链接 找到下载页面选择最新的复制其链接。 写此文时最新版本信息如下： 1234LNMP 1.4 测试版http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz (131KB)MD5：bd851e151b2ba13c3a32c435efb1a76c最后更新: 2017年2月14日14:18 GMT+8 其中的http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz就是我们需要的链接，复制到剪贴板。 安装 12345678# 下载，后边的路径直接粘贴就好。XShell上面复制快捷键是ctrl+insert，粘贴快捷键是Shift+insert，mac上面是我们熟悉的 command+c，command+vwget http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz# 解压tar -zxvf lnmp1.4beta.tar.gz# 进入lnmp目录cd lnmp1.4# 执行install.sh进行安装./install.sh lnmp 依次输入你要安装的选项前的数字并回车即可下一步。 MYSQL 选项 123456789You have 5 options for your DataBase install.1: Install MySQL 5.1.732: Install MySQL 5.5.53 (Default)3: Install MySQL 5.6.344: Install MySQL 5.7.165: Install MariaDB 5.5.536: Install MariaDB 10.0.287: Install MariaDB 10.1.190: DO NOT Install MySQL/MariaDBEnter your choice (1, 2, 3, 4, 5, 6, 7 or 0): 此处根据所需选择，如果使用的上述服务器，请选择2或者直接回车。我选择默认。 注意：安装MySql时，如果选择太高的版本安装会被拒绝，提示信息如下 Memory less than 1GB, can't install MySQL 5.6, 5.7 or MairaDB 10!。根据个人手动安装MySql5.7的经验来看，此768MB内存的服务器在运行一个nginx，mysql，php时还好，倘若再运行一个tomcat，mysql将会不定期down掉。所以此处选择一个低版本的5.5MySql即可。 1234You will install MySQL 5.5.53===========================Please setup root password of MySQL.(Default password: root)Please enter: 输入密码回车或直接回车，直接回车默认密码为root。此处做实验我选择默认，个人实际使用请修改。 1234MySQL root password: root===========================Do you want to enable or disable the InnoDB Storage Engine?Default enable,Enter your choice [Y/n]: 输入Y或者n然后回车或直接回车，直接回车默认启用InnoDB存储引擎。我选择默认。 1234567891011No input,The InnoDB Storage Engine will enable.===========================You have 6 options for your PHP install.1: Install PHP 5.2.172: Install PHP 5.3.293: Install PHP 5.4.454: Install PHP 5.5.38 (Default)5: Install PHP 5.6.306: Install PHP 7.0.157: Install PHP 7.1.1Enter your choice (1, 2, 3, 4, 5, 6 or 7): 输入选项然后回车或者直接回车，直接回车默认安装PHP5.5.38版本。我选择默认。 12345You will install PHP 7.1.1===========================You have 3 options for your Memory Allocator install.1: Don't install Memory Allocator. (Default)2: Install Jemalloc3: Install TCMalloc 输入选项然后回车或者直接回车，直接回车默认不安装内存分配器。我选择默认。 此时出现 1Press any key to install...or Press Ctrl+c to cancel 当然是摁任意键啦，一般都是回车咯。 然后出现一大堆信息。前几行如下： 12345678910111213You will install lnmp stack.nginx-1.10.3mysql-5.5.53php-5.5.38Enable InnoDB: yPrint lnmp.conf infomation...Download Mirror: http://soft.vpser.netNginx Additional Modules: PHP Additional Modules: Database Directory: /usr/local/mysql/varDefault Website Directory: /home/wwwroot/defaultCentOS release 6.8 (Final)Kernel \\r on an \\m 这一堆东西你就不用管啦。本次实验的开始时间23:04……经过了漫长漫长漫长的等待之后……大概23:35结束。所以期间你去洗个澡看个电视剧都不是问题。然后我们看到屏幕上最后输出的信息如下。 1234The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.Add Startup and Starting LNMP...Add nginx service at system startup...Starting nginx... doneAdd mysql service at system startup...Starting MySQL... SUCCESS! Add php-fpm service at system startup...Starting php-fpm done============================== Check install ==============================Checking ...Nginx: OKMySQL: OKPHP: OKPHP-FPM: OKClean src directory...+------------------------------------------------------------------------+| LNMP V1.4 for CentOS Linux Server, Written by Licess |+------------------------------------------------------------------------+| For more information please visit https://lnmp.org |+------------------------------------------------------------------------+| lnmp status manage: lnmp {start|stop|reload|restart|kill|status} |+------------------------------------------------------------------------+| phpMyAdmin: http://IP/phpmyadmin/ || phpinfo: http://IP/phpinfo.php || Prober: http://IP/p.php |+------------------------------------------------------------------------+| Add VirtualHost: lnmp vhost add |+------------------------------------------------------------------------+| Default directory: /home/wwwroot/default |+------------------------------------------------------------------------+| MySQL/MariaDB root password: root |+------------------------------------------------------------------------++-------------------------------------------+| Manager for LNMP, Written by Licess |+-------------------------------------------+| https://lnmp.org |+-------------------------------------------+nginx (pid 715 713) is running...php-fpm is runing! SUCCESS! MySQL running (1247)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp6 0 0 :::22 :::* LISTEN Install lnmp V1.4 completed! enjoy it. 简单说明一下，此安装过程安装完成便也启动了nginx，mysql，php-fpm并加入了开机启动项。如果重启服务器，不需要再单独手动开启相关的服务了。总的来说相当方便的。 关于Linux服务，自己之前做的笔记分享给大家。Linux 服务管理 这时候你在浏览器输入http://IP 例如 http://45.32.195.77便可以访问了。看到的内容如下： 访问页面 网站根目录路径/home/wwwroot/default,如果只用来放一些静态页面，那么，现在就足够了，直接将你的html，js，css等文件丢进去即可。这不是本文重点，在此不赘述了。 退出使用ctrl+c 安装WordPress下载WordPress包 中文官方站点英文官方站点具体的根据自己的需求选择。下面以中文版为例。当前最新版本是4.7.2 为了方便，我们还是在用站点默认的路径，但是我们投机取巧一下。 1234567891011121314# 进入根目录上一级目录cd /home/wwwroot/# 将default重命名为oldmv default old# 下载WordPress包中文版wget https://cn.wordpress.org/wordpress-4.7.2-zh_CN.tar.gz# 解压WordPress包tar -zxvf wordpress-4.7.2-zh_CN.tar.gz # 查看解压后的文件夹名，此处是wordpress，估计应该都是吧，看看保险啊[root@vultr wwwroot]# lsold wordpress wordpress-4.7.2-zh_CN.tar.gz# 将wordpress重命名为defaultmv wordpress default# 再次查看检验[root@vultr wwwroot]# lsdefault old wordpress-4.7.2-zh_CN.tar.gz 给相应目录授权 12345# 目录以及目录下的文件授权[root@vultr wwwroot]# chown -R 755 /home/wwwrootchown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted# 将目录的所有者分给www组下的www用户。[root@vultr wwwroot]# chown -R www:www /home/wwwroot/chown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted 出现的提示大概是说有一个文件无法更改用户分组和权限。不会影响你的wordpress，忽略就好。 创建一个数据库wordpress 1234567891011121314151617181920212223242526# 登录数据库mysql -u root -p# 输入密码默认的话就是root，否则就是你自己之前设置的那个# 登录进来之后，看到这样一些东西Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.5.53-log Source distributionCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respective owners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; # 不用理会上面的，创建我们的数据库，比如名字为wordpress。记得加分号。mysql&gt; create database wordpress;# 看一下，有没有我们创建的数据库mysql&gt; show databases;# 大概看到如下内容。意味着这一步也没问题。+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || wordpress |+--------------------+4 rows in set (0.01 sec)# 退出mysqlexit 配置WordPress 这时候在此通过浏览器访问 http://IP 例如 http://45.32.195.77，浏览器将自动跳转到http://45.32.195.77/wp-admin/setup-config.php，这就是wordpress的配置页面了，看到的内容如下： 访问页面 点击现在就开始。这时候我们看到如下页面: 数据库配置 按照之前设置的，输入如下信息。 12345数据库名：wordpress用户名：root密码：root数据库主机：localhost表前缀：wp_ 点击提交。 数据库连接完成 到这一步，基本上就意味着大功告成了，因为后边基本不会出错啦。 点击进行安装按钮。出现下图： wordpress 设置 按照自己的需求填写，比如我这里填写如下： wordpress 我的设置 点击安装WordPress按钮，然后登录设置啥的纯页面操作就不在这里过多介绍咯。 主页大概是这样的 后期问题解决有问题的反馈在此，我会进行补充。 主题只显示一个原因：php没有权限读取文件目录。 解决方案：编辑php.ini文件中的disable_functions字段，将其中的scandir去掉。 123456# 使用一键安装包安装的php的配置文件路径如下vi /usr/local/php/etc/php.ini# 查找disable_functions在当前的底行模式下输入 /disable_functions,便可以找到这样一行disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server# 删掉其中的scandir，此处很容易搞乱，所以有必要会使用编辑模式，摁i进入编辑模式。就可以输入删除了。# 退出编辑模式，并保存退出。esc退出编辑模式，:wq保存退出。 更多的指令看我之前的一个简单的入门笔记吧。Linux VIM 文本编辑器 然后记得重启php-fpm服务 1/etc/init.d/php-fpm restart 这样再刷新，就会发现主题不只有一个啦。 更多如果你使用MarkDown，那么请安装JetPack插件，如果你需要语法高亮，请安装Crayon Syntax Highlighter。 以后可能会深入研究一下，有机会的话会专门写一篇文章介绍WordPress主题与插件的哈。","link":"/2022/08/04/%E6%90%AD%E5%BB%BA%20WordPress%20%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"},{"title":"数学公式","text":"1.从1加到n的和的公式 S=n(n+1)/2。 因为S=1+2+3+…+n，并且，S=n+(n-1)+(n-2)+…+1，把这两个等式左右分别相加可以得到：2S=(n+1)+(n+1)+(n+1)+…+(n+1)，其中等式右边一共是 n个（n+1)相加是很容易数出来的，所以得到 2S=n(n+1)，于是S=n(n+1)/2。 2.等差数列和公式：Sn=n(a1+an)/2=na1+n(n-1)/2 d 3.等比数列求和公式：当q≠1时 ，Sn=a1(1-q^n)/(1-q)=(a1-anq)/(1-q) 当q=1时Sn=na1 (a1为首项，an为第n项，d为公差，q 为等比) 4.等差数列 前n项和公式为： Sn=na1+n(n-1)d/2或Sn=n(a1+an)/2(2) 从等差数列的定义、通项公式，前n项和公式还可推出： a1+an=a2+an-1=a3+an-2=…=ak+an-k+1，k∈{1,2,…,n} 若m，n，p，q∈N*，且m+n=p+q，则有 am+an=ap+aq Sm-1=(2n-1)an，S2n+1=(2n+1)an+1 Sk，S2k-Sk，S3k-S2k，…，Snk-S(n-1)k…或等差数列，等等。 5.Fib 0,1,1,2,3,5,8,13,21,… F(n) = F(n-1) + F(n-2); 二分查找 时间复杂度O(logn) 公式 T(n) = T(n/2) + O(1)二叉树遍历 时间复杂度O(n) 公式 T(n) = 2T(n/2) + O(1)排好序的二维矩阵二分查找 时间复杂度O(n) 公式 T(n) = 2T(n/2) + O(logn)归并排序 时间复杂度O(nlogn) 公式 T(n) = 2T(n/2) + O(n)","link":"/2022/08/10/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"title":"易车一面面试题","text":"易车一面：1、Arouter原理2、目前的组件化项目架构应用分层3、业务模块直接的通信怎么做的，是在common里封装接口吗4、组件化过程中遇到的困难，怎么解决的5、不想在common里封装接口，想达到通信的目的，怎么做（自己设计路由框架怎么做）6、集成启动的时候，各个业务模块的初始化启动怎么做（反射获取）7、MVVM优点在哪8、业务层怎么做管理，四个业务层都各自迭代，怎么协同管理（maven，aar）9、apk包体积优化怎么做的10、自己做热修复的系统怎么设计、插件什么格式下载下来11、布局优化，内存优化怎么做的12、约束布局13、jvm内存划分，内存泄漏怎么发生的，垃圾回收，GcRoot都有哪些","link":"/2022/08/10/%E6%98%93%E8%BD%A6/"},{"title":"注解相关知识","text":"注解@Retention可以用来修饰注解，是注解的注解，称为元注解。Retention注解有一个属性value，是RetentionPolicy类型的，Enum RetentionPolicy是一个枚举类型，@Retention 注解指定标记注解的存储方式：RetentionPolicy.SOURCE - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但Java虚拟机(JVM)会忽略。 这是默认的生命周期；RetentionPolicy.RUNTIME - 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，因此运行时环境可以使用它。 @Target 注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值：ElementType.ANNOTATION_TYP可以应用于注解类型。ElementType.CONSTRUCTOR 可以应用于构造函数。ElementType.FIELD 可以应用于字段或属性。ElementType.LOCAL_VARIABLE 可以应用于局部变量。ElementType.METHOD 可以应用于方法级注解。ElementType.PACKAGE 可以应用于包声明。ElementType.PARAMETER 可以应用于方法的参数。ElementType.TYPE 可以应用于类的任何元素。 package com.example.inject; import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; 在Activity 中增加注解标注，通过注解+反射+动态代理等，来优化Activity中代码。省去 setContentView、findViewById、setOnClickListener等操作。Layout注解12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectLayout { @LayoutRes int value();} View注解12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface InjectView { @IdRes int value();} OnClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent(listenerSetter = &quot;setOnClickListener&quot;, listenerType = View.OnClickListener.class, methodName = &quot;onClick&quot;)public @interface OnClick { int[] value();} OnLongClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent( listenerSetter= &quot;setOnLongClickListener&quot;, listenerType= View.OnLongClickListener.class,methodName = &quot;onLongClick&quot;)public @interface OnLongClick { int[] value();} 元注解 标注 OnClick OnLongClick 的注解1234567@Target(ElementType.ANNOTATION_TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectEvent { String listenerSetter(); Class&lt;?&gt; listenerType(); String methodName();} 注解管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.example.inject;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class InjectManage { public static void inJect(Activity activity) { injectLayout(activity); injectView(activity); injectEvent(activity); } /** * 依赖注入 layoutId布局 * 获取 Activity 上的注解 * * @param activity */ private static void injectLayout(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity是否为InjectLayout修饰 if (clazz.isAnnotationPresent(InjectLayout.class)) {// 3.获取InjectLayout注解 InjectLayout annotation = clazz.getAnnotation(InjectLayout.class); if (annotation != null) { try {// 4.通过反射获取 当前Activity 的 setContentView 方法 Method method = clazz.getMethod(&quot;setContentView&quot;, int.class);// 5.获取注解上的value layoutId int resourceId = annotation.value();// 6.调用setContentView method.invoke(activity, resourceId); } catch (Exception e) { e.printStackTrace(); } } } } /** * 依赖注入 获取View * * @param activity */ private static void injectView(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity中所有的属性字段 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) {// 3. 判断字段是否为InjectView修饰 if (field.isAnnotationPresent(InjectView.class)) { InjectView injectView = field.getAnnotation(InjectView.class); if (injectView != null) { try {// 4.反射获取findViewById方法 Method method = clazz.getMethod(&quot;findViewById&quot;, int.class);// 5.获取资源id int resourceId = injectView.value();// 6.获取View对象 View view = (View) method.invoke(activity, resourceId);// 7.设置访问权限 field.setAccessible(true);// 8.将反射获取到的view赋值到Activity上 field.set(activity, view); } catch (Exception e) { e.printStackTrace(); } } } } } /** * 依赖注入 获取 OnClick OnLongClick注解事件 * 注解 + 反射 + 动态代理 * * @param activity */ private static void injectEvent(Activity activity) { if (activity == null) { throw new NullPointerException(); } try {// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.获取Activity的所有成员方法 排除继承方法 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) {// 3.是否是自定义注解修饰 if (method.isAnnotationPresent(OnClick.class)) {//TODO OnLongClick事件处理 OnClick onClick = method.getAnnotation(OnClick.class); int[] value = onClick.value();// 4.获取注解上的注解 元注解 InjectEvent injectEvent = onClick.annotationType().getAnnotation(InjectEvent.class); String listenerSetter = injectEvent.listenerSetter(); Class&lt;?&gt; listenerType = injectEvent.listenerType(); String methodName = injectEvent.methodName();// 5.动态代理 生成代理的listener ProxyHandler handler=new ProxyHandler(activity); Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(), new Class[]{listenerType}, handler); handler.mapMethod(methodName,method);// 6.反射获取 findViewById方法的Method对象 Method findViewByIdMethod = clazz.getMethod(&quot;findViewById&quot;, int.class); findViewByIdMethod.setAccessible(true); for (int id : value) {// 7.通过findViewById获取view View btn = (View) findViewByIdMethod.invoke(activity, id);// 8.根据listenerSetter方法名和listenerType方法参数找到method Method listenerSetMethod = btn.getClass().getMethod(listenerSetter, listenerType); listenerSetMethod.setAccessible(true); listenerSetMethod.invoke(btn, listener); } } } } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } }} ProxyHandler12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.inject;import android.app.Activity;import android.util.Log;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.HashMap;public class ProxyHandler implements InvocationHandler { private WeakReference&lt;Activity&gt; mHandlerRef; private HashMap&lt;String, Method&gt; mMethodHashMap; public ProxyHandler(Activity activity) { mHandlerRef = new WeakReference&lt;&gt;(activity); mMethodHashMap = new HashMap&lt;&gt;(); } public void mapMethod(String name, Method method) { mMethodHashMap.put(name, method); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { try { Object handler = mHandlerRef.get(); if (null == handler) return null; String name = method.getName(); //将onClick方法的调用映射到activity 中的注解标注的方法 Method realMethod = mMethodHashMap.get(name);// Log.i(&quot;injectEvent&quot;, &quot;proxy=&quot; + proxy + &quot;,method=&quot; + method.getName() + &quot;,realMethod=&quot; + realMethod); if (null != realMethod) { return realMethod.invoke(handler, args); } } catch (Exception e) { e.printStackTrace(); } return null; }} 12345678910111213141516171819202122232425262728293031323334@InjectLayout(value = R.layout.activity_network)public class NetworkActivity extends AppCompatActivity { @InjectView(R.id.get_data) Button button; @InjectView(R.id.get_data2) Button button2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); InjectManage.inJect(this);// setContentView();// button=findViewById(R.id.button)// button.setOnClickListener(new View.OnClickListener() {// @Override// public void onClick(View v) {// testNetWorkApi();// }// });// button.setOnLongClickListener(new View.OnLongClickListener() {// @Override// public boolean onLongClick(View v) {// return false;// }// }); } @OnClick({R.id.get_data,R.id.get_data2}) public void onClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onClick&quot;); } @OnLongClick(R.id.get_data) public void onLongClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onLongClick&quot;); } 期间遇到点小问题，就是动态代理这块，对这块理解不够深。首先 Activity中 使用OnClick注解修饰的方法onClick()是需要传入参数的，否则在动态代理里，动态代理回调这个方法就会出错。","link":"/2022/08/04/%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"title":"热修复技术原理总结","text":"#1.什么是热修复 传统更新流程：版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;重新发版-&gt;用户安装 弊端:重新发版本代价高 :用户下载安装成本高 :bug修复不及时，体验差 解决方案 Hybrid方案:业务逻辑以H5方式加载 插件化方案:Atlas或者DroidPlugin方案 热修复方案:采用热修复技术，将更新补丁上传到云端，APP从云端下拉补丁直接应用生效 热修复更新流程:版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;打出补丁,推送给用户-&gt;自动拉取补丁修复 优势 1.无需重新发版，实时高效热修复 2.用户无感知修复，无需下载新应用,代价小 3.修复成功率高，把损失降到最低 ##2.热修复框架 腾讯QQ控件的超技补丁技术，微信的Tinker，饿了么的Amigo，美团的Robust 非侵入式Android热修复方案SophixSophix不支持四大组件的修复,如果要修复四大组件，必须在AndroidManifest里预先插入代理组件，并且声明所有权限。对app运行流程的侵入性太强。未作处理。 ##3.Android热修复的三大领域:代码修复,资源修复,So修复。###3.1代码修复###代码修复方案:一种是阿里系的底层替换方案，一种是腾讯系的类加载方案优劣: 底层替换方案限制多，但时效性好，加载快，立即见效。类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少。 ###底层替换方案 底层替换方案是在已经加载了的类中直接替换掉原有方法，是在原来类的基础上进行修改。因而无法实现对原有类进行方法和字段的增减，因为这样将破坏原有类结构。一旦补丁类中出现了方法的增加或减少，就会导致这个类以及整个Dex的方法数的变化。方法数的变化伴随着方法索引的变化，这样在访问方法时就无法正常的索引到正确的方法了。如果字段发生了增加和减少，和方法变化的情况一样，所有字段的索引都会发生变化。更严重的问题是，如果在程序运行中间某各类突然增加了一个字段，那么对于原先已经产生的这个类的实例，他们还是原来的结构，这是无法改变的。而新方法使用到这些老的实例对象时，访问新增字段就会产生不可预期的结果。传统的底层替换方式，不论是Dexposed、Andfix或者其他安全界的Hook方案，都是直接依赖修改虚拟机方法实体的具体字段，例如，改Dalvik方法的jni函数指针、修改类或者方法的访问权限。Android开源，各大厂商对代码进行改造，Andfix里的ArtMethod的结构是根据Android源码中的结构写死的。如果ArtMethod做修改，这种替换机制就会出问题。 Sophix是一种无视底层具体结构的替换方式，解决了兼容性问题。忽略了底层ArtMethod结构的差异，对于Android版本不需要区分，代码量大大减少。只要ArtMethod数组是以线性结构排列，就不会出现问题。 ###类加载方案类加载方案的原理是在app重新启动后让Classloader去加载新的类。因为app运行时，所有需要发生变更的类已经被加载过了，在Android上是无法对一个类进行卸载。如果不重新启动，原来的类还在虚拟机上，就无法加载新类。只有重新启动，在业务逻辑执行前，抢先加载补丁中的新类，当访问这个类时就会Resolve为新类，达到热修复目的。 ###底层替换原理 Andfix即时生效，其原理是，在已经加载的类中直接在native层替换掉原有方法，实在原有类基础上进行修改。其核心在于replaceMethod函数，这是一个native方法。 其参数是在Java层通过反射机制得到的Method对象所对应的jobject。src对应的事需要被替换的原有方法。dest对应的就是新方法，新方法存在于补丁包中的新类中，也就是补丁方法。 Android的java运行环境，在4.4以下用的事dalvik虚拟机，而在4.4以上用的是art虚拟机。 我们以art为例，对于不同Android版本的art，底层Java对象的数据结构是不同的，因而会进一步区分不同的替换函数，这里我们以Android6.0为例，对应的就是replace_6_0. 每一个Java方法在art中都对应着一个ArtMethod，ArtMethod记录了这个Java方法的所有信息，包括所属类、访问权限、代码执行地址等。 通过env-&gt;FromReflectedMethod，可以由Method对象得到这个方法对应的ArtMethod的真正起始地址。然后可以把它强转成ArtMethod指针，从而对其所有成员进行修改。这样全部替换完之后就完成了热修复逻辑，以后调用这个方法时就会直接走到新方法的实现中了。 为什么这样替换完就可以实现热修复了呢？需要从虚拟机调用方法的原理说起。 在Art虚拟机中ArtMethod结构中，包含两个重8_point_from_quick_compiled_code_了，他们是方法的执行入口。Java代码在Android中会被编译成DexCode。你也不 Art中可以采用解析模式或者AOT机器码模式执行。 解析模式，就是去除Dex Code，逐条解析执行，如果方法的调用者以解析模式运行，在调用方法时，就会取得这个方法的entry_point_from_interpreter_,然后他交转过去执行。AOT的方式，就会先预编译好Dex Code 对应的机器码，然后执行期直接执行机器码，不需要一条条解析执行Dex Code。如果方法的调用者是以AOT机器码方式执行的，在调用这个方法是，就是跳转到entry_point_from_quick_compiled_code执行。因此，当把一个旧方法的所有成员字段都换成新方法后，执行时所有数据就可以保持和新方法的一至。这样在所有执行到旧方法的地方，回取得新方法的执行入口、所属class、方法索引号及所属dex信息，然后想调用旧方法一样的执行到新方法的逻辑。 Native替换方案，比如Andfix和其他安全界的Hook方案，都是写死ArtMethod结构体，这样会带来兼容性问题。Native层替换思路，其实就是替换ArtMethod的所有成员 Sophix采取的是将ArtMethod的作为整体进行替换。 访问权限的问题 方法调用时的权限检查、同包名下的权限问题、反射调用非静态方法问题。 即时生效在什么情况下不适用？1. 引起原有类中发生结构变化的修改2. 修复了的非静态方法会被反射调用 内部类编译 内部类会在编译器会被编译为跟外部类一样的顶级类。 冷启动类加载原理当类结构发生变化时，如新增减少类的method/field再热部署模式下会受到限制，但是冷部署能够达到修复目的。 ##冷启动实现方案 ##插桩实现的前因后果 如果仅仅把补丁类打入补丁包中而不做任何处理的话， 在运行时类加载的时候会异常退出。加载一个dex文件到本地内存时，如果不存在odex文件，首先会执行dexopt，dexopt 的入口在davilk/opt/OptMain.cpp的main方法，最后调用到verifyAndOptimizeClass执行真正的verify/optimize操作。 Apk第一次安装的时候，会对原dex执行dexopt,此时假如apk只存在一个dex，所以dvmVerifyClass(clazz)结果为true,所以apk中所有的类都会被打上CLASS_ISPREVERIFIED标识，接下来执行dvmOptimizeClass，类接着被打上CLASS_ISOPTIMIZED标识。 现在加入A类是补丁类，所以补丁A类在单独的dex中，类B中的某个方法引用到补丁类A，所以执行到该方法会尝试解析类A。 类B由于被打上了CLASS_ISPREVERIFIED标志，接下来referrer是类B，resClassCheck是补丁类A，他们属于不同的dex。所以会提示dvmThrowlllegalAccessError。为了解决这个问题，一个单独无关帮助类放到一个单独的dex中，原dex中所有类的构造函数都引用这个类，一般的实现方法都是侵入dex打包流程，利用.class字节码修改技术，在所有.class文件的构造函数中引用这个帮助类，插桩由此而来。Art下冷启动实现 Dalvik下和Art下对DexFile.loadDex尝试把一个dex文件解析加载到native内存发生了什么？实际都是调用了DexFile.openDexFileNative这个native方法。Dalvik尝试加载一个压缩文件的时候只会去把classes.dex加载到内存中，如果此时内存文件中有多个dex，那么除了classes.dex之外的其他dex被直接忽略掉Art虚拟机方法调用链DexFile-&gt;openDexFileNative-&gt;OpenDexFilesFromat-&gt;LoadDexFilesArt下默认支持加载压缩文件中包含多个dex，首先肯定优先加载primary dex其实就是classes.dex，后续会加载其他的dex。所以补丁类只需要放到classes.dex即可，后续出现在其他dex中的“补丁类“是不会被重复加载的。 Art最终冷启动解决方案 把补丁dex命名为classes.dex。原apk中的dex一次命名为classes(2,3,4…).dex就好了，然后一起打包为一个压缩文件。然后DexFile.LoadDex得到DexFile对象，最后把该DexFile对象整个替换旧的dexElements数据就可以了。 Sophix 和 tinker 方案 补丁dex必须命名为classes.dex loadDex得到的DexFile完整替换掉dexElements数组而不是插入 DexFile.loadDex尝试把一个dex文件解析并加载到native内存，在加载到native内存之前，如果dex不存在对应的odex，那么Dalvik下回执行dexopt，Art下回执行dexoat，最后得到的都是一个优化后的odex，实际上最后虚拟机执行的事这个odex而不是dex。dex足够大那么dexopt/dexoat实际上是很好似的，Dalvik下实际影响比较下，因为loadDex仅仅是补丁包，Art下影响非常大，因为loadDex是补丁dex和apk中原dex合并成一个完整补丁压缩包，所以dexoat非常耗时。如果优化后的odex文件没生成或者没生成一个完整的odex文件，那么loadDex便不能在应用启动的时候进行的，因为会阻塞loadDex线程，一般是主线程。所以解决这个问题，Sophix把loadDex当做一个事务来看，如果中途被打断，那么就删除odex文件，重启的时候如果发现存在odex文件，loadDex完之后，反射注入/替换dexElements数组，实现patch。如果不存在odex文件，那么重启另一子进程loadDex，重启之后在生效。 具体实施方案对Dalvik和Art下1. Dalvik下采用自行研发的全量Dex方案2. Art下本质上虚拟机已经支持多dex的加载，我们只需把补丁dex作为主dex(classes.dex)加载而已 冷启动方案限制？当新增一个publlic/protected/default方法，会出现方法调用错乱。 Google的dexmerge方案 把补丁dex和原dex合并一个完整的dex。 Dalvik下完整DEX方案的新探索 冷启动类加载修复 对于Android下的冷启动类加载修复，最早的实现方案是QQ空间提出的dex插入方案。主要思想是，把插入新dex插入到ClassLoader索引路径的最前面，这样在load一个class时，优先找到补丁中的。这类插入dex 的方案，会遇到一个主要的问题，就是如何解决Dalvik虚拟机下类的pre-verify问题。 如果一个类 中直接引用到的所有非系统类都和该类在同一个dex里的话，那么这个类就会被打上CLASS_ISPREVERIFIED,具体判定代码可见虚拟机中的verifyAndOptimizeClass函数。 腾讯的三大热修复方案是如何解决这个问题的： QQ控件的处理方式，是在每个类中插入一个来自其他dex的hack.class,由此让所有类里面都无法满足pre-verified条件。 Tinker的方式，是合成全量的dex文件，这样所有class的都在全量dex中解决，从而消除class重复而带来的冲突。 Qfix的方式，是取得虚拟机中的某些底层函数，提前resolve所有补丁类，以此绕过Pre-verify检查。Sophix的方式，补丁中已包含变动的类，主要在原先基线包中dex里边，去掉补丁中已有的class。这样，补丁+去除了补丁类的基线包=app中所有类。参考Android原生multi-dex的实现，是把一个apk所用到的所有类拆分到classes.dex、classes2.dex、classes.dex…之中，而每个dex都只包含了部分的类的定义，但单个dex也是可以加载的，因为只要把所有dex都load进去，本dex中不存在的类就可以在运行期间在其他dex中找到。 #资源热修复技术 ##3.2资源修复InstantRun资源热修复原理：1. 构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完整的新资源包加入到AssetManger中，这样就得到一个含有所有新资源的AssetManager。2. 找到所有之前引用到愿你有Assetmanager的地方，通过反射，把引用处替换成新的AssetManager。Sophix 资源热修复原理: 构造一个package id 为0x66的资源包，其中包含改变了的资源项，然后直接在原有的AssetManager中addAssetPath这个包就可以了。由于补丁包的package id 为0x66,不与目前已经加载的0x7f冲突，因此直接加入到已有的AssetMananger中就可以直接使用。替换方式更加优雅，直接在原有的AssetManageer对象上进行析构和重构，原先AssetManager对象的引用没有发生改变，不用像InstantRun进行繁琐修改。 ###资源替换方案优势1. 不修改AssetManager的引用处，替换更快更安全。2. 不必下发完整包，补丁包中只包含有变动的资源3. 不要在运行时合成完整包。不占用运行时计算和内存资源。 一个Android进程只包含一个ResTable,ResTable的成员变量mPackageGroups就是所有解析过的资源包的集合。任何 一个资源包中都含有resources.arsc,他记录了所有资源的id分配情况以及资源中的所有字符串。这些信息是以二进制方式存储的。底层的AssetManager做的事就是解析这个文件，然后把相关信息存储到mPackageGroups里面。 资源信息主要是指每隔资源的名称以及他对应的编号。每隔资源，都有唯一编号。 编号是一个32位数字，用十六进制来标识就是0xPPTTEEEE。PP为package id，TT为type id，EEEE为entry id。 运行时资源的解析 默认由Android SDK编出来的apk，是由aapt工具进行打包的，其资源包的package id 是 0x7f。系统的资源包，也就是framework-res.jar，package id 为0x01。在走到app 的第一行代码之前，系统就已经帮我们构造好一个已经添加了安装包资源的AssetManager了。 因此，这个AssetManager里就已经包含了系统资源包以及app的安装包，就是package id 为0x01的framework-res.jar中的资源和package id为0x7f的app安装包资源。 如果此时直接在addAssetPath其实补丁包里的资源是不生效的。因为在getResTable已经执行很多次了。不会发生真正的解析。###Sophix资源解决方案 构造一个package id 为0x66的资源包，包含了改变的资源项，然后直接在原有AssetManager中addAssetPath这个包。不与已经加载的0x7f冲突。 而资源的改变包含增加、减少、修改这三种情况，分别是如何处理的呢？1. 对于新增资源，直接加入补丁包，然后新代码里直接引用就可以了2. 对于减少资源，我们只要不使用他就行了，因此不用考虑这种情况，他也不影响补丁包3. 对于修改资源，比如替换了一张图片之类的情况。我们把它视为新增资源，在打补丁的时候，代码在引用处也会做响应修改，也就是直接把原来使用就资源id的地方变成新id。#3.3 So库修复 So库修复本质上是对native方法的修复和替换。 Sophix采用的是类似类修复反射注入方式。把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，达到加载so库时时补丁so库，而不是原来so库的目录，从而达到修复的目的。采用这种方案，完全由Sophix在启动期间反射注入patch中的so库。其他方案是手动替换系统的System.load来实现替换目的。 Java Api提供一下两个接口加载一个so库1. System.loadLibrary(String libName);传进去的参数 so库名称，表示的so库文件，位于apk压缩文件中的libs目录，最后复制到apk安装目录下。2. System.load(String pathName)传进去的参数 so库在磁盘中的完整路径。加载一个自定义外部so库文件。 两种方式加载一个so库，实际上最后都调用nativeLoad这个native方法去加载so库，这个方法的参数fileName so库在磁盘中的完整路径名。 JNI编程中，动态注册的natvie方法必须实现JNI_ONLoad方法，同时实现一个JNINativeMethod[]数组 ，静态注册的native方法必须是Java+类完整路径+方法名的格式。 ##3.1. SO库冷部署重启生效实现方案 SO库修复方案1. 接口调用替换方案，需要强制侵入用户接口调用2. 反射注入方案，重启生效 总结：1. 动态注册的native方法映射通过加载so库过程中调用JNI_OnLoad方法调用完成2. 静态注册的native方法映射是在该native方法第一次执行的时候才完成映射，当然前提是该so库已经load过。 ##3.2 SO库热部署实时生效分析###3.2.1动态注册native方法实时生效动态注册的native方法调用一次JNI_OnLoad方法都会重新完成一次映射，所以我们是否只要先加载原来的so库，然后在加载补丁so库，就完成Java层native方法到native层patch后的新方法映射，这样就完成动态注册native方法的patch实时修复。 实测发现art下这样是可以实时生效，但Dalvik下做不到试试生效。原因Dalvik第二次load补丁so库，执行的仍然是原来的so库的JNI_OnLoad方法，而不是补丁so库的JNI_OnLoad方法。Dalvik虚拟机下dlopen方法实现，底层方法会校验so库是否已经加载过，方法的判断依据是判断name,如果加载过直接返回该so库的句柄。如果so库从未加载过，则load_library执行加载。所以Dalvik下面加载修复后的补丁so拿到的还是原so库文件的句柄，所以执行的仍然是原so库的JNI_OnLoad方法，Art下不存在问题，因Art下该方法以name作为key去查找不是bname,所以art下重新load一遍补丁so库，拿到的是补丁so库的句柄，然后执行补丁so库的JNI_OnLoad。解决Dalvik下该问题，可对补丁so库进行改名。 ###3.2.2静态注册native方法实时生效静态注册native方法的映射实在native方法第一次执行的时候完成映射，如果native方法在加载补丁so库之前已经执行过，是否这个静态注册native方法一定得不到修复？幸运的是，系统JNI API提供了解注册的接口 UnregisterNatives（JNIEnv* env,jclass jclazz）函数回吧jclazz所在类的所有native方法都重新指向为dvmResolveNativeMethod，所以调用unregisterNatives之后不管是静态注册还是动态注册的native方法之前是否执行过在加载补丁so 的时候都会重新去做映射。所以我们只需要以下调用。 ##3.3 SO库冷部署重启生效实现方案 ###3.3.1.接口调用替换方案Sdk提供接口替换System默认加载so库接口 SOPatchManager。loadLibrary接口加载so库的时候有限尝试去加载sdk指定目录下的补丁so，加载策略如下：1. 如果存在则加载补丁so库而不会去加载安装apk安装目录下的so库。2. 如果不存在补丁so，那么调用System.loadLibrary去加载安装apk目录下的so库。 方案优缺点：优点：不需要对不同sdk版本进行兼容，因为所有的SDK版本都有System.loadLibrary这个接口。缺点：调用方需要替换掉System默认加载so库接口为sdk提供的接口，如果是已经编译混淆好的三方库的so库需要patch，那么是很难做到接口的替换。 ###3.3.2反射注入方案System.loadLibrary(“native-lib”)，加载so库的原理，其实native-lib这个 so库最终传给native方法执行的参数是so库在磁盘中的完整路径，比如/data/app-lib/com.taobao.jni-2/libnative-lib.so,so库会在DexPathList.nativeLibraryDirectories/nativeLibraryPathElements变量所表示的目录下去遍历搜索。 可以发现会遍历nativeLibraryDirectories数组，如果找到了IoUtils.canOpenReadOnly(path)返回true，那么就直接返回该path，IoUtils。canOpenReadOnly(path)返回true的前提肯定是需要path标识的so文件存在的。我们可以采取类似类修复反射注入方式，只要把我们的补丁so库的路径插入到nativeLibraryDirectories数组的最前面就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复的目的。 Sdk23以上findLibrary 实现已经发生变化，只需把补丁so库的完整路径违参数构建一个Element对象，然后再插入nativeLibraryPathElements数组的最前面就好了。 优点：可以修复三方库的so库。同事接入方不需要想方案1一样强制侵入用户接口调用。缺点：需要不断的对sdk进行适配，如上sdk23为分界线，findLibrary接口实现已发生变化。不管是补丁包还是apk中一个so库存在多种cpu架构的so文件，比如armeabi，arm64-v8a,x86等。加载可定是加载其中一个so库文件的，如何选择机型对应的so库文件将是重点所在。 虚拟机究竟如何选择哪个abis目录作为参数构建PathClassLoader对象，原理如图 实际上补丁so也存在类似的问题，我们的补丁so库文件放到补丁包的libs目录下，libs目录和.dex文件res资源文件一起打包成一个压缩文件作为最后的补丁包，libs目录可能也包含多种abis目录。所以我们需要选择手机最合适的primaryCpuAbi，然后从libs目录下选择这个primaryCpuAbi子目录插入到nativeLibraryDirectories/nativeLibraryPathElements数组。所以怎么选择primaryCpuAbi是关键，具体实现如图： 1.sdk&gt;=21时，直接反射拿到ApplicationInfo对象的primaryCpuAbi即可2.sdk&lt;21时，有雨此时不支持64位，所以直接吧Build.CPU_ABI,Build.CPU_ABI2作为primaryCpuAbi即可。","link":"/2022/08/04/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"title":"电源开关机按键事件流程","text":"前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。 和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。 下面首先看一下dispatchUnhandledKey方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 通过前面两篇文章的分析（ android源码解析（二十六）–&gt;截屏事件流程&amp;nbsp;&amp;nbsp;android源码解析（二十七）–&gt;HOME事件流程）我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; } 通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。 12345678910111213141516public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { ... case KeyEvent.KEYCODE_POWER: { result &amp;= ~ACTION_PASS_TO_USER; isWakeKey = false; // wake-up will be handled separately if (down) { interceptPowerKeyDown(event, interactive); } else { interceptPowerKeyUp(event, interactive, canceled); } break; } ... return result; } 这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void interceptPowerKeyDown(KeyEvent event, boolean interactive) { ... // Latch power key state to detect screenshot chord. if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordPowerKeyTriggered = true; mScreenshotChordPowerKeyTime = event.getDownTime(); interceptScreenshotChord(); } // Stop ringing or end call if configured to do so when power is pressed. TelecomManager telecomManager = getTelecommService(); boolean hungUp = false; if (telecomManager != null) { if (telecomManager.isRinging()) { // Pressing Power while there's a ringing incoming // call should silence the ringer. telecomManager.silenceRinger(); } else if ((mIncallPowerBehavior &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) { // Otherwise, if &quot;Power button ends call&quot; is enabled, // the Power button will hang up any current active call. hungUp = telecomManager.endCall(); } } // If the power key has still not yet been handled, then detect short // press, long press, or multi press and decide what to do. mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered || mScreenshotChordVolumeUpKeyTriggered; if (!mPowerKeyHandled) { if (interactive) { // When interactive, we're already awake. // Wait for a long press or for the button to be released to decide what to do. if (hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } } else { wakeUpFromPowerKey(event.getDownTime()); if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); mBeganFromNonInteractive = true; } else { final int maxCount = getMaxMultiPressPowerCount(); if (maxCount &lt;= 1) { mPowerKeyHandled = true; } else { mBeganFromNonInteractive = true; } } } } } 这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。 123case MSG_POWER_LONG_PRESS: powerLongPress(); break; 我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。 123456789101112131415161718192021private void powerLongPress() { final int behavior = getResolvedLongPressOnPowerBehavior(); switch (behavior) { case LONG_PRESS_POWER_NOTHING: break; case LONG_PRESS_POWER_GLOBAL_ACTIONS: mPowerKeyHandled = true; if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) { performAuditoryFeedbackForAccessibilityIfNeed(); } showGlobalActionsInternal(); break; case LONG_PRESS_POWER_SHUT_OFF: case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM: mPowerKeyHandled = true; performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false); sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF); break; } } 可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面： 然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。 12345678910111213void showGlobalActionsInternal() { sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); if (mGlobalActions == null) { mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs); } final boolean keyguardShowing = isKeyguardShowingAndNotOccluded(); mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned()); if (keyguardShowing) { // since it took two seconds of long press to bring this up, // poke the wake lock so they have some time to see the dialog. mPowerManager.userActivity(SystemClock.uptimeMillis(), false); } } 可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（android源码解析（二十七）–&gt;HOME事件流程）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法： 12345678910111213141516171819202122232425262728293031public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { mContext = context; mWindowManagerFuncs = windowManagerFuncs; mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); mDreamManager = IDreamManager.Stub.asInterface( ServiceManager.getService(DreamService.DREAM_SERVICE)); // receive broadcasts IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED); context.registerReceiver(mBroadcastReceiver, filter); ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); mHasTelephony = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE); // get notified of phone state changes TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE); mContext.getContentResolver().registerContentObserver( Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mAirplaneModeObserver); Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE); mHasVibrator = vibrator != null &amp;&amp; vibrator.hasVibrator(); mShowSilentToggle = SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean( com.android.internal.R.bool.config_useFixedVolume); } 可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。 123456789101112public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) { mKeyguardShowing = keyguardShowing; mDeviceProvisioned = isDeviceProvisioned; if (mDialog != null) { mDialog.dismiss(); mDialog = null; // Show delayed, so that the dismiss of the previous dialog completes mHandler.sendEmptyMessage(MESSAGE_SHOW); } else { handleShow(); } } 可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。 1234567891011121314151617private void handleShow() { awakenIfNecessary(); mDialog = createDialog(); prepareDialog(); // If we only have 1 item and it's a simple press action, just do this action. if (mAdapter.getCount() == 1 &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) { ((SinglePressAction) mAdapter.getItem(0)).onPress(); } else { WindowManager.LayoutParams attrs = mDialog.getWindow().getAttributes(); attrs.setTitle(&quot;GlobalActions&quot;); mDialog.getWindow().setAttributes(attrs); mDialog.show(); mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND); } 在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private GlobalActionsDialog createDialog() { ... mAirplaneModeOn = new ToggleAction( R.drawable.ic_lock_airplane_mode, R.drawable.ic_lock_airplane_mode_off, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) { void onToggle(boolean on) { if (mHasTelephony &amp;&amp; Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) { mIsWaitingForEcmExit = true; // Launch ECM exit dialog Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null); ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(ecmDialogIntent); } else { changeAirplaneModeSystemSetting(on); } } @Override protected void changeStateFromPress(boolean buttonOn) { if (!mHasTelephony) return; // In ECM mode airplane state cannot be changed if (!(Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) { mState = buttonOn ? State.TurningOn : State.TurningOff; mAirplaneState = mState; } } public boolean showDuringKeyguard() { return true; } public boolean showBeforeProvisioning() { return false; } }; onAirplaneModeChanged(); mItems = new ArrayList&lt;Action&gt;(); String[] defaultActions = mContext.getResources().getStringArray( com.android.internal.R.array.config_globalActionsList); ArraySet&lt;String&gt; addedKeys = new ArraySet&lt;String&gt;(); for (int i = 0; i &lt; defaultActions.length; i++) { String actionKey = defaultActions[i]; if (addedKeys.contains(actionKey)) { // If we already have added this, don't add it again. continue; } if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) { mItems.add(new PowerAction()); } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) { mItems.add(mAirplaneModeOn); } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) { if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 &amp;&amp; isCurrentUserOwner()) { mItems.add(getBugReportAction()); } } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) { if (mShowSilentToggle) { mItems.add(mSilentModeAction); } } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) { if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) { addUsersToMenu(mItems); } } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) { mItems.add(getSettingsAction()); } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) { mItems.add(getLockdownAction()); } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) { mItems.add(getVoiceAssistAction()); } else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) { mItems.add(getAssistAction()); } else { Log.e(TAG, &quot;Invalid global action key &quot; + actionKey); } // Add here so we don't add more than one. addedKeys.add(actionKey); } mAdapter = new MyAdapter(); AlertParams params = new AlertParams(mContext); params.mAdapter = mAdapter; params.mOnClickListener = this; params.mForceInverseBackground = true; GlobalActionsDialog dialog = new GlobalActionsDialog(mContext, params); dialog.setCanceledOnTouchOutside(false); // Handled by the custom class. dialog.getListView().setItemsCanFocus(true); dialog.getListView().setLongClickable(true); dialog.getListView().setOnItemLongClickListener( new AdapterView.OnItemLongClickListener() { @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { final Action action = mAdapter.getItem(position); if (action instanceof LongPressAction) { return ((LongPressAction) action).onLongPress(); } return false; } }); dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); dialog.setOnDismissListener(this); return dialog; } 方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面： 好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了： 1mItems.add(new PowerAction()); 这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。 1234567891011121314151617181920212223242526272829303132private final class PowerAction extends SinglePressAction implements LongPressAction { private PowerAction() { super(com.android.internal.R.drawable.ic_lock_power_off, R.string.global_action_power_off); } @Override public boolean onLongPress() { UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE); if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) { mWindowManagerFuncs.rebootSafeMode(true); return true; } return false; } @Override public boolean showDuringKeyguard() { return true; } @Override public boolean showBeforeProvisioning() { return true; } @Override public void onPress() { // shutdown by making sure radio and power are handled accordingly. mWindowManagerFuncs.shutdown(false /* confirm */); } } 可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。 12345public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { ... mWindowManagerFuncs = windowManagerFuncs; ...} 好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。 经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。 12345678910private void initPolicy() { UiThread.getHandler().runWithScissors(new Runnable() { @Override public void run() { WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper()); mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this); } }, 0); } 这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。 然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false /* confirm */);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。 1234@Override public void shutdown(boolean confirm) { ShutdownThread.shutdown(mContext, confirm); } 好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。 12345public static void shutdown(final Context context, boolean confirm) { mReboot = false; mRebootSafeMode = false; shutdownInner(context, confirm); } 可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void shutdownInner(final Context context, boolean confirm) { // ensure that only one thread is trying to power down. // any additional calls are just returned synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;); return; } } final int longPressBehavior = context.getResources().getInteger( com.android.internal.R.integer.config_longPressOnPowerBehavior); final int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm); Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior); if (confirm) { final CloseDialogReceiver closer = new CloseDialogReceiver(context); if (sConfirmDialog != null) { sConfirmDialog.dismiss(); } sConfirmDialog = new AlertDialog.Builder(context) .setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : com.android.internal.R.string.power_off) .setMessage(resourceId) .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { beginShutdownSequence(context); } }) .setNegativeButton(com.android.internal.R.string.no, null) .create(); closer.dialog = sConfirmDialog; sConfirmDialog.setOnDismissListener(closer); sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); sConfirmDialog.show(); } else { beginShutdownSequence(context); } } 可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private static void beginShutdownSequence(Context context) { synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;); return; } sIsStarted = true; } ... if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) { mRebootUpdate = new File(UNCRYPT_PACKAGE_FILE).exists(); if (mRebootUpdate) { pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_update_prepare)); pd.setMax(100); pd.setProgressNumberFormat(null); pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); pd.setProgress(0); pd.setIndeterminate(false); } else { // Factory reset path. Set the dialog message accordingly. pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_reset_message)); pd.setIndeterminate(true); } } else { pd.setTitle(context.getText(com.android.internal.R.string.power_off)); pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress)); pd.setIndeterminate(true); } pd.setCancelable(false); pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); pd.show(); sInstance.mProgressDialog = pd; sInstance.mContext = context; sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE); // make sure we never fall asleep again sInstance.mCpuWakeLock = null; try { sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;); sInstance.mCpuWakeLock.setReferenceCounted(false); sInstance.mCpuWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mCpuWakeLock = null; } // also make sure the screen stays on for better user experience sInstance.mScreenWakeLock = null; if (sInstance.mPowerManager.isScreenOn()) { try { sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;); sInstance.mScreenWakeLock.setReferenceCounted(false); sInstance.mScreenWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mScreenWakeLock = null; } } // start the thread that initiates shutdown sInstance.mHandler = new Handler() { }; sInstance.start(); } 在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。 总结： 电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中； 在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等； 当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程","link":"/2022/08/06/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"百度二面面试题","text":"正向代理，反向代理正向代理 client proxy -&gt; service client -&gt; proxy service 数据库 后10条数据 sql语句怎么写Select * from user order by id desc limit 10 非关系型数据库库和关系型数据库区别关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。 多个数据库版本升级 如何设计减少后期开发人员工作量 计算2进制数据有多少个1 java文件编译过程通过javac 将 java文件编译成.class字节码文件 dex文件如何加载DexClassLoader PathClassLoader 。DexClassLoader 加载外部文件。PathClassLoader加载内部应用。继承自BaseDexClassLoader，内部包含DexElement 数组。 列表卡顿优化 内存紧张是否会导致卡顿 synchronized作用， 如何 让多个实例的同一个方法只有一个线程访问 计算二叉树深度 打印斐波那契数列0，1，1，2，3，5，8，13，21，34，55，89，144 微信朋友圈 图片点击放大效果和手指拖动效果如何实现 anr问题怎么分析 dalvik 虚拟机和ART虚拟机主要区别 socket是什么 tcp协议的上层协议有哪些http websocket mqtt","link":"/2022/08/10/%E7%99%BE%E5%BA%A62%E9%9D%A2/"},{"title":"算法面试总结","text":"数据结构题目一直是面试官考察的重点。数组和字符串是两种最基本的数据结构。链表应该是面试题中使用频率最高的一种数据结构。如果面试官想加大面试难度，那么他很有可能会选用与树(尤其是二叉树)想关的面试题。由于栈与递归调用密切相关，队列在图(包括树)的宽度优先遍历中需要用到，需账务这两种数据结构。 算法是面试官喜欢考察的另外一个重点。查找(特别是二分查找)和排序(特别是快速排序和归并排序)是面试中经常考察的算法，应聘者一定要熟练掌握。回溯法很适合解决迷宫及其类似的问题。如果面试题是求一哥问题的最优解，那么可以尝试使用动态规划。假如我们在用动态规划分析问题时发现每一步都存在一个能得到最优解的选择，那么可以尝试使用贪婪算法。另外，应聘者还要掌握分析时间复杂度的方法，理解即使同一思路，基于循环和递归的不同实现，他们的时间复杂度可能大不相同。很多时候我们会用自上而下的递归思路分析问题，却会基于自下而上的循环实现代码。位运算是针对二进制数字的运算规则。需掌握二进制的与、或、异或运算及左移、右移操作，就能解决与运算相关的面试题。","link":"/2022/08/10/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"网络状态码分类","text":"网络状态码分类 状态码 名称 描述100 Continue 继续。客户端应继续其请求101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200 OK 请求成功。一般用于GET与POST请求201 Created 已创建。成功请求并创建了新的资源202 Accepted 已接受。已经接受请求，但未处理完成203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206 Partial Content 部分内容。服务器成功处理了部分GET请求300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303 See Other 查看其它地址。与301类似。使用GET和POST请求查看304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305 Use Proxy 使用代理。所请求的资源必须通过代理访问306 Unused 已经被废弃的HTTP状态码307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证402 Payment Required 保留，将来使用403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面405 Method Not Allowed 客户端请求中的方法被禁止406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408 Request Time-out 服务器等待客户端发送的请求时间过长，超时409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息412 Precondition Failed 客户端请求信息的先决条件错误413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效417 Expectation Failed 服务器无法满足Expect的请求头信息500 Internal Server Error 服务器内部错误，无法完成请求501 Not Implemented 服务器不支持请求的功能，无法完成请求502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理","link":"/2022/08/06/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB/"},{"title":"科学上网电报 Telegram 群组汇总","text":"``****# 科学上网电报 Telegram 群组汇总（转） 科学上网电报 Telegram 群组汇总Cover Image for 科学上网电报 Telegram 群组汇总December 25, 2020Telegram电报群实在是太多了，小伙伴根本找不过来，加上Telegram本身无法搜索群组，想找一些合适的好玩的电报群租非常麻烦。如何快速的找到自己想要加入的Telegram群组？本文是电报群组大汇总，建议使用浏览器的搜索功能查找关键字，这样才能快速定位。建议收藏本汇总。 推荐Telegram 中文 NEWS:https://t.me/YinxiangBiji_NewsTelegram 中文社群:https://t.me/yxbjxTelegram 中文群组频道搜索机器人: https://t.me/ququn_botBear 熊掌记用户群:https://t.me/joinchat/Ag98FxRIKr7UkwUPqKKmfwRSS 交流群:https://t.me/joinchat/Ag98F0evTbZwY8HB7oH4fA笔记软件交流讨论:https://t.me/joinchat/Ag98F0DdcZr1X1xS6lJsyA幕布用户群:https://t.me/joinchat/Ag98F01tRQ2RIk_icHhiyA为知笔记用户群:https://t.me/joinchat/Ag98F1MLJji5WC5OpjAcHQ有道云笔记用户群:https://t.me/joinchat/Ag98F1C2ip5g0Bac_KCJ2ATodoist 用户群:https://t.me/joinchat/Ag98F1DuGqE_dIiNkeM2uASimplenote 用户群:https://t.me/joinchat/Ag98F0f7fjEKqZKVHNW0aAMarginNote 用户群:https://t.me/joinchat/Ag98F0ZLDrJZOSBWXAEiowiMazing 用户群:https://t.me/joinchat/Ag98F07KJmIlmwSCfTOKxQTypora 用户群:https://t.me/joinchat/Ag98FxBSO7eJ9mMwxxUIPw光年VPN 用户群:https://t.me/lightyearvpn群组 Group番羽土番Tempest(rixCloud) 群:https://t.me/rixCloud_UserSurge 交流:https://t.me/loveappsSurge Pro:https://t.me/SurgeProQuantumult X:https://t.me/QuanXAppQuantumult:https://t.me/quantumultQuantumult X小白群:https://t.me/QuanX_AppShadowrocket:https://t.me/ShadowrocketApplhie1/Rules:https://t.me/lhie1xDivineEngine Chat:https://t.me/joinchat/BlP48kmUGY-iR41Iq11-3wQuantumult X、Surge、Loon的脚本讨论:https://t.me/joinchat/JikZ61Y-WyLUu6dBFPfu6wthor，Quantumult X，小火箭 JSBox交流群:https://t.me/weixiaoge777 Loon:https://t.me/Loon0x00rixCloud 用户群:https://t.me/rixCloudbot (绑定账号后,发送’/joingroup’获取群链接)Dler Cloud 用户群:https://t.me/DlerCloud_bot (绑定账号后,会给你发送群链接)YoYu - Global Accelerate:https://t.me/YoYuBot (发送’/bind’绑定账号后,会给你发送群链接)喵帕斯用户群:https://t.me/npsBoostbot (绑定账号后,发送’/joingroup’获取群链接)歪兔YTOO:https://t.me/YToo_bot (绑定账号后,获取群链接)N3RO Network:https://t.me/nnn3ro科学上网技术研究会:https://t.me/kxswjs科学上网，科技分享:https://t.me/qiankeji老王用户群:https://t.me/wangvpn_users老王讨论群:https://t.me/wangvpn_user_chat嘿嘿嘿:https://t.me/hellcell321神机规则群:LAMP交流群:https://t.me/qiushui2018V1blog交流群:https://t.me/V1blog_gBGP测速:https://t.me/hxisj8whsv机场测速频道:https://t.me/jcfast自用机场测速:https://t.me/shangguanhongxinSpeedtest by Delected Account:https://t.me/delspeedtestSurge/Quantumult X Script:https://t.me/scriptgroupShadowsocks:https://t.me/joinchat/A1lxzDuvcioTtic84c12vQShadowsocksR 讨论组:https://t.me/ssrunofficialShadowsocksR 讨论组 2群:https://t.me/chatssrShadowsocksRR 讨论组:https://t.me/ssrrchatNetch 游戏加速工具:https://t.me/Netch_Discuss_GroupClash:Clash for Windows:Clash for Android:Clash 交流群:https://t.me/ClashclientClashR 交流群组:https://t.me/ClashR_ChatClashW:https://t.me/joinchat/AAAAAFHaKhGQaovvfpKr4gShellClash(Clash for Miwifi):https://t.me/clashfmTrojan-Qt5:https://t.me/TrojanQt5Pharos Pro For iOS:https://t.me/Shadow_x_user_supportPharos Pro For Android:https://t.me/joinchat/EthDYRQ80Clo_dj8e3PJnQTrojan Qt5:https://t.me/TrojanQt5Dashboard更新发布:https://t.me/db4cmShadowRay:https://t.me/ShadowRayProject V(V2Ray):https://t.me/projectv2rayProject X(Xray):https://t.me/projectXrayNetch 游戏加速工具:https://t.me/NetchV2fly Official:https://t.me/v2fly_chatV2Fly #Off-Topic:https://t.me/joinchat/GhXX_0zQFLOkjy9z81eQqgQv2ray User Group:https://t.me/qv2rayQv2ray Outpost:https://t.me/qv2ray_outpostv2rayN&amp;G:https://t.me/v2rayN老毛子Padavan固件自助交流群:https://t.me/pdcn2老毛子Padavan固件iOS自助交流群:https://t.me/pdcn3Wingy Halal Group:https://t.me/wingytg魅影极速:魅影极速分站ARK:https://t.me/joinchat/HOQoQ0gXFKNdjqQ1S5ymfACordCloud泡面交流群:https://t.me/joinchat/DsPjq0KEVl6saO_62MHEDANexitally 的老年人活动中心:https://t.me/nexitallyusersAmyTelecom官方群:https://t.me/amytelecomgroupIPLC.cloud:https://t.me/joinchat/Kt2jPxWr4SxT4M40CKDfjAWireGuard:https://t.me/WireGuardVPN讨论群:https://t.me/gouwu202Net:https://t.me/chatwith202海豚湾の三温暖:https://t.me/joinchat/IVfY9w2yQbtFtuyjcS7i6wSurfboard 交流群:https://t.me/surfboardappSockBoom 咕咕咕交流群:https://t.me/sockboomCCCAT Madhouse:https://t.me/joinchat/AwB5ckAQb8s9Ev9c6shndgCCCAT Helpdesk:https://t.me/joinchat/AwB5ckdlwjLKRARW0nac2APython云-一个学习py的公益机场:https://t.me/pythonyun忍者云:https://t.me/joinchat/JzPmF0Vpbn30D36D9_Ja_wNyanCAT Group:https://t.me/NyanCaaaat几鸡:https://t.me/ngcss梦迪mdssCloud:https://t.me/MdCloud梦迪mdssCloud:https://t.me/mdssiosssrcloud:https://t.me/ssrcloud次元链接:https://t.me/cylink星愿云加速:https://t.me/starwishss百草园:https://t.me/baicaoyuan星愿云SWcloud:https://t.me/starwishss不拘阁:https://t.me/bujuyigeMunClolud:https://t.me/MunCloudSSRNSL NetWork:https://t.me/nsl_ssr飞云flycloud:https://t.me/FeiYunGroupI·SSR·do:https://t.me/i_SSRLSJ AirPort:https://t.me/lsjairportPoiCloud:https://t.me/PoiCloud良辰云:https://t.me/liangchenyunssZCSSR:https://t.me/zcssrqazCloud:https://t.me/qazcloud陆玖:https://t.me/GroupFor69Conair:https://t.me/conairmeFlysocks-Server:https://t.me/flysocksX-Air T3航站楼:https://t.me/xssr_boosterFHV站(antei):https://t.me/FHVHKHKloriCloud:https://t.me/loricloud928Net购物小车:https://t.me/net928贼船:https://t.me/zeichuanSoCloud 聊天群:https://t.me/socloudso牧场物语官方交流群:https://t.me/mcwy666999GLaDOS 中文社区:https://t.me/glados_network盈科數碼動力 Pacific Century CyberWorks Limited:https://t.me/ssrcloudGeekCloud:https://t.me/joinchat/Ky2VFBBt2S5uRDbF3bJfQgTHE.SSR官方售后群(BLINKLOAD):https://t.me/thessrgroup浪花云:https://t.me/langhuayunSunCloud萌妹吃瓜:https://t.me/Mengmm永久公益机场:https://t.me/AC_FFree大水比交流群:https://t.me/hxisj8whsv大佬吹牛群:https://t.me/xddos0少数人TG交流群:https://t.me/shaoshurenxWestCloud养生之道:https://t.me/joinchat/LM3Mm061YantoLHzgOs41QDLK的奔放交流时间:https://t.me/dlkvpnMcatCloud - V2ray:https://t.me/McatCloudQatar Airways:https://t.me/qatar00Mac-SSR:https://t.me/MacSSRMac翻墙 · SpechtLite交流群:https://t.me/SpechtLiteGFW 吐槽 &amp;&amp; 翻墙方法讨论:https://t.me/DiscussCrossGFWAlice:https://t.me/joinchat/AAAAAEAKmMX609B2f_Z9iQAnyFlow:https://t.me/AnyFlowApp极客公园:https://t.me/geekparkSSR V2ray 讨论分享:https://t.me/joinchat/HHeAr1ELdNEKXdOhr1yXkw路由器梅林固件交流群:https://t.me/joinchat/AAAAAEC7pgV9vPdPcJ4dJw恩山论坛→软路由综合交流群:https://t.me/Router166XX-Net:https://t.me/xxnetpipesocks:https://t.me/pipesocksSocksCap64官方群:https://t.me/tarolabNICO Homemade “CupSS”:https://t.me/niconodeVPS全球主機交流:https://t.me/VPSchatBIS科学上网:https://t.me/BISprojectglzjinmod:https://t.me/glzjinmod代理「配置·规则」分享:https://t.me/RuleConfig狸猫加速器活动交流群:https://t.me/joinchat/AAAAAEQuL_IYR9I0wuLnfQKitsunebi交流:https://t.me/Kitsunebi_funs精品免费翻墙app推荐:https://t.me/fuckyougfwSSTap Rule:https://t.me/SSTapRuleSSGlobal.co 官方群:https://t.me/joinchat/ESwgR0Ckp_zXMCuRKqykqATrojan:https://t.me/trojangfwLantern Beta:https://t.me/joinchat/BxT4KUg7B5HATgrFP22VXg几鸡-小圈自用公益机场:https://t.me/lisuanlaojiSuJ-Tech公益SSR:https://t.me/joinchat/KKbIW0pwN0JfXI86groWNASSRLittle小布机场:https://t.me/ssrlivAgent云计算加速服务:https://t.me/crossgreatfirewallss panel v3 mod 非官方水群:https://t.me/SSUnion小布吉岛闲聊群:https://t.me/bujidaochatOKAB3吹水:https://t.me/OKAB3ScriptSurgio 交流:https://t.me/surgiotgnebula_net:https://t.me/nebula_netOfficial Geph Users 迷霧通官方用戶群:https://t.me/gephusersExCloud:https://t.me/excloudAK’s Tech Studio:https://t.me/joinchat/GnoDABmvn-48g2PpaySbeQspeedtest测速吹水群:https://t.me/del_speedtestSignin Script:https://t.me/Suntany章鱼哥的SSPanel之家:https://t.me/woaizyg枫之谷加速:https://t.me/fzgjsYtFlow α:https://t.me/YtFlowVPS信号旗情报本部:https://t.me/vps_xinhaoqi飞享一刻:https://t.me/fhyw37咸鱼News:https://t.me/saltyfishnews软件Microsoft users:https://t.me/Microsofthelp捷径 Shortcuts:https://t.me/SiriShortcuts捷径社区:https://t.me/shortcuts_cnSnipaste:https://t.me/joinchat/BGyWwD9ZNqE3pLbhXc-VgQSnipaste Discuss:https://t.me/joinchat/BGyWwEDqrqiwizDA6gt16gPrice Tag:https://t.me/pricetagappApp 种草群:https://t.me/appfoundgroup版本控:https://t.me/nextnbChrome:https://t.me/ChromeCNMWeb 及相关讨论:https://t.me/mwebappMOZE 官方群:https://t.me/mozeapp岁寒输入法交流:https://t.me/SuiHanIMEHyperApp:https://t.me/hyperappPlus Messenger Support:https://t.me/plusmsgrchatPlus Messenger Chat:https://t.me/offTopicPlusChatPlus Messenger 中文討論區:https://t.me/plusfgcUnigram Insiders:https://t.me/unigraminsidersDocker:https://t.me/dockertutorialPin:https://t.me/PinTG奇点:https://t.me/jidianThor:https://t.me/thorshuThor HTTP Sniffer:https://t.me/thoranubisThor/HTTP/JSBox/捷径/Cydia交流群:https://t.me/yqc_666Pythonista 3:https://t.me/Pythonista3jiaoliuquniTools:https://t.me/toolinboxX.cat:https://t.me/PcatAppDrafts:https://t.me/drafts4Aria2 中文交流群:https://t.me/Aria2_CNLucis（优雅的第三方 Tumblr 客户端）:https://t.me/LucisAppLyricsX:https://t.me/LyricsXTestFlightPureWriter’s Friends:https://t.me/purewriter/码农群英会:https://t.me/devmanmanEOS:https://t.me/EOSprojectSifter:https://t.me/sifterappIINA 中文:https://t.me/IINAUsersZHIINA:https://t.me/IINAUsersRSSHub:https://t.me/rsshubPPHub 官方群:https://t.me/joinchat/Jn89QxI2MWt9hgTLQQW2GgCuto 壁纸:https://t.me/joinchat/BC6PtD89sEGgHKR28OtQVAUpperSoft-讨论组:https://t.me/UpperSoftDiscussMac玩儿法茶馆:https://t.me/waerfa软件技术资源共享:https://t.me/SharedResourcesplusTelePlus 官方討論組:https://t.me/TelePlus_GroupMK播放器:https://t.me/MKPlayerApp畅邮（Cymail）电子邮箱客户端:https://t.me/cyemail记账应用讨论:https://t.me/accountingappsMixin Network (XIN):https://t.me/MixinCommunity52破解信息:https://t.me/wuaipojieLaunch Center Pro 交流分享:https://t.me/lcpappReddigram:https://t.me/reddigramNicegram Chat:https://t.me/nicegramchatAdGuard Chat [EN]:https://t.me/adguard_enAdguard [CN]:https://t.me/adguard_cnAdGuard 【中文】:https://t.me/AdGuard_chineseGridea 群组:https://t.me/joinchat/IDY0ahRqb8NPodv95BNpBgOffice Tool Group:https://t.me/joinchat/GdsEL0ejcWZ-T-koyW4WugExcel学习群:https://t.me/excellearnerVShareCloud:https://t.me/VShareCloudMoonFM:https://t.me/joinchat/FLWvJhDhXGAQO5SGDg87nwTelegreat 中文支援區:https://t.me/TelegreatXInstagram:https://t.me/joinchat/AAAAAFL_lXy0yPL754j5CQPanDownload交流群:https://t.me/joinchat/Lz9fSlOgUUyinc5N7Gv6tgAPKs, ROMs &amp; Tools:https://t.me/r3l3as3sdotPlayer 小点播放器:https://t.me/dotplayer期待APP:https://t.me/angeliachatElpass:https://t.me/ElpassAppuTools:https://t.me/u_toolsttte for Twitter:https://t.me/ttteappHere内测群:https://t.me/HereAppPigeon Insiders:https://t.me/pigeon_appVNoteX:https://t.me/vnotexVVebo官方群:https://t.me/vvebogroupVVeboX非官方群:https://t.me/VVeboX_unofficialGBox官方交流群:https://t.me/GBoxTGGBox Official:https://t.me/GBoxOfficialTransno:https://t.me/transnousergroupFastClip:https://t.me/fastclipchatStack Insiders:https://t.me/stack_apppyTelegramBotAPI:https://t.me/joinchat/Bn4ixj84FIZVkwhk2jag6ACC来电拦截:https://t.me/ccblockerSubs - subscriptions tracker:https://t.me/app_subs时光软件:https://t.me/sgxxqgScriptable 交流群:https://t.me/Scriptable_JS社区/用户Telegram 中文社群:https://t.me/yxbjxVultr 中文社群:https://t.me/vultr_groupBear 熊掌记用户群:https://t.me/joinchat/Ag98FxRIKr7UkwUPqKKmfwRSS 交流群:https://t.me/joinchat/Ag98F0evTbZwY8HB7oH4fA笔记软件交流讨论:https://t.me/joinchat/Ag98F0DdcZr1X1xS6lJsyA幕布用户群:https://t.me/joinchat/Ag98F01tRQ2RIk_icHhiyA为知笔记用户群:https://t.me/joinchat/Ag98F1MLJji5WC5OpjAcHQ有道云笔记用户群:https://t.me/joinchat/Ag98F1C2ip5g0Bac_KCJ2ATodoist 用户群:https://t.me/joinchat/Ag98F1DuGqE_dIiNkeM2uASimplenote 用户群:https://t.me/joinchat/Ag98F0f7fjEKqZKVHNW0aAMarginNote 用户群:https://t.me/joinchat/Ag98F0ZLDrJZOSBWXAEiowiMazing 用户群:https://t.me/joinchat/Ag98F07KJmIlmwSCfTOKxQTypora 用户群:https://t.me/joinchat/Ag98FxBSO7eJ9mMwxxUIPwNewlearner水群:https://t.me/NewlearnerGroup科技花:https://t.me/zaihuachat谷歌交流社区 • 科技圈:https://t.me/GoogleFans逗比根据地:https://t.me/doubi逗比根据地:https://t.me/doubi2中文输入法爱好者群:https://t.me/IME_zhCN少数派 sspai 社群 非官方:https://t.me/sspai_groupiOS &amp; Mac · Free Talk:https://t.me/joinchat/BC6PtDwOzSNWFpXosJUnYwAndroid · Free Talk:https://t.me/joinchat/BC6PtDwBMhfDu6pnrg2wgwTech·Free Talk:https://t.me/joinchat/Ag98FzveUjPyDL-fMVNuXgAndroid &amp; iOS 相爱群:https://t.me/iosandandroidloveApple Talk 交流群:https://t.me/apple_talkApple Park:https://t.me/apple_parkAPPLE 交流群:http://t.me/apple_cnApple 产品交流群:https://t.me/applepro2iBeta 尝鲜派 官方用户讨论群:https://t.me/ibetame库克的后厨 Cook’s Kitchen:https://t.me/OnlineAppleUserGroup不知名科技吐槽:https://t.me/LifeAnaTechApple Watch 大集合:https://t.me/apple_watchApple TV+:https://t.me/AppleTVPlusApple Arcade CN:https://t.me/applearcadecnmimi:https://t.me/Orz_mini肆意🅥科学上网:https://t.me/kexueshangwang_41电脑玩物:https://t.me/joinchat/CHRBlQyz8PjB_RzmdXTavQ程序员技术资源分享群(陈皓(左耳朵耗子)创建的群):https://t.me/joinchat/FwAZpxdwmTHP2W1sPydPAQtinyfool的墙外群:https://t.me/joinchat/MqAAGRSeOCbZ1qDsOLBwig高可用技术研究:https://t.me/joinchat/FiMK0A5tQhJxLu9tBb0QTA大虾的编程资源交流群:https://t.me/programmingsrchubgroup东京IT技术者交流群:https://t.me/TokyoITPixelExperience - Official chat:https://t.me/pixelexperiencechat🔍telegram🇨🇳综合搜索:https://t.me/sssoou_resource🐑telegram🇨🇳羊毛自助搜索:https://t.me/sssoou_yangmao一加手机/OnePlus:https://t.me/oneplus666GIF 群聚地:https://t.me/GIFgroupTW貼圖群 Sticker Group:https://t.me/StickerGroupV2EX 后花园:https://t.me/joinchat/Bg3MFjv5FgYrWI0WqHDo8QV2EX 后花园 v2.0:https://t.me/goV2EXV2EX 交流群:https://t.me/v2exchatV2EX-修仙:https://t.me/xiuxianAppinn Talk (小众软件):https://t.me/appinnSetapp 开车群:https://t.me/joinchat/AacydhT79JJBmDj68rCC9wSetapp 拼车群:https://t.me/setapp_diSetApp - Mac玩儿法开车群:https://t.me/setappondriveJS神技能:https://t.me/joinchat/IH5XJktzBKU7RptjDo9fXQ电丸科技AK:https://t.me/joinchat/J0l1qkdif6F3O8T6sVvXtwBIGdongdongGroup:https://t.me/bigdongdongGroupCODEKON 抗压能力研究所:https://t.me/WhiteBoard2019YouTube—ImShuker:https://t.me/shukerzNotion 中文社区:https://t.me/NotionsoNotion爱好者交流:https://t.me/NotionfansNotionPlus:https://t.me/joinchat/Grv3kRuQAtl7ZuY3JpUhsg电报人:https://t.me/three001Google Drive 无限容量:https://t.me/google_driveGoogle Drive 交流群:https://t.me/GoogleDriveStore搬瓦工 (BandwagonHost):https://t.me/BandwagonHostGroup跳蚤市场-科学上网交流等:http://t.me/PharosMarketShopping读舍 - 享受阅读时光:https://t.me/shufmiGame 游戏交流群:https://t.me/gamecn读书会:https://t.me/readingclub1984读书会众议院:https://t.me/readingclubhouse鲸发现:https://t.me/whalediscovery无限月读Group:https://t.me/la4jiNF^2 影视交流群:https://t.me/joinchat/M8iUbkx2I_gi-wGusMqDUA4K影视屋-蓝光无损 Chat:https://t.me/yingshiwuPayPal交流群:http://t.me/paypal_us游戏交流群:https://t.me/cngamekindle电子书读书会:https://t.me/zebook创造者们:https://t.me/joinchat/DNc0EECuTl_xs0O30bvCWQ数码养生:https://t.me/joinchat/KN3lR1QT8tGXImuc8L8k3g编程随想读者群:https://t.me/programthinkreader码力全开 Friends:http://t.me/forcecoderOpenWRT 编译官方大群:https://t.me/joinchat/JhKgAA6Hx1uiihA7RaTW1wOpenWRT LEDE/Wireless Routers:https://t.me/OpenWRT_Routerskoolshare OpenWRT X64:https://t.me/joinchat/ERO9vEMMVu1dzQ-F8nP6kA老毛子Padavan固件自助交流群:http://t.me/pdcn2老毛子Padavan固件IOS自助交流群:http://t.me/pdcn3安卓手机交流圈:https://t.me/androidseeGoogle Fi 交流群:https://t.me/google_fiYouTube Music:https://t.me/YTMusicCN字谈字畅听众群:https://t.me/TypeChatRuby 中文圈:https://t.me/rubycnpolyhedron:https://t.me/polyhedron聽世界:https://t.me/listentotheworldVap0rVVave:https://t.me/Vap0rVVaveNickTalk:https://t.me/nicktalkiTunes Gift Card:http://t.me/iTunesGiftiOS:https://t.me/iOSdevoteeiPad:https://t.me/aboutipadMacGG:https://t.me/macggmacOS 交流组:https://t.me/macosermacOS:https://t.me/getosxiOS 交流群:https://t.me/iOS_cniPadOS 交流群:https://t.me/iPadOSAPPLE 用户交流群:https://t.me/apple_cnmacOS 用户交流群:https://t.me/mac_cnIT之家 群组:https://t.me/iOS1314黑苹果与白苹果用户交流群:https://t.me/Balancer996233Blog:https://t.me/blog233悟空的日常粉丝:https://t.me/wkongsvlogsynology/黑群晖用户交流群:https://t.me/nasfanssgobal:https://t.me/joinchat/ESwgR0Ckp_zXMCuRKqykqAGroupHub_Chat:https://t.me/GroupHub_Chat中国数字时代读者群:https://t.me/cdtchinese掘金 iOS 开发交流群:https://t.me/joinchat/BAjjKkLl8h5wfynrpFvOwQ掘金 Android 开发交流群:https://t.me/joinchat/BAjjKkMXyR2_SrASapNZ0AGoogle Voice 交流群:https://t.me/googlevoiceGoogle Voice 互拨交流群:https://t.me/zh_GVGoogle Play Party:https://t.me/joinchat/AAAAAEQyqqFfIeHCsuQe5wGoogle Fans Club 中文:https://t.me/googlecnIngress Prime 讨论群:https://t.me/joinchat/BJY4f03cl_8YHMdUrVDxuwRedSoloCup’s League of Ingress Agents:https://t.me/joinchat/DEqMlRFr-nH2lu73mP7_9QGTD Users Base:https://t.me/gtdusersbase小米手机讨论群:https://t.me/M_PhoneMIUI Beta Team - China:https://t.me/joinchat/DdB-ZxL__BxfXlQCGJUUmgM-Team official chat - Chinese:https://t.me/M_Team_ChatNexus Users:https://t.me/nexususersOne Plus:https://t.me/oneplus3ttGoogle交流群:https://t.me/GoogleFans生活 读书 新知:https://t.me/joinchat/BZKdbj1dAu5m8X48JV2gYg主机测评(zhujiceping.com):https://t.me/zhujicepingBTSynChina中文资源分享:https://t.me/btsynchinaSync资源分享讨论:https://t.me/joinchat/Drwnmz6wvT8wpIcFEBI57gNAS私有云技术交流:https://t.me/NASteam路由器固件玩家群:https://t.me/sbxswDev. iOS/macOS/watchOS/tvOS:https://t.me/AppleDevCNJava 编程语言:https://t.me/JavaerJava Programming Chat:http://t.me/javaprogrammingchatIT人的生活日常:https://t.me/it_normal_lifeAndroid Develop 中文讨论群:https://t.me/AndroidDevCnAndroid Delicious:https://t.me/AndroidDiscussAndroid Dev:https://t.me/AndroidDevChatAndroid Dev[CN]:https://t.me/AndroidDevCn网易云音乐:https://t.me/NetEaseMusicGeeks Chat:https://t.me/geeksChatNintendo Switch 闲聊群:https://t.me/NintendoSwitchCN红红火火恍恍惚惚:https://t.me/joinchat/DfC7Q0HhtNTA5R53WfAZyQ香港 IT 群:https://t.me/din_lo_it酷友交流群:https://t.me/coolapkchinaZeroNet[zh]:https://t.me/joinchat/AAAAAAtSeltSs7ffxR0wzwBeijing GNU/Linux User Group:https://t.me/beijinglugMAT - 广场（My Android Tools）:https://t.me/MyAndroidTools美剧交流群:https://t.me/SSKMJBTSTg攝影社群:https://t.me/photographyintelegram知日讀者群:https://t.me/zhijapanfibjs 交流:https://t.me/fibjs加密货币与区块链讨论群:https://t.me/onBlockchain第欧根尼俱乐部 The Diogenes Club:https://t.me/TheDiogenesClubNetflix迷:https://t.me/NetflixFunNetflix 讨论群:https://t.me/netflixchinaNetflix 讨论:https://t.me/joinchat/C94vkUP2WbygEhA59U4mZANetflix-剧天堂:https://t.me/NetflixGodNetflix等App解锁:https://t.me/happy_dns解锁大会员的世界:https://t.me/bili_bi莓友会:https://t.me/bbfans群晖壕技术交流:https://t.me/joinchat/BzNX6A2jzj1nMBlltYKbEg社工库机器人CCTV认证群:https://t.me/shegroupgate.io的小伙伴们:https://t.me/gate_ioSteam:https://t.me/SteamCNthe speechless $$ apexidea:https://t.me/thespeechlessDEW官方中文群:https://t.me/dew_cnDEW Offical EnglishGroup:https://t.me/dew_enDEW 日本語グループ:https://t.me/dew_jpDEW 공식 한국어 그룹:https://t.me/dew_krPython数据社群,数据分析大数据相关知识交流:https://t.me/datapyTechCrunch中文版讨论组:https://t.me/techcrunchcngroup锤子科技 Smartisan 讨论组:https://t.me/smartisan_unofficial内涵段子:https://t.me/duanzigeTeFuir 自渡:https://t.me/TeFuirZIDuDribbble 设计交流:https://t.me/dribbbletalkAndroid Plaza:https://t.me/AndroidPlaza[ZH/EN] 摄影:https://t.me/cnphotog加速吧小宝（koolshare merlin firmware）:https://t.me/xbchat软路由综合交流群:https://t.me/Balancer66软路由交流群:https://t.me/ruanlueSir PlayGround:https://t.me/joinchat/JjxmyRZZXJWb74I-sCrryAeSir Playground固件&amp;插件交流群:https://t.me/joinchat/JjxmyUrN3utQKXt_5LD54g机场联萌-Linux&amp;vps@SSpanel:http://t.me/supermarket666阿里云交流群:https://t.me/Balancer985微软云(Azure)交流群:https://t.me/Balancer211谷歌云(Gcp)交流群:https://t.me/Balancer166博客搭建交流群:https://t.me/Balancer863Tasker中文交流群组:https://t.me/taskercn简信用户群:https://t.me/mailtimeRime&amp;iRime交流群:https://t.me/joinchat/F2HuOQpBU2NjUrg8ybQMDgVim 用户交流群:http://t.me/vimhubiOS 越狱讨论群:https://t.me/iOS_JailbreakiOS 越狱交流群:https://t.me/iOS_jailbreakingJailbreak Chat:https://t.me/joinchat/AAAAAD161xTKVMuu-bOaxgTelegram Hath Group:https://t.me/telehathgroupVps交流:https://t.me/talkvps自由世界之声:https://t.me/TetgramC今日我地唔倾健身倾人生:https://t.me/telegrcProduct Hunt 分享讨论:https://t.me/joinchat/CreGnBZN4DGqRb4HiBkm9gwikipedia-zh:https://t.me/wikipedia_zh_nOld-wikipedia-zh:https://t.me/wikipedia_zhwikipedia-zh-help:https://t.me/wikipedia_zh_helpwikipedia-zh-game:https://t.me/wikipedia_zh_gamewikipedia-zh-science&amp;technology:https://t.me/wikipedia_zh_science_and_techwikipedia-zh-computer-science:https://t.me/wikipedia_zh_cswikipedia-zh-humanities&amp;SoSci:https://t.me/wikipedia_zh_humanitieswikipedia-zh-jurisprudence:https://t.me/wikipedia_zh_jurisprudencewikipedia-zh-entertainment&amp;art:https://t.me/wikipedia_zh_entmt_and_artwikipedia-zh-acg:https://t.me/wikipedia_zh_acg_nwikipedia-zh-physics:https://t.me/wikipedia_zh_physicswikipedia-zh-BioMed:https://t.me/Wikipedia_zh_bio_and_medwikipedia-zh-language:https://t.me/wikipedia_zh_langwikipedia-zh-translation:https://t.me/wikipedia_zh_translationwikipedia-zh-food&amp;drink:https://t.me/wikipedia_zh_food_and_drinkwikipedia-zh-sports:https://t.me/wikipedia_zh_sportswikipedia-zh-library&amp;museum:https://t.me/wikipedia_zh_libwikipedia-zh-Geo&amp;Transpt:https://t.me/wikipedia_zh_geo_and_transptwikipedia-zh-LGBT+:https://t.me/wikipedia_zh_LGBTwikipedia-zh-appeal&amp;meta:https://t.me/wikipedia_zh_appeal_n_metawikipedia-zh-DC:https://t.me/wikipedia_zh_DCwikipedia-zh-ingress:https://t.me/wikipedia_zh_ingress台大維基社:https://t.me/ntuwpc高雄維基人 Kaohsiung Wikimedia community:https://t.me/wikikaohsiung維基學生會:https://t.me/wikipedia_zh_wsu邊緣人小組｜边缘人小组 Marginalized Persons’ Club:https://t.me/marginalizedpersonsclub《維基人》讀者交流群:https://t.me/the_Wikipedian_groupwikipedia-zh patrol:https://t.me/wikipedia_zh_patrolWikipedia-zh-DYK:https://t.me/wikipedia_zh_dykzh wiki bulletin:https://t.me/zhwiki_bulletin中文维基《求闻》- Qiuwen Chinese Wikipedia:https://t.me/Qiuwenwikimedia-commons-zh:https://t.me/wikimedia_commons_zhwikibooks-zh:https://t.me/wikibooks_zhwikisource-zh:https://t.me/wikisource_zhwikiversity-zh:https://t.me/wikiversity_zhwikinews-zh:https://t.me/wikinews_zh_nwikivoyage-zh:https://t.me/wikivoyage_zhwikipedia-lzh:https://t.me/wikipedia_lzhlzh wiki bulletin:https://t.me/lzhwiki_bulletinWamLzh:https://t.me/wamlzhcvn-zho:https://t.me/cvn_zhocvn-zh-sw:https://t.me/cvn_zh_swwikipedia-mnc:https://t.me/wikipedia_mncwikipedia-yue:https://t.me/wikipedia_yuewikipedia-cdo:https://t.me/wikipedia_cdocdo wiki bulletin:https://t.me/cdowiki_bulletinRetroShare:https://t.me/cnretroshareMoeUnion:https://t.me/MoeUnionVediotalk:https://t.me/VedioTalkGroup利器 👨🏻‍💻👩‍💻 🧤:https://t.me/fun_makersDeveloper 中文圈:https://t.me/coderzh酷安闲聊群:https://t.me/coolapkxianliao酷安:https://t.me/cool_apkLicenses Group 合租 美剧讨论 薅羊毛:https://t.me/Licensess[合租] Netflix Spotify office365 YouTube Hulu Surge等音乐影视:https://t.me/hezu1合租小车🚗:https://t.me/TogetherHub拼车小组:https://t.me/PinCheGroupBen先生的闲聊群:https://t.me/Ben_zahuopunetflix spotify hulu账号交流:https://t.me/zxc1017yyfxNETFLIX极乐世界:https://t.me/duxiangNFNetflix/Spo/Hulu/HBO低价体验车:https://t.me/FreetrialStoreBen先生的杂货铺:https://t.me/joinchat/K1vTsBMebnPn7mLwR6KGmAEhViewer・DEPRECATED・交流群:https://t.me/ehviewer谈股论金:https://t.me/CNFinance三家村:https://t.me/platoer谷歌、微软云盘讨论群:https://t.me/google_win黑洞资源交流群:https://t.me/debated好棒 羊毛福利站 自助查:https://t.me/dajiajia优质 淘宝 京东 隐藏优惠券 福利推荐:https://t.me/taobaojuan频道🏆资源福利分享 Chat:https://t.me/freemorebestchatVIA Official Group:https://t.me/viatgMagisk中文讨论群组:https://t.me/magiskCNshareLetITFly’s Group:https://t.me/joinchat/DnJ2K0An6XhI3N-5EK2FtASpotify Addict Group:https://t.me/spotifyaddictSpotify使用者:https://t.me/joinchat/DlW6BkAiT7ReIIADtANzYwApple Music:https://t.me/amthings远鉴字幕组官方交流群:https://t.me/joinchat/KmUaGRU5OgWsuv27BABIDg奈菲影视求片专用群:https://t.me/joinchat/KmUaGRMWdO29JVd3wcCHCg峰哥分享技术交流超级群:https://t.me/fengsharegroupTG技术党:https://t.me/MRHXPJ真是药丸:https://t.me/joinchat/L5ipUhYff4tk98bOrdqutQTelegram中文:https://t.me/Chat_CN网络中文圈:https://t.me/CN_InternetBitcron 中文圈:https://t.me/bitcron小点播放器+m3u8直播源交流群:https://t.me/conchplayerSaoDaye - TG总群:https://t.me/saodayeSaoDaye - TG飙车:https://t.me/yiqisaoPi&amp;N1玩家交流群,专业:https://t.me/PIN1GroupeBooksPlan小声读书:https://t.me/what_youread读书分享:https://t.me/dushufenxiang_chatzread 读书会:https://t.me/zreadi-Book.in 讨论组:https://t.me/i_book_inChinese Developers:https://t.me/ChineseDevelopersBAT 大家庭:https://t.me/china_net_group三人行中文群(工作生活学习交流平台):https://t.me/three001996.ICU:https://t.me/anti996流浪防区 /r/China_irl 官方群:https://t.me/China_irl流浪防区 666游戏厅:https://t.me/China_irl_GamesMi Video feedback group:https://t.me/MiVideoFeedbackTelegramd中文技术交流群:https://t.me/cntelegramd主机贴士:https://t.me/BWH1NET二进制/sudo:https://t.me/huochesijiGoogle Voice讨论组:https://t.me/swatpc1Ssrconnect:https://t.me/ssrconnect专业Linux/运维/虚拟化讨论:https://t.me/professionallinux酸奶ssr2.0:https://t.me/ssruSSR浪漫生活群:https://t.me/llmsh软件源TG:https://t.me/appcgntg趣·享:https://t.me/peekfun免费DDOS群:https://t.me/joinchat/Ma3VglCDtwnOGNPbKAl5MwTYPCN Group:https://t.me/joinchat/BoV2zj_WY5j8BxC98_6MCQ今天的砼与钢(建筑群):https://t.me/jintiandetongyugang苹果旧版交流:https://t.me/xinapp特斯拉 Tesla 交流群:https://t.me/teslafast网络技术交流–AE:https://t.me/joinchat/KvkGoxAJywGVPq7LVUAXugAmazon 海淘购物交流群:https://t.me/firstAmazonApple Boy:https://t.me/joinchat/BJpk_BFL2deF7841fGKEbQGoogle Suite 交流群:http://t.me/googlesuitelibra 区块链大中华交流:https://t.me/joinchat/Lfx59xaZjZfOm8BEJXgSGQ夸吧·夸夸群:https://t.me/kuaba谷歌云端GCP交流群:http://t.me/Google_CloudPlatformCloudflare在中国:https://t.me/CN_Cloudflare月光博客IT技术交流群:https://t.me/yueguangqunPixel 3 小窝:https://t.me/Pixel3House戒赌吧2.0:https://t.me/joinchat/FHxB4lkIZ3IjoCt3_Yh3awTbo 粉丝群:https://t.me/TboJiangGroupGDrive , INFUSE , SYNOLOGY , PLEX:https://t.me/infusetvOur Bittorrents Club:https://t.me/joinchat/IST_uFF7P-u5oecKl3uvFg戒赌吧2.0:https://t.me/joinchat/L6o3d1kIZ3JCcg2ki2SGsg群组检索导航:https://t.me/Groups_cn日本語学習Japanese Study:https://t.me/joinchat/BGDV_Qcq7MTcpiFkB2n7FwZUOLUOTV 专属交流群:https://t.me/zuoluotv不知名科技吐槽:https://t.me/ApexIdeaTechKevin自留地:https://t.me/mrkevinh主机百科:https://t.me/zhujiwikiAffyun.com:https://t.me/pingcat91yun.co 大海航行靠舵手:https://t.me/im91yunLeonn:https://t.me/zhenggui古博-VPS仓交流群/VPS推荐实测:https://t.me/guboorg如有乐享:https://t.me/joinchat/EqJkBQ4FsPUuWoN8HsOjNgTechnical Blog 技術博客:https://t.me/Technical_BlogGigsGigsCloud.com 意见交流:http://t.me/gigsgigscloudgroupTenVM/ToSpeed 交流群:https://t.me/tenvmgroup微基主机讨论组 - 原50KVM/50VZ:https://t.me/network50_chatNathosts主机交流群:https://t.me/nathostsHKServerSolution 交流&amp;建议:https://t.me/hkserversolution爱听歌交流群:https://t.me/musictools666利器社群在 TG 上的分支:http://t.me/fun_makers圆角水群:https://t.me/UoVzCloud中文独立博客:https://t.me/indieBlogsTelegram蛤丝总群:https://t.me/joinchat/EgReJ0BeLkTPKtZLJ1HipA黑苹果osx86项目中文讨论/Hackintosh CHN Discussion:https://t.me/osx86zhChromebook CN:https://t.me/chromebook_cnC 语言中文交流:https://t.me/ClanguagezhC++ 中文交流:https://t.me/cpluspluszhCSS 討論區:https://t.me/csstwHaskell 中文交流:https://t.me/haskellzhJavaScript 中文交流:https://t.me/javascriptzhJulia 编程语言交流:https://t.me/julialangzhPerl 中文交流:https://t.me/perlzhPython:https://t.me/PythonPython中文社区:https://t.me/PyChinaPython 中文交流:https://t.me/pythonzhGo:https://t.me/GolangCNR 语言中文交流:https://t.me/rprojectzhScala 中文群组:https://t.me/scala_zhTypeScript 中文交流:https://t.me/typescriptzhKali / BlackArch Linux 中文交流:https://t.me/hackerzhCentOS 中文:https://t.me/centoszhUbuntu 中文:https://t.me/ubuntuzhSublimeText用户组:https://t.me/sublimecnJava/Android开发交流:https://t.me/java_android_dev大数据杂谈:https://t.me/bigdatazhFrontend 前端中文技术交流:https://t.me/frontend_talkiOS Dev CN:https://t.me/iOS_Dev_CNStone Server 中文交流:https://t.me/stone_serverHexo 博客交流:https://t.me/hexozhHugo 博客交流:https://t.me/hugoblogDat 中文交流:https://t.me/datzhZeroNet 中文交流:https://t.me/zeronetzhGoogle Play 交流:https://t.me/googleplay_cn体育爱好者/足球/篮球/NBA/CBA 交流:https://t.me/tiyu365Wallpapers 壁纸:https://t.me/G_WallpapersSM.MS 图床粉丝群:https://t.me/smms_images博物館愛好者 Museum lovers:https://t.me/PakMyotKuanhios黑科技交流群:https://t.me/ioshkj007HN 中文社区:https://t.me/hn_china树莓派:https://t.me/shumeipai中英語言学习:https://t.me/LinguisticAcademyTechCrunch中文讨论组:https://t.me/tcchineseLotteryHelperBot 抽奖群:https://t.me/Lottery_Group🀄️ Fedora 中文用户组:https://t.me/fedorazhiOS软件学习交流:https://t.me/ChujiuGGG家庭网络资源共享群:https://t.me/homenet6UoL BSc讨论组:https://t.me/uolbsc「韵味科技」TG技术交流群:https://t.me/ywadminPS4:https://t.me/ps4cn2Nintendo Switch 娱乐 - 动森:https://t.me/nintendoswitch_cn财经幽灵电报群:https://t.me/financial_ghostGroupTg云音乐:https://t.me/Tgsongs中文音樂討論群組:https://t.me/joinchat/AyylyVG1Gf-53dJgnjjq9A智能家居交流群:https://t.me/homeassiant666Handshake中文社区:https://t.me/handshake_cn第二现场:https://t.me/dearlive科技聚会:https://t.me/pixelcnSurge for Android:https://t.me/SurgeforAndroid翼起乐:https://t.me/YiQiLePanoanDrive(离线下载自动转存Google Drive):https://t.me/PanoanDriveBasic数字移民讨论群:https://t.me/shuziyimin_groupAnytype community:https://t.me/anytypeGraphQL China:https://t.me/graphql_china今日热榜:https://t.me/joinchat/IL6n4w9xiRMvHaU1YpVFog品品品品葱葱葱葱:https://t.me/pcfanzei茶馆Teahouse:https://t.me/aTeaHouse柯基犬的日常 - 吹水群:https://t.me/UntitledGroup希饭 学习&amp;技术&amp;分享:https://t.me/idcmoe荔枝木上荔枝果，荔枝木下你和我:https://t.me/lycheewood_discuss西西书屋 精校电子书:https://t.me/xixishuwu读者中心:https://t.me/duzhe今天你动森了吗:https://t.me/AnimalCrossingXLife &amp; Knowledge.:https://t.me/LifeAndKnowledge[CN]Flutter Dev:https://t.me/FlutterCNinfuse交流群:https://t.me/infusepro6台灣蘋果同好交流群:https://t.me/TaiwanAppleFans日本旅遊同好交流群:https://t.me/JP_Travel高清影音数码折腾群:https://t.me/TalkUHDBot开发者交流群:https://t.me/bot_dev_groupVULTR用户交流群:https://t.me/VultrChatTGX-社群:https://t.me/tgx_groupXDA-General:https://t.me/joinchat/GobKO1HujyceuQ_ijPmmFwXDA-Chromebooks:https://t.me/joinchat/GobKO0oLNMy0AVuHsL4ApQXDA-Google:https://t.me/joinchat/GobKO059P187L04_lROAjAXDA-Samsung:https://t.me/joinchat/GobKO1MO9T7g7iY2y1-oLgXDA-OnePlus:https://t.me/joinchat/GobKO0WAM7JznxHXgKkCiwXDA-Huawei:https://t.me/joinchat/GobKO0yVKYAHOOON_KuXIwXDA-Realme:https://t.me/joinchat/GobKO1b8S_BrnHRZ3N_ScwXDA-Sony:https://t.me/joinchat/GobKO0fZhvNzc__RcJuGzQXDA-HTC:https://t.me/joinchat/GobKO0BtfvCQLqQ6SAqregXDA-LG:https://t.me/joinchat/GobKO1HUnWgyZcjQ8iIkRAXDA-Motorola:https://t.me/joinchat/GobKO0fPbFnKzIzUq8QD2AXDA-Nokia:https://t.me/joinchat/GobKO08UpiE7HUWxr_yc2AXDA Labs:https://t.me/xda_feed微信读书分享交流:https://t.me/iWeRead码力全开 Friends:https://t.me/forcecoder互联网1号聊天室:https://t.me/chatroom11111FlyOS Official Group:https://t.me/flyosproRed C Linux DEV.&amp;COM.:https://t.me/redclinux多平台技术交流:https://t.me/alldesktop奈飞Pro - Netflix奈飞合租/拼车:https://t.me/naifei_pro中文翻译机器人反馈群:https://t.me/fanyi_group各种云☁️交流群:http://t.me/Server699SaltyLeo的博客讨论组:https://t.me/SaltyLeo_blog数字尾巴粉丝群:https://t.me/joinchat/GnoDABh4Ob-e5zKOOMe4bgCodingStartup 起碼課:https://t.me/codingstartupOpenWrt DiscussCTCGFW’s Group:https://t.me/ctcgfw_openwrt_discussPLEX/EMBY交流群:https://t.me/bigdongdongmediaAlook 视频解析 收集 分享:https://t.me/jsdayanki交流群:https://t.me/anki_appPayPal交流群:https://t.me/paypal_us播客Checked.FM 听众群:https://t.me/joinchat/Ag98Fw0TEeBh2Xz8s0d9mg一天世界:https://t.me/ipn_yitianshijie○△□（不鳥萬通讯）:https://t.me/igiveafuck灭茶苦茶 听众群:https://t.me/ipn_miechakucha选・美 听众群:https://t.me/joinchat/At5ANzwvTWoETwagE5S09w《内核恐慌》听众群:https://t.me/pan_icu博物志 听众群:https://t.me/museelogue太医来了 听众群:https://t.me/taiyilaile味之道 听众群:https://t.me/joinchat/At5ANzuy5JM9yhPrmuGrcQ流行通信 听众群:https://t.me/joinchat/At5ANzuiD519i5bvwvZprA硬影像 听众群:https://t.me/joinchat/BpH28D58cUGp1jXFHWvpww無次元 听众群:https://t.me/joinchat/A4fzlAC1AatZACa_NSKqwg(Hi)story 听众群:https://t.me/HistoryCheap壁下观 听众群:https://t.me/ipn_bixiaguan疯投圈 听众群:https://t.me/crazycapital时尚怪物 听众群:https://t.me/ipn_fashionmonster科技聚变 TechFusion 听众群:https://t.me/TechFusionChat播客大家谈:https://t.me/bokecn「得意忘形」听众群:https://t.me/joinchat/Bx8JqQ33oVCrKSul-cHJGQ津津乐道听友交流:https://t.me/htnpodcastTelegramDurov’s Chat:https://t.me/durovschat官方翻译支持群 English:https://t.me/translation_en官方翻译支持群 简体中文 (聪聪):https://t.me/translation_zhcncc官方翻译支持群 简体中文:https://t.me/translation_zh_hans官方翻译支持群 简体中文(@zh_CN 版):https://t.me/translation_classic_zh_cn官方翻译支持群 简体中文(langCN):https://t.me/translation_zhlangcn官方翻译支持群 瓜体中文:https://t.me/translation_duang_zh_hans官方翻译支持群 繁体中文(香港):https://t.me/translation_zh_hant官方翻译支持群 繁体中文(台湾):https://t.me/translation_taiwan官方翻译支持群 喵体中文 （ @MiaoCN ）:https://t.me/translation_meowcn官方翻译支持群 郭桓桓的繁體中文語言包:https://t.me/translation_zhong_taiwan_traditional官方翻译支持群 文言:https://t.me/translation_chinese_ancientTG 简中交流（水）群:https://t.me/cnpubTelegram 討論區:https://t.me/PublicGroupForzhTelegram 新手帮助:https://t.me/newbie_chatTelegram X iOS:https://t.me/tgiostestsTelegram iOS Talk:https://t.me/TelegramiOStalkTelegram Android Talk:https://t.me/TelegramAndroidTalkTelegram X Android:https://t.me/tgandroidtestsTelegram macOS:https://t.me/macswiftTelegram macOS Talk:https://t.me/TelegramMacOsTalkTelegram Desktop Talk:https://t.me/TelegramDesktopTalkTelegram Windows Phone Talk:https://t.me/TelegramWPtalkTelegram Bot Talk:https://t.me/BotTalkTelegram Party:https://t.me/PublicTestGroupTelegram Android Themes:https://t.me/AndroidThemesGroupTelegram Desktop Themes:https://t.me/TelegramThemesTelegram X: Themes:http://t.me/tgx_perfectionTelegram Beta Chat:https://t.me/tgbetachatTentang Telegram:https://t.me/tentangtelegramInstant View Platform Chat:https://t.me/IVpublicTelegram 新手問答區:https://t.me/TGQNA電報群推廣:https://t.me/joinchat/FAir4j15AV8Q_x5zzoc8ywKeralaGram:https://t.me/keralagramTelegram 新手频道讨论组:https://t.me/newbie_tele_discussionCNBlacklistR 交流群:https://t.me/joinchat/FfbG_g9eWFL1-8vEhY4xlQ地区群成都:https://t.me/cheng_du深圳:https://t.me/shenzhenbot?start=join深圳:https://t.me/shenzhentg北京:https://t.me/beijingz上海:https://t.me/shanghai_tg广州:https://t.me/GuangzhouIT四川:https://t.me/civhuanglaoxiao川渝:https://t.me/chongqing_sichuang西安:https://t.me/XianCity南宁:https://t.me/NanNingTG滕州:https://t.me/tengzhou徐州:https://t.me/tgdxz烟台:https://t.me/yantaiinfo湖南:https://t.me/hunantg济南:https://t.me/jinan_tg郑州:https://t.me/zhengzhoutg武汉:https://t.me/joinchat/AAAAAEPsBibY4oIaHgjIwg西安:https://t.me/joinchat/FY1SJkRF6ubEQzU-3Mq3cw温州:https://t.me/joinchat/AAAAAApGjPVlDbXwYSj1IA宁波:https://t.me/joinchat/IDzvnxAU9yCEh6vx4RQrPg其他Coder Offtopic 中文群:https://t.me/coder_otBoastTG:https://t.me/BoastTGSteam&amp;PlayStation&amp;Xbox&amp;Switch:https://t.me/ps4cn2數字權利 Digital rights:https://t.me/digital_rights绿岛之谜:https://t.me/joinchat/AAAAAELn2imDDoj2w9ueMQKoolProxy:https://t.me/joinchat/AAAAAD-tO7GPvfOU131_vg图话天下:https://t.me/joinchat/Ap7Q_zvEXX48wixHbtg79A要開/做/做開IT Projects嘅人:https://t.me/IT_projects_people烧饼博客粉丝群:https://t.me/sbfans圍觀設計師現場:https://t.me/lookingforqoliPureWriter’s Friends:https://t.me/joinchat/BSLnXkP8kEMg66CBcsUNGQCryptocurrency:https://t.me/joinchat/AAAAAENKOpO9tmbe5etMnARabi Coffee:https://t.me/rabicoffeeOfficial Counterparty Chat:https://t.me/Counterparty_XCPCasual ENGLISH Chat:https://t.me/joinchat/AAAAAEBz8Owuzgri6kB2UA一起玩「狼人」:https://t.me/cnwolf愚民小鎮:https://t.me/twWolfGPlusCard 交流群（非官方）:https://t.me/GPluscardIT之家:https://t.me/joinchat/0575a16a008fa17ec5457b81a4f15abeGentoo-zh:https://t.me/joinchat/0557494901586680e50d77eebd2986d2PDA 的Discovery版块:https://t.me/discoverys元朗區Pokemon:https://t.me/joinchat/DGASnj7QdwuW1LIo-5-80g今天你健身了吗:https://t.me/joinchat/AAAAAA6h4cV3PLgFQYrnCA骇客邦:https://t.me/hihackersS&amp;D两位先生:https://t.me/Science_Democracy欧美生活影视音乐圈Europe America:https://t.me/AJSCIEAARDR2 Group:https://t.me/HKRDR2抽奖机器人交流、反馈:https://t.me/BotFeedback共享资源站点翻车群:https://t.me/gxzyzdSdorica 萬象物語:https://t.me/sdoricaSit and Date:https://t.me/SitandRelaxGroup红米Note3交流群:https://t.me/Kenzo_CNCuniqUK电话卡交流群:https://t.me/CuniqUKMTP代理自助分享群:https://t.me/mtppubgMTP代理服务聊天吹水防走失群:https://t.me/joinchat/Li3nUVe9NvfwCsxZIhUtkQtg夸夸群:http://t.me/tgkkq黑产市场资源项目:https://t.me/heise888ACGN☆Taiwan:http://t.me/TaiwanAnime真是药丸:https://t.me/AllshadiaoUpperDoc Group:https://t.me/UpperDocGroup倒水,然后吹:https://t.me/joinchat/K5hKwle9NvfbSLOViD7M7giBreaking:https://t.me/iBreaking内涵段子之狼人杀:https://t.me/werewolfcn内涵段子 · 咕咕娱乐:https://t.me/DuanziGame内涵段子之闲聊群:https://t.me/OverseasChinese上帝是女孩:https://t.me/GodaregirlsTelegram 狼人杀群:https://t.me/langrensha888For Work 系列-裙子群:https://t.me/DressFWFor Work 系列-日麻群:https://t.me/MahjongFWFor Work 系列-反馈投稿摸鱼群:https://t.me/FishingFW闲聊NBA:http://t.me/bbNBATSU守望者调度交流群:https://t.me/yy688go_2019RSS屋:https://t.me/joinchat/HiIOAxV7g9JwNuLuThUsyQ@igapps 绿色应用:https://t.me/igappsTg音乐站:https://t.me/konghouTg云音乐:https://t.me/TgGeQu电报唱吧:https://t.me/changba_tg你自己的歌单群:https://t.me/laitingge柚酱的小屋:https://t.me/joinchat/I4oUNxLdCH4yj1cI7cvx-wTHKPGM’s 聊天群:https://t.me/thkpgmchatSPhard交流群:https://t.me/sphardLoreFree知识共享社区(CN/EN):https://t.me/lorefreecomios黑科技交流群:http://t.me/iosX007Netflix卡片小站:https://t.me/Leye166回形针PaperClip粉丝群:https://t.me/paperclipfans瘟疫难民254营:https://t.me/ckhunter254iShare 爱分享:https://t.me/iShareTG✈️ limboPro 🅥 TG 后花园里:https://t.me/limboprogroup璃颜&amp;红尘，伊人笑:https://t.me/liyanhongchen影视APP交流群:https://t.me/ysjlq搞笑视频:https://t.me/joinchat/AAAAAFe-j4P9-B1VgdAmJwHanan’s Group:https://t.me/hanhans2创造者日报:https://t.me/creatorsdailyTG云音乐:https://t.me/TgsongssTg唱吧总站:https://t.me/changba_tg尖叫指令:https://t.me/joinchat/LzJ_QBZg1QRICpNlKwZi4g4K影视屋-蓝光无损 Chat:https://t.me/yinshiwuZapro · 杂铺 HAPPY:https://t.me/tmioeTG科技无意义听众讨论组:https://t.me/technical_with_love8不求甚解:https://t.me/fakeye_clinic路亚🎣+养🌿🐚🦠🐟:https://t.me/fishlureOutage! Staging:https://t.me/OutageChatFaangbbs 北美程序员大群:https://t.me/faangbbs移民路上:https://t.me/OutOfTheSiegeEmperorTian吹水群:https://t.me/iOSAppJLQCount To 1 Million:https://t.me/CountToOneMillionNo U:https://t.me/NoUGroup\\o/:https://t.me/HuzzahGroup(ツ):https://t.me/ShrugGroupbboysoul:https://t.me/bboysoulcnAPPDO 数字生活指南:https://t.me/appdododo中国ChineseMasks口罩进出口:https://t.me/chinamasksFriendChCodeList:https://t.me/FriendChCodeList科学上网保护者:https://t.me/mango_channel动物森友会—无人岛串门计划:https://t.me/AnimalCrossing_CNJoyMusic:https://t.me/NetYunCunMusicAnime GIFs Collections:https://t.me/animationfans美股交流分享:https://t.me/USBullStock中国知识分子&amp;海外华人华侨&amp;聊天吹水:https://t.me/OpenNewWorld局 勢 分 析:https://t.me/joinchat/JLoGIlWLw06_eA6eHNp1Jgoooooohmygosh &amp; friends:https://t.me/omgfriends阿里云国际Alibaba Cloud:https://t.me/AlibabaCloudHKTingTalk - Group:https://t.me/tingtalkgroup一辆佛系合租车:https://t.me/HZQAM4Apps推广/抽奖/活动:https://t.me/AppsSweepstakes全球主机服务器交流中心群:https://t.me/chgggggg有价值与无价值-读者交流群:https://t.me/jiazhigroupNo.1 Manila_服务器_优秀的服务器_服务器托管租用_:https://t.me/PHmanila影音宝:https://t.me/joinchat/SLnVYRyWVJgxhPFaPcxOsAEXFLUX Networks - Chat:https://t.me/EXFLUX_GROUP麻瓜实验室:https://t.me/MugglesMagicHouseMuzik回聲古典:https://t.me/sonicwonderlandSZ 跨境卖家交流群:https://t.me/joinchat/R19cgUtMpN8dlwAYUalO8A智识社区:https://t.me/zhishiacLeetcode刷题:https://t.me/leetcode_discussLeetCode + Interview Prep 2021:https://t.me/leetcode_discussionLeetCode Uz Discuss:https://t.me/leetcodeuz_discuss验证码平台:https://t.me/wuyewanfuWildRift-英雄联盟手游:https://t.me/cnWildRift沙雕根据地:https://t.me/shadiaoo互喷群爱国粉红民主斗士互喷群:https://t.me/Stateanddemocracy大陆与港台澳互喷群:https://t.me/DLGTA大陆香港互喷群:https://t.me/cn0101装逼群(成功人士交流大本营):https://t.me/zhuangbicn地域黑互喷群:https://t.me/cityblackcn男生女生互喷群:https://t.me/boygirlVS锤粉锤黑互喷群:https://t.me/SmartisanClubssr与v2ray互喷群:https://t.me/joinchat/F_8vnkfFaoivwpZdGPt0ww前端后端程序员互喷群:https://t.me/joinchat/F_8vnkziKlPTn2PVzL2Vbg苹果华为小米oppovivo三星一加互喷群:https://t.me/joinchat/F_8vnlBNAdh4EwXc4H-ufg简体字正體字互喷群:https://t.me/joinchat/F_8vnkzmGs23y1IOyiWKXA淘宝京东互喷群:https://t.me/joinchat/F_8vnk6ABOTwIT9aWTKgTQ梅西C罗互喷群:https://t.me/joinchat/F_8vnkzMMVLfK0LQV2O1agTG微信互喷群:https://t.me/joinchat/F_8vnkc6mvUHAozhrPIQPQ肯德基麦当劳互喷群:https://t.me/joinchat/F_8vnkzTklgCJwjP1OM15Q网易云音乐QQ音乐互喷群:https://t.me/joinchat/F_8vnlFVJpjm0SkkW7-W7w主播互喷群:https://t.me/joinchat/F_8vnkrADCFwPB3j9o2C5A快手主播互喷群:https://t.me/joinchat/F_8vnk32rLM7pHbydfmndQ甜粽子咸粽子互喷群:https://t.me/joinchat/F_8vnkeiez7WnnJmocLS7w甜豆腐脑咸豆腐脑互喷群:https://t.me/joinchat/F_8vnkY4nSALn2MNZyN98g普通话与方言互喷群:https://t.me/joinchat/F_8vnkxxFhaoapKVxSHKLQOld school and trap互喷群:https://t.me/joinchat/F_8vnk1GIc8bmuMUAOWjRQ国产合资车互喷群:https://t.me/joinchat/F_8vnkoSC-PzKLkLOtEU6g无神论者与有神论者互喷群:https://t.me/joinchat/F_8vnkhMagnwTcVjHy-GGQ崔永元冯小刚互喷群:https://t.me/joinchat/F_8vnk47qc56WbNaRI92uw抖音快手互喷群:https://t.me/joinchat/F_8vnkeNYulaLdv6lvEajAAdidas Nike互喷群:https://t.me/joinchat/F_8vnkn5hgP6l1KGSE8ngg汤达人康师傅互喷群:https://t.me/joinchat/F_8vnkZOHonzN1n6URfBow农夫山朱怡宝互喷群:https://t.me/joinchat/F_8vnkxe96gSJUL-eybUKg可口可乐百事互喷群:https://t.me/joinchat/F_8vnkXyJIchDu6lqAvViw长发短发互喷群:https://t.me/joinchat/F_8vnkSi7hRX4ZYWIR7m1w摩拜ofo互喷群:https://t.me/joinchat/F_8vnkv6DO-NW8PAB6_yLg饿了么美团互喷群:https://t.me/joinchat/F_8vnkuyQEOJy6oRL2A82w全国喷北京群:https://t.me/joinchat/F_8vnlMFVp1iIId4M66uSg低端人口群:https://t.me/joinchat/F_8vnlE3eWQmDx2CUX31LQ打击流氓软件及APP群:https://t.me/joinchat/F_8vnlIqQCbjdhhMhwIu6w东西方文明互喷群:https://t.me/joinchat/F_8vnkS5h2ZktRJNO1d8_Q老板员工互喷群:https://t.me/joinchat/F_8vnlMpNxpMSOyAeznmaQ文科生理科生互喷群:https://t.me/joinchat/F_8vnlIVh0S1UHhRw2Hx6w中餐西餐互喷群:https://t.me/joinchat/F_8vnkweHskaXX2b4bcASw中医西医互喷群:https://t.me/joinchat/F_8vnkN1o4g8_cJV84fNiw12星座互喷群:https://t.me/joinchat/F_8vnk2RDL3LCVKlfXCH8A电信移动联通互喷群:https://t.me/joinchat/F_8vnkZcnV8IYQe1MvH7pw频道 ChannelTelegramDurov’s Channel（Telegram 创始人兼CEO 的频道）:https://t.me/durovTelegram 官方诈骗举报:https://t.me/notoscamTelegram-zh_CN Project:https://t.me/zh_CNTelegram 简体中文:https://t.me/Tele_zh_CNTelegram 繁体中文:https://t.me/Tele_zh_TWTelegram News:https://t.me/telegramTelegram Features:https://t.me/featuresTelegram Geeks:https://t.me/geekschannelTelegram Info:https://t.me/tginfoTelegram Apps:https://t.me/tgfilesTelegram APKs for Android:https://t.me/TAndroidAPKTelegram for macOS Updates:https://t.me/macos_stable_updates_filesTelegram Stable Releases:https://t.me/tgstableTelegram Beta:https://t.me/tgbetaTelegram X:https://t.me/tgx_androidTelegram Beta Blog:https://t.me/tgrambetaTelegram Designers:https://t.me/designersTelegram Contests:https://t.me/contestInstant View Contest News:https://t.me/IVcontestTelegram BotNews:https://t.me/BotNewsKatalog Telegram:https://t.me/katalogtelegramTelegram iOS Beta Slots:https://t.me/tgslotsTelegram Blog Secrets:https://t.me/tgblog_secretsTelegram 新手指南:https://t.me/newbie_guideTelegram 种植园:https://t.me/TelePlantingTelegram 新手入口:https://t.me/StartTGDesktop Themes Channel:https://t.me/themesTelegram Desktop Themes:https://t.me/desktopThemesTelegram Themes:https://t.me/themechannelTelegram Themes:https://t.me/themeschannelThemeTelegram X:https://t.me/ThemeTelegram_XAndroid Themes Channel:https://t.me/AndroidThemesTelegram Theme By Shana:https://t.me/ShanaThemesCancer Themes:https://t.me/cancerthemesVANILLA TELEGRAM THEMES:https://t.me/VanillaTGTelegram Stickers:https://t.me/TgStickerTelegram 新手频道:https://t.me/newbie_teleTelegram 文言翻譯之官方頻道:https://t.me/classical_chinese電報群組廣播:https://t.me/FOCUSTELEGRAMGROUPLINK電報新群推送:https://t.me/linkpushtg机器人推荐:https://t.me/tgbotlistTelegram Passport:https://t.me/TelegramPassportPlus Messenger official:https://t.me/plusmsgrKeralaGram [Official]®:https://t.me/KeralaGramChannelChallegram:https://t.me/ChallegramX Plus Channel:https://t.me/XPlus_ChannelNicegram:https://t.me/nicegramappNicegram Dev:https://t.me/nicegramdev捷报 News:https://t.me/JieBaoNews软件App 限免精选:https://t.me/appfansApp 资讯聚合:https://t.me/app_news_cniOS Releases:https://t.me/iOSUpdates限時免費 LimitFree:https://t.me/limitfreeApp限免&amp;TestFlight&amp;资讯聚合:https://t.me/AppcnAppinn Feed:https://t.me/appinnfeedThor 日常消息:https://t.me/thornoticeShu 使用技巧:https://t.me/shuskillAnubis 网络调试技巧:https://t.me/anubisskillGoogle Play Public:https://t.me/GooglePlayPublicSnipaste:https://t.me/snipasteSnipaste-Mac-Bugs:https://t.me/joinchat/BGyWwD-l6rbaO5NEsfYRQQiTele App:https://t.me/iteleofficialGitHub Trending:https://t.me/githubtrendingpython-telegram-bot:https://t.me/pythontelegrambotchannelMarkdownrobot Info:https://t.me/mrkdwnrbt简悦-SimpRead:https://t.me/simpreadMarginNote Channel:https://t.me/MarginNoteVivaldi Browser:https://t.me/vivaldibrowserZ-Turns:https://t.me/Z_TurnsStair Speedtest 更新频道:https://t.me/stairspeedtestThor 过滤器集散中心:https://t.me/f4thorPythonista 3 脚本通知频道:https://t.me/pythonista3jiaobenGoogle Play限免信息:https://t.me/playsalesUpperSoft软件发布: https://t.me/UpperSoft单向历:https://t.me/ows_calendarShortcutsCN 捷径社区:https://t.me/ShortcutsCNXposed框架:https://t.me/XposedCNMagisk-CN:https://t.me/magiskCN软件技术资源共享:https://t.me/SharedResourcesTelePlus - 免翻牆電報:https://t.me/TelePlus_ChannelNotion Twitter Bot:https://t.me/notion_twitter_botTestFlight:https://t.me/TestFlightXTestFlight:https://t.me/testflight_appsTestFlight.Center:https://t.me/TestFlightCenterPan Download官方频道:https://t.me/pandownloadNotion News:https://t.me/NotionNewsUnigram News:https://t.me/unigramUnigram Appx:https://t.me/unigramappxtg生态观察:https://t.me/tgsucksTGgeek TG极客:https://t.me/TGgeekTGgeek 新闻:https://t.me/TGgeekNewsTGgeek TG极客软件站:https://t.me/joinchat/AAAAAEeOCvpM8JSknojYeQ老司机必备工具箱:https://t.me/theguideoftelegram闲置软路由信息发布:https://t.me/supermarket66阿里云频道:https://t.me/supermarket985微软云频道:https://t.me/supermarket211谷歌云(GCP)供需对接市场:https://t.me/supermarket999利器部落 VIP 资源分享:https://t.me/Powerful_ToolsAppStoreCN:https://t.me/AppStore_CNwatchOS 应用推荐:http://t.me/watchOS_cntvOS 应用推荐:http://t.me/tvOS_cnAdGuard:https://t.me/adguardenAdGuard消息:https://t.me/AdGuardcnAdguard News:https://t.me/AdguardNewsOffice Tool Channel:https://t.me/otp_channelOpenWRT编译官方频道:https://t.me/opbypdopenwrt固件收藏:https://t.me/openwrtx86「Meeta」share:https://t.me/meetashareMac 应用推荐:https://t.me/mas_cnApp Store 应用推荐:http://t.me/AppStore_cnApp Store 游戏推荐:http://t.me/AppStore_GamesAescripts Channel:https://t.me/joinchat/AAAAAEysxC5w5mYhEI-1VAPi&amp;N1交流群新频道:https://t.me/NewPiN1ChannelApp 种草:https://t.me/appscaoElpass News:https://t.me/elpassnewsHi DerekCoder:https://t.me/Hi_DerekCoderx86_64软路由passwall固件:https://t.me/passwall笔记软件交流讨论 - 频道:https://t.me/joinchat/AAAAAFPA6feibNtwoeiZcwApp Store、Google Play礼品卡:https://t.me/iTunesGiftNewsZuragram:https://t.me/zuragramVVebo:https://t.me/vvebochannelGBox官方频道:https://t.me/GBoxTGCFastClip:https://t.me/fastclipgroupLifeAnalysis Lab 更新:https://t.me/lalabLifeAnalysis Lab Update:https://t.me/lalabengFastClip快讯:https://t.me/fastclipgroupRSSHub 布告栏:https://t.me/awesomeRSSHubDarker Sky ☔️ for Android:https://t.me/darkerskyandroid番羽土番毒药机场测速 SS/SSR:https://t.me/DuyaoSSV1 Blog 科技 生活 SpeedTest 主机评测:https://t.me/V1_BLOGV1 机场优惠通知:https://t.me/discount_shareBGP测速频道:https://t.me/BGP2020機場海外測速中心:https://t.me/BlacklotusChannel外星人测速频道:https://t.me/waixingrenspeedNet云评测:https://t.me/cloudtest机场测压实验室:https://t.me/cyssr品云☁️测速:https://t.me/Examine_Cloudss，ssr，v2ray机场测速:https://t.me/askahh秋水逸冰的个人频道:https://t.me/qiushuiyibingSurge 开发者的频道:https://t.me/yachmeSurge Official:https://t.me/surgeofficialSurge News:https://t.me/surgenewsSurge去广告:https://t.me/SurgeAdBlockDler Cloud News:https://t.me/dlercloud_newsShadowrocket News:https://t.me/ShadowrocketNewsQuantumult News:https://t.me/QuanXNewsQure for Quantumult X 图标:https://t.me/QureIconSetmini图标包 for Quantumult X:https://t.me/OrzminiQuantumult 的规则频道:https://t.me/useConfigQuantumultX &amp; Surge脚本收集:https://t.me/NobyDaQuantumult X JS 收集分享:https://t.me/QuanXJSQuantumult X 功能教学:https://t.me/HellCellZC123QuantumultX 教程&amp;API&amp;解析器 更新通知频道:https://t.me/QuanX_APINobyDa Script:https://t.me/joinchat/JtzRlVY-WyJPDavvhKjrbwChavy Scripts:https://t.me/chavyscriptsLiangYi🅥重写规则&amp;脚本:https://t.me/liangyiAnzw9314通知频道:https://t.me/nzw9314NewsW37°大飛频道:https://t.me/w37fhyNeteaseUnlock Channel:https://t.me/jiaowoyOKAB3脚本:https://t.me/OKAB3_Script_Channel神机规则:https://t.me/DivineEngine_ProfilesDivineEngine:https://t.me/DivineEngineCool Scripts:https://t.me/cool_scriptsTG规则脚本信息分享器:https://t.me/MRHXPJGGProject V 官方公告:https://t.me/v2msgExCloud News:https://t.me/ExCloudNewsNetch 版本发布频道:https://t.me/NetchXChannelPotatso Channel:https://t.me/potatsoSSR Backup Channel:https://t.me/ssr_backuplhie1/Rules Channel:https://t.me/rulenewsTempest TCN(rixCloud):https://t.me/TempestAppTrojan Qt5 News:https://t.me/TrojanQt5NewsServerCat 主机喵:https://t.me/servercatHyper SSR:https://t.me/hyperssrSurfboard News:https://t.me/surfboardnews逗比根据地 News:https://t.me/doubi_a老王公告区:https://t.me/wangvpn_user魅影极速官方频道:https://t.me/myjstw魅影极速轻量站ARK频道:https://t.me/arktochannel喵帕斯通知频道:https://t.me/joinchat/AAAAAD-w0xtKH55HW8GBCQFndroid的日常(Clash for Windows):https://t.me/fndroid_newsClash for Android Channel:https://t.me/clash_for_android_channelClashR News:https://t.me/ClashR_NewsclashR 公告:https://t.me/clashR_channelClash(R) for Windows 公告板:https://t.me/ClashR_for_Windows_ChannelACL4SSR:https://t.me/ACL4SSRStick Rules:https://t.me/usestick爱兔联盟公告通知:https://t.me/tuClubNews每日免费节点分发:https://t.me/freessrshadowsocks公益组织:https://t.me/ssfree无题（非clowwindy本人）:https://t.me/clowwindyESU.TV:https://t.me/esutvSocks5最新代理发布:https://t.me/socks5listSS节点免费发放:https://t.me/sslistSSR节点免费发放:https://t.me/ssrlistSSR节点国际共享:https://t.me/ShadowsocksRssrV2ray节点免费发放:https://t.me/v2listSSR SHARE 免费SSR:https://t.me/gyjclubGoogle Hosts:https://t.me/googlehostsGoogle Hosts 广播频道:https://t.me/googlehostsnewsGoogle Hosts Official Channel:https://t.me/googlehosts_news机场物价局:https://t.me/JCFBIMTP发布 tg代理:https://t.me/mtppubMTPROTO公益代理发放频道:https://t.me/onessrPharos Announcements:https://t.me/Pharos_x_AnnouncementsSSRPanel:https://t.me/ssrpanelFree Telegram proxy:https://t.me/proxymevAgent官方福利资源发布频道:https://t.me/everythingjustbeginss panel v3 mod 魔改修改版 News:https://t.me/sspanel_Uimss panel v3 mod 非官方水群:https://t.me/SSUnionBosLife:https://t.me/boslifenewsCoel SSR BroadCast:https://t.me/joinchat/AAAAAFiwPBlDTJJ-6xbWSgSTC_API:https://t.me/niconewbeeeapi从纯小白开始的翻墙冒险:https://t.me/chunxiaobaiSubConverter 更新频道:https://t.me/subconverterVPN测评-各类VPN相关资讯+真实测评:https://t.me/VPNceping火箭空间站 (TG代理):https://t.me/Rocketcool杂物:https://t.me/gugugugomielecV2:https://t.me/elecV2x86_64 ssrpOpenWRT软路由固件频道:https://t.me/ssrpOpenWRTXurge:https://t.me/Xurge科学上网与机场观察:https://t.me/jichangtjYtFlow β:https://t.me/YtFlowChannelMerlinClash猫咪爬梯:https://t.me/merlinclashcat媒体Telegram 中文 NEWS:https://t.me/YinxiangBiji_NewsVultr News:https://t.me/vultr_newsTelegram 抽奖活动导航: https://t.me/Lottery_home科技花（TestFlight）:https://t.me/TestFlightCN小道消息:https://t.me/WebNotesBackup小道消息:https://t.me/WebNotes2比特新声:https://t.me/bitvoice海龙说:https://t.me/haotalk不客观 Not Objective:https://t.me/notobjective卖桃者说（池建强）:https://t.me/mactalk澳门政府官方Telegram頻道:https://t.me/leehsienloong《澳門日報》官方Telegram頻道:https://t.me/macaodaily台灣隊長蔡英文:https://t.me/iingtw看鉴中国 OutsightChina:https://t.me/OutsightChina新闻实验室:https://t.me/newslab202060秒读懂世界:https://t.me/SharedResources突发新闻:https://t.me/breakingnews_t南方周末 / Southern Weekly:https://t.me/infzmPixelExperience - News:https://t.me/PixelExperience果核  Apple Nuts:https://t.me/AppleNuts Apple Spyder 果蛛 🕷️:https://t.me/AppleSpyderOnePlus™:https://t.me/OnePlus数码荔枝 lizhi.io:https://t.me/shumalizhi程序员技术资源分享:https://t.me/gotoshare大虾的编程资源库/码农/程序员资源:https://t.me/programmingsrchubMIUI 12 Updates:https://t.me/MIUI11_UpdatesIPN 播客网络:https://t.me/ipnpodcast一分世界:https://t.me/yifenshijie《無次元》博客:https://t.me/wuciyuan一天世界 博客:https://t.me/yitianshijie津津乐道播客:https://t.me/jinjinledao剩余价值:https://t.me/surplusvalueclub电丸科技AK:https://t.me/joinchat/AAAAAEWbURDTisztrTcwqA随机波动 StochasticVolatility:https://t.me/StochasticVolatilityPodcast精选中文播客:https://t.me/chinapodcastkindle电子书读书会:https://t.me/zebookpush『得到』电子书:https://t.me/dedao_eBook读舍 FM:https://t.me/bookcn新蛤社TG膜蛤专栏:https://t.me/XinHaNewsAgency电脑玩物:https://t.me/playpcesor回形针PaperClip&amp;灵光灯泡:https://t.me/papercliphubIngress官方频道:https://t.me/NianticOfficialSteam快讯:https://t.me/steamsteamLibra - Facebook Coin:https://t.me/Libra_infoProgrammer Jokes:https://t.me/programmerjokesBooksThief:https://t.me/BooksThiefCreative Motion:https://t.me/creativemotionGoogle:https://t.me/googleSolidot（奇客的资讯,重要的东西）:https://t.me/solidotReadHub:https://t.me/readhub_cnProduct Hunt Hot:https://t.me/product_hunt_hot少数派:https://t.me/sspaiXDA-Developers Hub:https://t.me/xdadevelopershubXDA-News [Official]:https://t.me/xdanews中国互联网交换中心 China-Internet-Exchange:https://t.me/googlessrrLinux中国:https://t.me/linuxdotcnBIGDONGDONG 频道:https://t.me/bigdongdongchannelGroupHub广播站:https://t.me/GroupHub数字优惠:https://t.me/DigitalSpecialDealsOne Pie:https://t.me/ssp1pTelegram安全使用方案:https://t.me/protecttelegramNyanChan’s Notebook (次糖糖):https://t.me/nyanchansnotebookHitiko’s Channel:https://t.me/HitikoWooMai’s Channel:https://t.me/WooMaiChannelMrKevin博客 资讯 分享 测评:https://t.me/hilinuxcnLeonn的博客:https://t.me/liyuansVPS仓-推荐/补货提醒:https://t.me/vpscangVps推荐:https://t.me/VPSRSSVPS信号旗播报:https://t.me/vps_xhqunwire.hk 生活科技頻道:https://t.me/unwire好奇心日报:https://t.me/qdaily好奇心日报:https://t.me/qdaily001互联网从业者充电站:https://t.me/https1024cnBeta.COM中文业界资讯站(简中):https://t.me/cnbeta_comcnBeta.COM中文業界資訊站(繁中):http://t.me/cnbeta_com_hk中国数字时代消息推送:https://t.me/cdtchinesefeedPSA-安全公告专栏:https://t.me/TGCNPSA网络安全事件SecEvents:https://t.me/SecEvents安全威胁收集和福利:https://t.me/safe2you网络安全技术频道:https://t.me/tg_InternetSecurityAffyun.com - 每日offers优选:https://t.me/affyunpushGoogle Drive 资源:https://t.me/gdurl帮找资源:https://t.me/lovesource书籍共享计划:https://t.me/booksharingplanLicenses Channel:https://t.me/Licensesss[合租通知] Netflix YouTube Spotify office365 Hbo Surge 美剧:https://t.me/hezu2拼车小组:https://t.me/PinCheStationnetflix spotify hulu vpn账号:https://t.me/zxc1017FreeTrial.Store:https://t.me/freetrialsellNew Hollywood English Movies HD:https://t.me/hollywood_new_english_hd_moviesTelegram movies II:https://t.me/TMoviesOfficial2NF^2 经典剧集频道:https://t.me/joinchat/AAAAAE3C8ftAes4Hlwdq1QNF^2 在播剧集频道:https://t.me/joinchat/AAAAAFV5bPMRFezYw2bdTwNF^2 原电影频道:https://t.me/joinchat/AAAAAEkxsGoVvgfKGi_QBANF^2 iOS 电影频道:https://t.me/joinchat/AAAAAFFZ44zzfAGVxxLkGwNF^2 Google Drive 发布频道:https://t.me/joinchat/AAAAAFFQ9jJ_upG0y6xKyg4K影视资源:https://t.me/Remux_2160P4K影视屋-蓝光无损电影:https://t.me/dianying4KDiscuss That!:https://t.me/DiscussThisYouTube-ImShuker文件及公告:https://t.me/shukerxiaoxiReddit 精选:https://t.me/RedditTopMETO 的涂鸦板:https://t.me/metoooooApple Upgrade:https://t.me/AppleUpgradeLinux Update:https://t.me/linuxUpdate跑路快讯:https://t.me/runningfaster电报时报:https://t.me/times001PUSH科技快讯:https://t.me/Pushings逆风社:https://t.me/nifengpress新纪元 新闻中心:https://t.me/xinjiyuan9长安街日报:https://t.me/thecaajournal噫这世界:https://t.me/yizheshijie羊毛收割机 • 好物:https://t.me/ZHwool羊王🐑频道:https://t.me/yangwangpindao吾爱资源 薅羊毛·资讯中心:https://t.me/Pojieapp🎏「 彼岸情报🔎！」🎏薅羊毛情报见闻社:https://t.me/BaccanoSoul好物 • 羊毛信息发布:https://t.me/Yiwushop随手薅毛毛:https://t.me/get_cheap_goods🅻ihaiba资源羊毛分享🍭:https://t.me/lihaiba频道🏆资源福利分享:https://t.me/freemorebest全网福利收集:https://t.me/FuliListGoogle Play限免信息:https://t.me/playsalesDiscovery探索频道:https://t.me/tele_event_share扫地僧笔记:https://t.me/lover_links今日头条:https://t.me/jinritoutiaoScience:https://t.me/scienceUntitled TechTalk:https://t.me/UntitledTechTalk中国地震台网速报:https://t.me/BC_CEIC中国地震速报（≥4.5级）:https://t.me/dizhen公共交通部落:https://t.me/fhs_publictransport_zone地铁服务信息更新:https://t.me/Metro_Service_Update药丸时报:https://t.me/PillNewsGif Center:https://t.me/gifcenterWallpapers:https://t.me/AR72014Wallpapers/Обои:https://t.me/EZwallsWallpapers By Arthwork:https://t.me/arthworkWallPapers:https://t.me/WallpapersForYou_8k壁纸 wallpapers:https://t.me/bizhi123Hk3ToN:https://t.me/Hk3ToWallpaper@Winn 手工壁纸分享:https://t.me/WallpaperWinn最美壁纸©极简派:https://t.me/yidu520Wallpapers:https://t.me/awsiiqiWallpaper PC:https://t.me/iWallpaperPCAE Documents Room:https://t.me/joinchat/AAAAAEI59b4dQOYGvZdZRwTech Guide:https://t.me/TechGuideBoring Class:https://t.me/BoringClassThink Positive Words:https://t.me/thinkpositivewords小牛课堂之股市新手手册:https://t.me/KYWsharetraining燎原:https://t.me/liaoyuan胖客十袋:https://t.me/pankt涂抹:https://t.me/paint_film跑路快讯:https://t.me/runrunkuaixunTechCrunch中文版:https://t.me/techcrunchcn鳥的日用美學:https://t.me/Feuilletons乙烷日报:https://t.me/OverDaily碎琼乱玉 背风而行:https://t.me/ruanyuwwLetITFly News:https://t.me/LetITFlyW猪圈净化快讯:https://t.me/zhujuan2018科技圈广播:https://t.me/InternetNewsCN安全上网,注意事项:https://t.me/anquanshangwang360互联网安全中心:https://t.me/InternetSecurityCenterOf360苹果旧版应用发布频道:https://t.me/guooldHackerNews中文站:https://t.me/China_HackerNews竹新社:https://t.me/tnews365竹新资料库:https://t.me/kt_database海外媒体的中文新闻:https://t.me/chinanews001《維基人》官方推播頻道:https://t.me/the_Wikipedian中文維基新聞廣播頻道:https://t.me/wikinews_zh_broadcastReuters:World:https://t.me/ReutersWorldChannel内涵段子:https://t.me/duanzitg糗事百科:https://t.me/qiushibaike句子迷:https://t.me/kuaikanmanhuaPUSH科学快讯:https://t.me/pushings少数人知道的消息:https://t.me/csrinfo科技圈的日常:https://t.me/misakatech博闻社:https://t.me/bowenpress湾区日报 Official:https://t.me/wanqu_official逗比据地根 (频道):https://t.me/ToyooMessage免費資源網路社群 Free Group:https://t.me/Free_Group好物 · 羊毛收割机:https://t.me/ZH_wool三家村Flow:人文+科技:https://t.me/GoReading菲兹定律:https://t.me/prefocuson网络安全中心:https://t.me/tgdailigg61 的私人无主题分享:https://t.me/thisis61speakingiOS 越狱插件更新信息:https://t.me/Jailbreak_TweaksJailbreak:https://t.me/jailbreakJailbreak Notifications:https://t.me/jailbreaknotificationsCydia Updates:https://t.me/cydiaupdateSpotify News:https://t.me/spotifynews全网福利收集:https://t.me/AlltheChannel无限月读:https://t.me/moecao每日 AWESOME 观察:https://t.me/awesomeopensourceIT 那点事:https://t.me/InternetNewsCN即刻精选:https://t.me/jike_collection996 码农的觉醒:https://t.me/Awakenedeveloper远鉴字幕组发布频道:https://t.me/VisionarySub流浪防区 新闻台:https://t.me/China_irl_NewsDaily News:https://t.me/daily73机场防御测压实验室:https://t.me/ssrcyXDDOS压力测试:https://t.me/xddos2网站防御测试频道:https://t.me/webyc悟空干货集中营:https://t.me/daily5kongLIFETIME视界:https://t.me/lifetimecn电视机顶盒&amp;手机影视APP:https://t.me/tvbox001Cloudflare在中国频道:https://t.me/Cloudflare_CNTikTok:https://t.me/tiktokPT资讯频道:https://t.me/privatetrackernewsIyouport:https://t.me/iyouport主机百科资讯分享:https://t.me/zhujiwiki_infoo1xhack &amp; friends🥤 分享 思考 科技 生活:https://t.me/o1xinsightNewlearnerの自留地:https://t.me/NewlearnerChannelAwesome Collection:https://t.me/awesome_collectionPicacomic News:https://t.me/PicACGApple Tech News:https://t.me/appletechnews码力全开工作室:https://t.me/maliquankai一碗毒鸡汤:https://t.me/ywdjt数字移民:https://t.me/shuziyimin值物志:https://t.me/zhiwuzhi路透中文网:https://t.me/lutouzhongwen_rss纽约时报:https://t.me/niuyueshibao_rss美国之音:https://t.me/meiguozhiyin_rss知乎日报:https://t.me/zhihuribao_rssBBC中文:https://t.me/bbczhongwen_rssFT中文网:https://t.me/ftzhongwen_rss双语新闻:https://t.me/shuangyunews_rss法国 国际广播电台:https://t.me/rfi_rss德国 德国之声:https://t.me/dw_rss澳大利亚 广播公司:https://t.me/abc_rss俄罗斯 卫星通讯社:https://t.me/ru_rss新加坡 联合早报:https://t.me/sg_rss韩国 中央日报:https://t.me/korea_rss日本 日经中文网:https://t.me/jp_rss台湾香港 当地日报:https://t.me/ttww_rss每日早间新闻:https://t.me/zaobaoNews经济信息联播:https://t.me/eco_cnLearn SwiftUI:https://t.me/learnswiftui媒奇葩说:https://t.me/mtalk看理想 vistopia:https://t.me/ikanlixiangStreaming Link Station:https://t.me/streaming_link_station方可成的新闻实验室:https://t.me/newslab2020Wolley News:https://t.me/wolleynewsJustf News:https://t.me/justfNewHacker News:https://t.me/hacker_news_feedNewMobileLife:https://t.me/newmobilelife國家地理雜誌 中文版:https://t.me/natgeomedia你有一个打折需要了解:https://t.me/SteamNy无损音乐:https://t.me/wsmusic0Emby全能服务器体验（嘎鱼饭）:https://t.me/gayufanTrending Stickers:https://t.me/TrendingStickersKAIX.IN:https://t.me/kaix_inTSBBLOG:https://t.me/tsbblog中文播客精选:https://t.me/greatpodcasts每日一歌:https://t.me/dailymusich音乐世界:https://t.me/lumingguandj中文社科讲座资讯:https://t.me/chwebinars【ZERO】安全运营（DevSecOps）:https://t.me/zero_devsecops小报频道:https://t.me/FQnews维生素E:https://t.me/vitamineEpodcast新冠肺炎2019-nCoV疫情实时播报🅥:https://t.me/nCoV2019新型冠状病毒最新疫情推送频道:https://t.me/CoronavirusNews丁香园肺炎疫情播报:https://t.me/ncovPneumonia霍金斯大学nCoV全球实时数据:https://t.me/JHU_nCoV_APIWuhan Quarantine #nCoV #武汉封城:https://t.me/wuhanquarantinefrom202001232019-nCoV实况:https://t.me/CN2019nCoV2019-nCoV疫情相关资讯发布:https://t.me/WuHan2019nCoVFinancial Times: Coronavirus news:https://t.me/financialtimes全平台口罩放货监控:https://t.me/jdkzjk新型冠狀病毒肺炎疫情頻道:https://t.me/NCVMacao疫情趋势图&amp;信息图:https://t.me/nCoV2019GraphCoronavirus Info:https://t.me/corona印度:https://t.me/MyGovCoronaNewsdesk以色列:https://t.me/MOHreport哈萨克斯坦:https://t.me/coronavirus2020_kz马来西亚:https://t.me/cprckkm乌兹别克斯坦:https://t.me/koronavirusinfouz沙特:https://t.me/LiveWellMOH新加坡:https://t.me/govsg西班牙:https://t.me/sanidadgob乌克兰:https://t.me/COVID19_Ukraine俄罗斯:https://t.me/stopcoronavirusrussia香港:https://t.me/HKFIGHTCOVID19德国:https://t.me/corona_infokanal_bmg其他频道/群组/机器人分享:https://t.me/hao123fAnimated Stickers:https://t.me/AnimatedStickersAnimated Emojis:https://t.me/AnimatedEmojis本土創作的貼圖:https://t.me/LocalStickersStickers Channel:https://t.me/stickersChannelACG Stickers:https://t.me/ACGStickersTestFlight News:https://t.me/testflightsEnglish learners:https://t.me/English一加手机/OnePlus频道:https://t.me/onepluscnMy Desctop（Cool 4k, HD wallpapers）:https://t.me/PhoneDesctopBTSynChina中文资源分享:https://t.me/btsynchineseBtsync keys:https://t.me/btsyncGramip Channel:https://t.me/Gramip秘密文摘:https://t.me/secretofbody_degistSync资源更新:https://t.me/shenkey91yun优惠快讯:https://t.me/express91yunzrj766的频道:https://t.me/zrj96雷罗笔记:https://t.me/coolciOuterShare 独乐乐不如众乐乐:https://t.me/outershareVPS.TF 资讯聚合:https://t.me/joinchat/AAAAAFNDKWzkp5wyCL86jwHost Testing and evaluation:https://t.me/HostEvaluateFree網絡信息自由門:https://t.me/todayfreedomEH Forwarder Bot Support:https://t.me/EFBSupport今天份的微软药丸:https://t.me/microshitLWL 的基地台:https://t.me/lwlbaseIngress 中文:https://t.me/IngressChineseIngress Chengdu&amp;Chongqing:https://t.me/IngressChengduChongqingtsear.ch - Telegram SearchEngine:https://t.me/tgchansFindYanot Ch:https://t.me/findyanotch各种奇奇怪怪的优惠和专卖活动:https://t.me/joinchat/AAAAAEDHaeh76nlGWM6zhgDoggyStyle journal of U:https://t.me/djoyou北京空气质量每天推送:https://t.me/BeijingAir豆瓣精选:https://t.me/douban_read文杏馆（藏书分享）:https://t.me/BooksThatMakeYouThink【程序员之家】软件项目百例:https://t.me/useless_project_ideas新闻播报PDF:https://t.me/news_pdf好书分享:https://t.me/haoshufenxiang每周一书:https://t.me/weekly_books机械工业出版社资源:https://t.me/bookusefor1机械工业出版社计算机书籍:https://t.me/bookusefor3中信、清华大学、电子工业书籍资源:https://t.me/bookusefor2编程随想推荐书籍（非官方）:https://t.me/programthinkbook電書攤Ƹ̵̡Ӝ̵̨Ʒ:https://t.me/telebookstall好书分享频道:https://t.me/haoshufenxiang山巅出版社:https://t.me/shandian2084zread (推) - 什么书值得读:https://t.me/zreadpush微信搬运工:https://t.me/WeChatEssence蛋挞报:https://t.me/pincongessence台湾的一个可爱Sticker Channel:https://t.me/sticker_tw发猫频道猫奴必备:https://t.me/miaowu一个小圈子的画猫:https://t.me/miaopang今天 tg 打掉了几个ISIS bot:https://t.me/ISISwatch老毛子Padavan固件发布:https://t.me/pdcn1老毛子Padavan固件纯净交流群:https://t.me/pdcn0eSir Playground固件&amp;插件发布频道:https://t.me/joinchat/AAAAAE-8dVyO8ljrgQ5yCw王者荣耀:https://t.me/joinchat/Ddz9QT36eAcOR-AX7gHZdw图拉鼎的所见、所闻、所想:https://t.me/tualatrix_saysBetter Naming:https://t.me/rebornixscuinfo:https://t.me/scuinfoProducter Cast:https://t.me/producter_castZeroNet Feed:https://t.me/ZeroNet某不科学的DIYgod:https://t.me/awesomeDIYgod美剧资源推送:https://t.me/SSKMJBTSKindle 电子书降价信息:https://t.me/kindlePriceKindle 特价书:https://t.me/KindleBookDealsAmazon 降价信息:https://t.me/amazondropPremium 🇵 🇷 🇴💀:https://t.me/Premiumpro白板（一些有趣的文字、图片、视频）:https://t.me/mastergogogo共青团中央:https://t.me/comyouth嘴炮:https://t.me/zuipaoGMF:https://t.me/theGMFEntdaily:https://t.me/entdailyHacker News:https://t.me/another_hacker_news饭否每日精选:https://t.me/fanfou_daily饭否每周精选:https://t.me/fanfou_weeklyScale system:https://t.me/scalesystemFireball Newsletter:https://t.me/fireballnewsletter一任阶前点滴到天明:https://t.me/hearrain有趣的物有趣的事情:https://t.me/superliClassic Drama &amp; Novel:https://t.me/Drama暗之城 - 科学之城:https://t.me/cityofsciencechannelInbox收集箱:https://t.me/inbox_all冷眼向洋:https://t.me/lengyanxiangyang内涵段子TV:https://t.me/duanzizhijiaDribbble Popular Design 每日流行设计:https://t.me/designtaalkGoogle Voice 靓号:https://t.me/voice_googleApper:https://t.me/iappliance书店官方公告栏:https://t.me/bookshopleaf浮生笔记:https://t.me/fabulousleafAirplanes:https://t.me/Airplanese每日一句:https://t.me/meiriyiju开源游戏服务器框架 skynet 项目:https://t.me/skynetluaJailbreak News:https://t.me/jailbreaknotifications碎嘴老鼠:https://t.me/dms_share看看就好:https://t.me/swiminthedream线路爆炸:https://t.me/boomagain川普推文即时同步:https://t.me/realDonaldTrumpTwitter三仙炒面:https://t.me/sanxian大咕咕咕鸡:https://t.me/tgdaguguguji荔枝木:https://t.me/lycheewoodRuich97 Notice:https://t.me/ruich97_baseRuich97 Notice:https://t.me/gabriel_channelGroupOwnerBots:https://t.me/GroupOwnerBots一休儿的哲学讲座:https://t.me/yixiuer小破不入渠:https://t.me/forwardlikehell吾聊世界:https://t.me/wuliaoworldNetflix高分好剧推介:https://t.me/NetflixFansNetflix 影片介绍:https://t.me/NetflixFirstRARTV:https://t.me/rartv财经快讯:https://t.me/fnnew黑洞资源共享:https://t.me/tieliu翻车频道:https://t.me/banyungong666neoFelhz’s Channel 山雨欲来风满楼:https://t.me/neoFelhzWAlPlank:https://t.me/NaAlOH4_JokesAlPlank Ver Sion:https://t.me/NaAlOH4_Jokes_plusPrivacy Rules:https://t.me/PrivacyRulesNo Bug In:https://t.me/NoBugIn老梦杂货铺:https://t.me/littlesh0pSitandRelax’s ChannelNSFW:https://t.me/SitandRelaxLabs坐和云音乐:https://t.me/SitandMusicSitandRelax’s Channel:https://t.me/SitandRelaxLab红米Note3吐槽频道:https://t.me/RIP_KenzoJerry Zhāng 的频道:https://t.me/JerryZhangSaoDaye - TG频道:https://t.me/infosaodayeEMK Public Channel:https://t.me/JacobEMK摄神取念:https://t.me/LegolimensTG中文资源库共享中心:https://t.me/anruan123Drakeets:https://t.me/drakeetsUpperDoc:https://t.me/UpperDoc诚换通-二手交易频道:https://t.me/chenghuitongpindaoFor Work 系列-梗频道:https://t.me/JISFWFor Work 系列-图频道:https://t.me/GfWR16For Work 系列-读频道:https://t.me/NewsFWFor Work 系列-妹频道:https://t.me/GFW3DSFor Work 系列-NLP频道:https://t.me/NLPfWFor Work 系列-轨道群:https://t.me/RailwayFW@ATGWall ‘s Channel:https://t.me/ATGWall_ChannelSukka’s Notebook:https://t.me/SukkaChannelDavid’s YouTube 频道推荐:https://t.me/davidsyoutubetesla特斯拉/科技NEWS:https://t.me/Tesla_sharesaber的万事屋:https://t.me/sabershome鱼塔嘅台:https://t.me/Trumeet芝士和培根:https://t.me/KnowledgeHan中国辟谣:https://t.me/piyao学习网安知识:https://t.me/cy6ersec搞机日记:https://t.me/gcjiriji烤苹果(专业收集 bug):https://t.me/AppleCookedFoolish TraceWind:https://t.me/FoolishTraceWindtg机器人推荐:https://t.me/tgbotlistNetflix卡片小站频道:https://t.me/Leye169物与民胞:https://t.me/unicorn4kkDLK搞笑趣闻情报站:https://t.me/dlkqingbaozhan蝉鸣:https://t.me/chanming毒奶频道 🅥 limboPro.xyz:https://t.me/limboprossrACG/萌系/二次元资源、福利、资讯发放频道:https://t.me/MoeTheTG🔑win10密匙windows10激活码分享 微软:https://t.me/win10keymaxOurBits RSS频道:https://t.me/OurBits_RSS365知中国:https://t.me/knowchina365影视APP分享频道:https://t.me/ysappZUOLUOTV官方频道:https://t.me/zuoluotvofficial不求甚解:https://t.me/fakeye好书集:https://t.me/haoshuji煎蛋无聊图:https://t.me/jiandan_boreddotplayer订阅列表:https://t.me/dotplayerlists思想:https://t.me/sixiang每日沙雕墙:https://t.me/shadiaooo上班划水之沙雕图:https://t.me/goworkbitch心惊报:https://t.me/xinjingdaily🅢🅗🅐🅡🅔:https://t.me/WeShareSome微博热搜:https://t.me/weibo_hot🌏世界宇:https://t.me/sharedworld土味生活:https://t.me/tuweishenghuo初恋的感觉:https://t.me/chuliandeganjue笑掉大牙:https://t.me/xiaodiaodaya读者书摘:https://t.me/duzheshuzhaiZapro Notice:https://t.me/zaproshareThe Sociologist:https://t.me/thesoc科技无意义:https://t.me/technical_with_love𝐕 𝐀 𝐆 𝐔 𝐄 - 針:https://t.me/oz_senseiSean:https://t.me/SeanChannelVanHelSing Notification:https://t.me/ChujiuggOutvivid:https://t.me/outvividRss™:https://t.me/hubssrLEAPS Hedge:https://t.me/leapstradeReuters: World:https://t.me/ReutersWorldChannelzrj766的频道:https://t.me/zrj96IMG2D:https://t.me/IMG2D家庭网络资源共享频道:https://t.me/homenet9科研萌新的日常生活:https://t.me/records_of_my_daily_lifePT资讯频道:https://t.me/privatetrackernewsRachel 碎碎念:https://t.me/RachelBlahblahRachel 的消息发布站点:https://t.me/RachelNotice京东优惠:https://t.me/jdbuyTelegram China News:https://t.me/tgchinanews📊 Polls Channel:https://t.me/polls_channelGoogoCC:https://t.me/googoccEmperorTian资源推送:https://t.me/iOSAppTS往生路:https://t.me/wangshenglu翼起乐News:https://t.me/YiQiLeNews小艾先生说:https://t.me/xiaoaixianshengshuo福利线报:https://t.me/xiaoaixiansheng_fulixianbao影视资源:https://t.me/xiaoaixiansheng_yingshizhuanqu浅影随想:https://t.me/lightFantasy杂物:https://t.me/zaawuu螺莉莉的黑板报:https://t.me/im_RORIRI锤子🔨丨网球🎾丨圈❎:https://t.me/ThorHCCAPPDO 数字生活指南:https://t.me/appdodoPanoanDrive(离线下载自动转存Google Drive):https://t.me/PanoanChannel资源垃圾佬:https://t.me/allfree123Telegram China News:https://t.me/tgchinanews「每日更新」視頻分享频道:https://t.me/BLADE_CLUB_Media英语外刊推送:https://t.me/ENmagazine_push萦纡 / 潮过广陵半江愁 如何解思念瘦:https://t.me/huangxinn老梁故事汇:https://t.me/Laoliang666科学上网资源整合:https://t.me/ysl_channel自留 𝙘𝙝𝙖𝙣𝙣𝙚𝙡 &gt; 𝙢𝙖𝙞𝙘𝙤𝙤 / 𝙍𝙪𝙡𝙚𝙨:https://t.me/who_channel美剧←→blahblah (&amp; etc.):https://t.me/mytvseries澡堂随笔:https://t.me/showerblah政治哲学片段摘录:https://t.me/poliphy酷喵无损音乐:https://t.me/kugoumusicAll About RSS:https://t.me/aboutrssNS新闻转报:https://t.me/SwitchNewCNrynco libkadence:https://t.me/rynifTingTalk - Channel:https://t.me/tingtalkTelegram (非官方)香港支援頻道:https://t.me/tlgrmHK_chPDF资料:https://t.me/pdf_001我们的歌🎵:https://t.me/DDDDDDziApps推广/抽奖/活动:https://t.me/AppsSweepstakesNews有价值与无价值-科技数码:https://t.me/wuyongzhiyong懂TG - 海外大小事保护隐私自己事:https://t.me/dongTG边走边吃的夏天:https://t.me/deliciousxiamoke 的 日常分享、吐槽和动态:https://t.me/mokeyjay_channel造物指南:https://t.me/create_worlds肆意🅥资源推送:https://t.me/resourcepush_41EXFLUX Netowrks - News:https://t.me/exflux_news台灣蘋果同好群 - 佈告板:https://t.me/TWAppleFansAnnounce微信(Wechat)也要吃藥？:https://t.me/wechatpill麻瓜术士的魔法资产:https://t.me/ArtistModifyAsset今天份的微软药丸:https://t.me/microshit烤苹果:https://t.me/AppleCooked内核怕怕 - 辣鸡 Linux:https://t.me/kernelscared辣鸡咕鸽毁我信仰 #CurryMyLife:https://t.me/googleshitTG…药丸？:https://t.me/tgpill今天三桑爆炸了吗:https://t.me/SamsungBoom索尼大法孬:https://t.me/SonySucks微信(Wechat)也要吃藥？:https://t.me/wechatpill飛雞推特準備起飛了(?:https://t.me/Fly_Chicken_Twitter辣雞Adobe也有頻道:https://t.me/AntiAdobeNVIDIA Fk you:https://t.me/wtfnvidiaDiscord藥丸??:https://t.me/discord_pill路由黑洞:https://t.me/route_blackhole迟早药丸:https://t.me/metapill靠北網商:https://t.me/Anti_ISPJetBreaks 💊:https://t.me/jetbreaks🍝 Spotify 糊了:https://t.me/SpaghettifyCCTV -1001240015334&gt;IC 故事会:https://t.me/EEPill食屎啦 Niantic:https://t.me/shitofnianticArch 滚挂了吗？:https://t.me/btw_use_arch如何与沙雕相处:https://t.me/ruheyushadiaoxiangchu空空如也:https://t.me/MomoKCHMicrosoft-软粉论坛:https://t.me/microwinver免费挂机宝:https://t.me/freemach1ne85.60×53.98卡粉订阅/提醒:https://t.me/DocOfCard小林君家里的托尔:https://t.me/TooruchanNews托尔酱的梗图与FW:https://t.me/TooruChan_MemesCodingStartup 起碼課:https://t.me/codingstartup一些干货:https://t.me/youganhuo豆瓣知乎简书微信公众号:https://t.me/dbzhjs全球主流新闻媒体中文速览:https://t.me/allzhnews验证码平台:https://t.me/Telegram-zh_CN校长读报:https://t.me/XiaoZhangDuBaoMtpHub:https://t.me/mtphubGodly Noob:https://t.me/GodlyNews1每天趣事:https://t.me/Meitian奇趣百科:https://t.me/qiqubaike扣扣空间:https://t.me/qqqzone硬核小卒:https://t.me/yinghexiaozu** ``","link":"/2022/08/07/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%94%B5%E6%8A%A5%20Telegram%20%E7%BE%A4%E7%BB%84%E6%B1%87%E6%80%BB/"},{"title":"系统启动并解析Manifest的流程(转)","text":"最近有同学问我关于Manifest何时被系统解析的问题，正好也分析到这一块了，索性这一章就讲解一下android系统何时解析Manifest吧，这里的Manifest指的是android安装文件apk中的androidManifest.xml文件是何时被解析的。大家应该都知道，Android系统启动之后，我们就可以在一个应用中打开另一个从未打开过的应用，或者是在一个应用中发送广播，如果另外一个应用设置了这个广播的接收器，那么这个应用进程就会被启动并接收该广播并作出相应的处理，这样的例子很多，我们可以猜测到Android系统在启动的时候就会抓取到了系统中所有安装的应用信息（应该是解析apk文件的Manifest信息），即在Android系统的启动过程中就已经解析了系统中安装应用的androidManifest.xml文件并保存起来了，那么这个过程具体是如何的呢? 其实android系统启动过程中解析Manifest的流程是通过PackageManagerService服务来实现的。这里我们重点分析一下PackageManagerService服务是如何解析Manifest的。 首先看一下在SystemServer进程启动过程中是如何启动PackageManagerService服务的： 123456789private void startBootstrapServices() { ... mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); ... } 在SystemServer进程启动过程中会调用SystemServer类的startBootstrapServices方法（主要用于启动ActivityManagerService服务和PackageManagerService服务），然后会在这个方法中会调用PackageManagerService.main静态方法，这个方法主要是用来初始化PackageManagerService服务并执行相关逻辑的。下面我来看一下main方法的具体逻辑： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; } 可以发现main方法的实现逻辑主要是创建了一个PackageManagerService对象，并将这个对象添加到ServierManager中为其他组件提供服务。好吧，看来PackageManagerService的初始化操作主要是在PackageManagerService的构造方法中了，下面我们来看一下其构造方法的实现逻辑： 1234567File dataDir = Environment.getDataDirectory(); mAppDataDir = new File(dataDir, &quot;data&quot;); mAppInstallDir = new File(dataDir, &quot;app&quot;); mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;); mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath(); mUserAppDataDir = new File(dataDir, &quot;user&quot;); mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;); PackageManagerService的构造方法代码量比较大，这里就不贴出所有的代码了，我们主要和解析Manifest相关的主要代码，在构造方法中有这样几段代码。可以发现在构造方法中，解析了系统中几个apk的安装目录，这几个目录就是系统中安装apk的目录，android系统会默认解析这几个目录下apk文件，也就是说如果我们android手机在其他的目录下存在apk文件系统是不会默认解析的，反过来说，如果我们把我们的apk文件移动到这几个目录下，那么重新启动操作系统，该apk文件就会被系统解析并执行相关的逻辑操作，具体做什么操作呢？我们看下面的实现。 123456789101112131415161718192021222324252627282930313233343536/ overlay packages if they reside in VENDOR_OVERLAY_DIR. File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR); scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0); // Find base frameworks (resource packages without code). scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0); // Collected privileged system packages. final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;); scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0); // Collect ordinary system packages. final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all vendor packages. File vendorAppDir = new File(&quot;/vendor/app&quot;); try { vendorAppDir = vendorAppDir.getCanonicalFile(); } catch (IOException e) { // failed to look up canonical path, continue with original one } scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all OEM packages. final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;); scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); 在我们刚刚的PackageManagerService.mani方法中，解析完刚刚的几个系统目录之后系统会调用scanDirLI方法，那么这个方法主要是做什么用的呢？看它的名字应该是遍历这个系统目录。好吧，这个方法主要就是用于解析上面几个目录下的apk文件的。不信？我们看一下scanDirLI方法的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) { final File[] files = dir.listFiles(); if (ArrayUtils.isEmpty(files)) { Log.d(TAG, &quot;No files in app dir &quot; + dir); return; } if (DEBUG_PACKAGE_SCANNING) { Log.d(TAG, &quot;Scanning app dir &quot; + dir + &quot; scanFlags=&quot; + scanFlags + &quot; flags=0x&quot; + Integer.toHexString(parseFlags)); } for (File file : files) { final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) { // Ignore entries which are not packages continue; } try { scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null); } catch (PackageManagerException e) { Slog.w(TAG, &quot;Failed to parse &quot; + file + &quot;: &quot; + e.getMessage()); // Delete invalid userdata apps if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; e.error == PackageManager.INSTALL_FAILED_INVALID_APK) { logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + file); if (file.isDirectory()) { mInstaller.rmPackageDir(file.getAbsolutePath()); } else { file.delete(); } } } } } 可以放下其首先会遍历该目录下的所有文件，并判断是否是apk文件，如果是apk文件则调用scanPackageLI方法，scanPackageLI方法的名字很明显，就是用于解析这个apk文件的。 继续看一下scanPakcageLI方法的实现： 123456789101112131415161718192021private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { if (DEBUG_INSTALL) Slog.d(TAG, &quot;Parsing: &quot; + scanFile); parseFlags |= mDefParseFlags; PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setOnlyCoreApps(mOnlyCore); pp.setDisplayMetrics(mMetrics); if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != 0) { parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY; } final PackageParser.Package pkg; try { pkg = pp.parsePackage(scanFile, parseFlags); } catch (PackageParserException e) { throw PackageManagerException.from(e); } ...} 好吧，这个方法也比较复杂，这里只是列出重点相关的代码，我们可以发现在这个方法中创建了一个PackagerParser对象，并调用了parsePackage方法，这个方法其实就是解析Manifest的主要方法，我们可以看一下其具体的实现： 1234567public Package parsePackage(File packageFile, int flags) throws PackageParserException { if (packageFile.isDirectory()) { return parseClusterPackage(packageFile, flags); } else { return parseMonolithicPackage(packageFile, flags); } } 可以发现，若我们解析的File对象是一个文件夹则执行调用parseClusterPackage方法，否则调用执行parseMonolithicPackage方法，很明显的因为我们这里解析的是apk文件（在上一方法中我们循环遍历得到了apk文件，这里的File对象就代表了一个个的apk文件信息），所以这里会执行parseMonolithicPackage方法，然后我们来看一下parseMonolithicPackage方法： 123456789101112131415161718public Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException { if (mOnlyCoreApps) { final PackageLite lite = parseMonolithicPackageLite(apkFile, flags); if (!lite.coreApp) { throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, &quot;Not a coreApp: &quot; + apkFile); } } final AssetManager assets = new AssetManager(); try { final Package pkg = parseBaseApk(apkFile, assets, flags); pkg.codePath = apkFile.getAbsolutePath(); return pkg; } finally { IoUtils.closeQuietly(assets); } } 可以看出，这里又调用了parseBaseApk方法： 12345private Package parseBaseApk(File apkFile, AssetManager assets, int flags) ... final Package pkg = parseBaseApk(res, parser, flags, outError); ... } 可以看出，这个parseBaseApk方法调用了其重载的parseBaseApk方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;application&quot;)) { if (foundApp) { if (RIGID_PARSER) { outError[0] = &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;); XmlUtils.skipCurrentTag(parser); continue; } } foundApp = true; if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) { return null; } } else if (tagName.equals(&quot;overlay&quot;)) { pkg.mTrustedOverlay = trustedOverlay; sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestResourceOverlay); pkg.mOverlayTarget = sa.getString( com.android.internal.R.styleable.AndroidManifestResourceOverlay_targetPackage); pkg.mOverlayPriority = sa.getInt( com.android.internal.R.styleable.AndroidManifestResourceOverlay_priority, -1); sa.recycle(); if (pkg.mOverlayTarget == null) { outError[0] = &quot;&lt;overlay&gt; does not specify a target package&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } if (pkg.mOverlayPriority &lt; 0 || pkg.mOverlayPriority &gt; 9999) { outError[0] = &quot;&lt;overlay&gt; priority must be between 0 and 9999&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;key-sets&quot;)) { if (!parseKeySets(pkg, res, parser, attrs, outError)) { return null; } } else if (tagName.equals(&quot;permission-group&quot;)) { if (parsePermissionGroup(pkg, flags, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission&quot;)) { if (parsePermission(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission-tree&quot;)) { if (parsePermissionTree(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;uses-permission&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-permission-sdk-m&quot;) || tagName.equals(&quot;uses-permission-sdk-23&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-configuration&quot;)) { ConfigurationInfo cPref = new ConfigurationInfo(); sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesConfiguration); cPref.reqTouchScreen = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen, Configuration.TOUCHSCREEN_UNDEFINED); cPref.reqKeyboardType = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType, Configuration.KEYBOARD_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD; } cPref.reqNavigation = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation, Configuration.NAVIGATION_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV; } sa.recycle(); pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-feature&quot;)) { FeatureInfo fi = parseUsesFeature(res, attrs); pkg.reqFeatures = ArrayUtils.add(pkg.reqFeatures, fi); if (fi.name == null) { ConfigurationInfo cPref = new ConfigurationInfo(); cPref.reqGlEsVersion = fi.reqGlEsVersion; pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;feature-group&quot;)) { FeatureGroupInfo group = new FeatureGroupInfo(); ArrayList&lt;FeatureInfo&gt; features = null; final int innerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } final String innerTagName = parser.getName(); if (innerTagName.equals(&quot;uses-feature&quot;)) { FeatureInfo featureInfo = parseUsesFeature(res, attrs); // FeatureGroups are stricter and mandate that // any &lt;uses-feature&gt; declared are mandatory. featureInfo.flags |= FeatureInfo.FLAG_REQUIRED; features = ArrayUtils.add(features, featureInfo); } else { Slog.w(TAG, &quot;Unknown element under &lt;feature-group&gt;: &quot; + innerTagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); } XmlUtils.skipCurrentTag(parser); } if (features != null) { group.features = new FeatureInfo[features.size()]; group.features = features.toArray(group.features); } pkg.featureGroups = ArrayUtils.add(pkg.featureGroups, group); } else if (tagName.equals(&quot;uses-sdk&quot;)) { if (SDK_VERSION &gt; 0) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesSdk); int minVers = 0; String minCode = null; int targetVers = 0; String targetCode = null; TypedValue val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = minVers = val.data; } } val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = val.data; } } sa.recycle(); if (minCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (minCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } } else if (minVers &gt; SDK_VERSION) { outError[0] = &quot;Requires newer sdk version #&quot; + minVers + &quot; (current version is #&quot; + SDK_VERSION + &quot;)&quot;; mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } if (targetCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (targetCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } // If the code matches, it definitely targets this SDK. pkg.applicationInfo.targetSdkVersion = android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; } else { pkg.applicationInfo.targetSdkVersion = targetVers; } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;supports-screens&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestSupportsScreens); pkg.applicationInfo.requiresSmallestWidthDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_requiresSmallestWidthDp, 0); pkg.applicationInfo.compatibleWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_compatibleWidthLimitDp, 0); pkg.applicationInfo.largestWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largestWidthLimitDp, 0); // This is a trick to get a boolean and still able to detect // if a value was actually set. supportsSmallScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens, supportsSmallScreens); supportsNormalScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens, supportsNormalScreens); supportsLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens, supportsLargeScreens); supportsXLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_xlargeScreens, supportsXLargeScreens); resizeable = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable, resizeable); anyDensity = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity, anyDensity); sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;protected-broadcast&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestProtectedBroadcast); // Note: don't allow this value to be a reference to a resource // that may change. String name = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name); sa.recycle(); if (name != null &amp;&amp; (flags&amp;PARSE_IS_SYSTEM) != 0) { if (pkg.protectedBroadcasts == null) { pkg.protectedBroadcasts = new ArrayList&lt;String&gt;(); } if (!pkg.protectedBroadcasts.contains(name)) { pkg.protectedBroadcasts.add(name.intern()); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;instrumentation&quot;)) { if (parseInstrumentation(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;original-package&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String orig =sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); if (!pkg.packageName.equals(orig)) { if (pkg.mOriginalPackages == null) { pkg.mOriginalPackages = new ArrayList&lt;String&gt;(); pkg.mRealPackage = pkg.packageName; } pkg.mOriginalPackages.add(orig); } sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;adopt-permissions&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String name = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); sa.recycle(); if (name != null) { if (pkg.mAdoptPermissions == null) { pkg.mAdoptPermissions = new ArrayList&lt;String&gt;(); } pkg.mAdoptPermissions.add(name); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-gl-texture&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;compatible-screens&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;supports-input&quot;)) { XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;eat-comment&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (RIGID_PARSER) { outError[0] = &quot;Bad element under &lt;manifest&gt;: &quot; + parser.getName(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;Unknown element under &lt;manifest&gt;: &quot; + parser.getName() + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } } 在这个parseBaseApk方法中有一个while循环，该循环主要就是用于解析AndroidManifest.xml文件中的节点信息。在开始解析application节点的时候，同时调用了parseBaseApplication方法，该方法解析了application节点下的activity，service，broadcast，contentprovier等组件的定义信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;activity&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (tagName.equals(&quot;receiver&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, true, false); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.receivers.add(a); } else if (tagName.equals(&quot;service&quot;)) { Service s = parseService(owner, res, parser, attrs, flags, outError); if (s == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.services.add(s); } else if (tagName.equals(&quot;provider&quot;)) { Provider p = parseProvider(owner, res, parser, attrs, flags, outError); if (p == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.providers.add(p); } else if (tagName.equals(&quot;activity-alias&quot;)) { Activity a = parseActivityAlias(owner, res, parser, attrs, flags, outError); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (parser.getName().equals(&quot;meta-data&quot;)) { // note: application meta-data is stored off to the side, so it can // remain null in the primary copy (we like to avoid extra copies because // it can be large) if ((owner.mAppMetaData = parseMetaData(res, parser, attrs, owner.mAppMetaData, outError)) == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } else if (tagName.equals(&quot;library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestLibrary_name); sa.recycle(); if (lname != null) { lname = lname.intern(); if (!ArrayUtils.contains(owner.libraryNames, lname)) { owner.libraryNames = ArrayUtils.add(owner.libraryNames, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestUsesLibrary_name); boolean req = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesLibrary_required, true); sa.recycle(); if (lname != null) { lname = lname.intern(); if (req) { owner.usesLibraries = ArrayUtils.add(owner.usesLibraries, lname); } else { owner.usesOptionalLibraries = ArrayUtils.add( owner.usesOptionalLibraries, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-package&quot;)) { // Dependencies for app installers; we don't currently try to // enforce this. XmlUtils.skipCurrentTag(parser); } else { if (!RIGID_PARSER) { Slog.w(TAG, &quot;Unknown element under &lt;application&gt;: &quot; + tagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } else { outError[0] = &quot;Bad element under &lt;application&gt;: &quot; + tagName; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } } 这样，经过这里循环遍历，整个androidManifest的节点信息就被解析并保存在了Package对象中。可以看到我们平时在Manifest中定义的各种节点，其实都是在这里有所体现。当androidManifest.xml文件被解析完成之后会调用我们刚刚介绍的scanPackageLI的重载方法，将解析完成的Package对象信息保存的Setting对象中，这个对象用于保存app的安装信息，具体实现是在方法： 12private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException 当解析完成manifest文件之后会调用其重载方法： 123// Note that we invoke the following method only if we are about to unpack an application PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user); 这样，解析的manifest文件信息就会被保存到Settings中，并持久化，然后执行安装apk的操作，我们可以看一下该重载方法的具体实现： 1234567891011121314private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { boolean success = false; try { final PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags, currentTime, user); success = true; return res; } finally { if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) { removeDataDirsLI(pkg.volumeUuid, pkg.packageName); } } } 可以发现其内部调用了scanPackageDirtyLI方法，这个方法就是实际实现持久化manifest信息并安装APK操作的： 12345678private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { ... // And now re-install the app. ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo); ...} 可以发现其内部调用了createDataDirLI，该方法主要实现安装apk的操作。 1234567891011121314151617private int createDataDirsLI(String volumeUuid, String packageName, int uid, String seinfo) { int[] users = sUserManager.getUserIds(); int res = mInstaller.install(volumeUuid, packageName, uid, uid, seinfo); if (res &lt; 0) { return res; } for (int user : users) { if (user != 0) { res = mInstaller.createUserData(volumeUuid, packageName, UserHandle.getUid(user, uid), user, seinfo); if (res &lt; 0) { return res; } } } return res; } 查看该方法的实现： 1234567891011121314public int install(String uuid, String name, int uid, int gid, String seinfo) { StringBuilder builder = new StringBuilder(&quot;install&quot;); builder.append(' '); builder.append(escapeNull(uuid)); builder.append(' '); builder.append(name); builder.append(' '); builder.append(uid); builder.append(' '); builder.append(gid); builder.append(' '); builder.append(seinfo != null ? seinfo : &quot;!&quot;); return mInstaller.execute(builder.toString()); } 怎么样？很熟悉吧，这里的Installer其实调用的就是我们平时运行android项目很熟悉的install命令，原来android系统安装apk文件底层都是调用的adb命令。 总结： android系统启动之后会解析固定目录下的apk文件，并执行解析，持久化apk信息，重新安装等操作； 解析Manifest流程：Zygote进程 –&gt; SystemServer进程 –&gt; PackgeManagerService服务 –&gt; scanDirLI方法 –&gt; scanPackageLI方法 –&gt; PackageParser.parserPackage方法； 解析完成Manifest之后会将apk的Manifest信息保存在Settings对象中并持久化，然后执行重新安装的操作； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程","link":"/2022/08/06/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/"},{"title":"Android 基础知识总结","text":"前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起返回按键的时候默认都是销毁当前Activity。而本文中我们主要介绍触摸事件的分发流程，从Native层到Activity层触摸事件的分发了流程和按键的分发事件都是类似的，这里我们可以根据异常堆栈信息看一下。 123456789101112131415161718192021at com.example.aaron.helloworld.MainActivity.dispatchTouchEvent(MainActivity.java:103)at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2359)at android.view.View.dispatchPointerEvent(View.java:8698)at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4530)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4388)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4053)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4110)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6345)at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6301)at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6254)at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6507)at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185) 这样经过一系列的方法调用之后最终调用了Activity的dispatchTouchEvent方法，而我们也是从Activiyt的dispatchTouchEvent方法开始对触摸事件的分发进行分析。 在具体查看Activity的dispatchTouchEvent方法之前我们先简单介绍一下触摸事件，触摸事件是由一个触摸按下事件、N个触摸滑动事件和一个触摸抬起事件组成的，通常的一个触摸事件中只能存在一个触摸按下和一个触摸抬起事件，但是触摸滑动事件可以有零个或者多个。好了，知道这个概念以后，下面我们就具体看一下Activity中的dispatchTouchEvent的实现逻辑。 123456789public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 在看一下dispatchTouchEvent方法之前我们首先需要解释一下MotionEvent的概念。MotionEvent是一个触摸动作的封装，里面包含了触摸动作的类型，以及操作等属性，我们具体的可以看一下MotionEvent的说明： Object used to report movement (mouse, pen, finger, trackball) events. Motion events may hold either absolute or relative movements and other data, depending on the type of device. 然后在dispatchTouchEvent方法中，会首先判断MotionEvent的动作类型，也就是我们的触目动作的类型，判断其是否是“按下”操作，若是的湖泽，则执行onUserInteraction方法，这个方法又是实现了什么逻辑呢？ 12public void onUserInteraction() { } 可以发现其在Activity中只是一个简单的空实现方法，同样的我们可以看一下该方法的介绍： Called whenever a key, touch, or trackball event is dispatched to the activity. Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and {@link #onUserLeaveHint} are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication. 理解上就是用户在触屏点击，按home，back，menu键都会触发此方法。 回到Activity的dispatchTouchEvent方法中，我们调用了getWindow().suerDispatchTouchEvent()方法，我们分析过Activity的加载绘制流程，而这里的getWindow()就是返回Activity中的mWindow对象，而我们知道Activity中的mWindow对象就是一个PhoneWindow的实例。并且这里的window.superDispatchTouchEvent若返回值为ture，则直接返回true，否则的话会执行Activity的onTouchEvent方法，继续我们看一下PhoneWindow的superDispatchTouchEvent方法。 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } 可以看到在PhoneWindow中的superDispatchTouchEvent方法中调用的是mDecor.superDispatchTouchEvent方法，而这里的mDecor是我们Activity显示的ViewTree的根View，并且mDecor是一个FrameLayout的子类，所以这里我们看一下mDecor的superDispatchTouchEvent方法。 1234567private final class DecorView extends FrameLayout implements RootViewSurfaceTaker { ... public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } ...} 在DecorView的superDispatchTouchEvent方法中我们调用了super.dispatchTouchEvent方法，而我们的DecorView继承于FrameLayout，但是经过查看之后我们知道FrameLayout中并没有实现dispatchTouchEvent方法，而由于我们的FrameLayout继承于ViewGroup，所以这里的dispatchTouchEvent方法应该就是ViewGroup的dispatchTouchEvent方法。 好了，这里先暂时说一下Acitivty中的事件分发流程 ViewRootImpl层的事件分发会首先调用Activity的dispatchTouchEvent方法； Activity的dispatchTouchEvent方法中会通过Window.superDispatchTouchEvent方法将事件传递给DecorView即ViewGroup。 若window的superDispatchTouchEvent方法返回true，则事件分发完成，Activity的dispatchTouchEvent直接返回为true，否则的话调用Activity的onTouchEvent方法，并且Acitivty的dispatchTouchEvent返回值与Activity的onTouchEvent返回值一致。 下面我们在继续看一下ViewGroup的dispatchTouchEvent方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 前面我们知道触摸事件是由一个触摸按下事件，一个触摸抬起事件和N个触摸滑动事件组成的，而这里的触摸按下事件就是这里的ACTION_DOWN，同时友谊ACTION_DOWN是一系列事件的开端，所以我们在ACTION_DOWN时进行一些初始化操作，从上面源码中注释也可以看出来，清除以往的Touch状态然后开始新的手势。并在在cancelAndClearTouchTargets(ev)方法中将mFirstTouchTarget设置为了null，接着在resetTouchState()方法中重置Touch状态标识。 然后标记ViewGroup是否拦截Touch事件的传递，if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)这一条判断语句说明当事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立，否则if不成立，然后将intercepted设置为true，也即拦截事件。这里说明一下ViewGroup中的onInterceptTouchEvent方法是ViewGroup中特有的方法用于表示是否拦截触摸事件，返回为true的话则表示拦截事件，事件不在向子View中分发，若范围为false的话，则表示不拦截事件，继续分发事件。 123public boolean onInterceptTouchEvent(MotionEvent ev) { return false; } 一般的我们可以在自定义的ViewGroup中重写该方法，用于拦截事件的分发。而当我们在父ViewGroup重写该方法返回为true执行事件拦截的逻辑的时候，可以在子View中通过调用requestDisallowInterceptTouchEvent方法，重新设置父ViewGroup的onInterceptTouchEvent方法为false，不拦截对事件的分发逻辑。 123456789101112131415161718public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We're already in this state, assume our ancestors are too return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } } 比如常见的向我们的ViewPager中由于需要处理左右滑动事件从而在其onInterceptTouchEvent方法中重写了返回值，返回为true，拦截对事件的处理逻辑，但是若这时候ViewPager中嵌套了ListView，则listView也需要处理触摸事件的逻辑，但是ViewPager中已经重写了onInterceptTouchEvent方法，这时候怎么办呢？幸运的是ListView也在内部的实现中调用了requestDisallowInterceptTouchEvent方法，保证自身获得对触摸事件的处理。 然后在代码中我们判断childrenCount个数是否不为0，继续我们获取子View的list集合preorderedList；最后通过一个for循环倒序遍历所有的子view，这是因为preorderedList中的顺序是按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会因为Android的UI后刷新机制显示在上层；假如点击的地方有两个子View都包含的点击的坐标，那么后被添加到布局中的那个子view会先响应事件；也就是说后被添加的子view会浮在上层，点击的时候最上层的那个组件先去响应事件。 然后代码通过调用getTouchTarget去查找当前子View是否在mFirstTouchTarget.next这条target链中的某一个targe中，如果在则返回这个target，否则返回null。在这段代码的if判断通过说明找到了接收Touch事件的子View，即newTouchTarget，那么，既然已经找到了，所以执行break跳出for循环。如果没有break则继续向下执行，这里你可以看见一段if判断的代码if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))，那么这个方法又是执行什么逻辑的呢？ 在该方法中为一个递归调用，会递归调用dispatchTouchEvent()方法。在dispatchTouchEvent()中如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()，如果子View为View那么就会调用其onTouchEvent()。dispatchTransformedTouchEvent方法如果返回true则表示子View消费掉该事件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don't need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; } 然后在在ViewGroup的dispatchTransformedTouchEvent方法中，调用了该ViewGroup的child View的dispatchTouchEvent方法，若其子View也是ViewGroup，则重复执行ViewGroup的dispatchTouchEvent方法，若其子View是View，则执行View的dispatchTouchEvent方法。 但这里大概分析了一下ViewGroup的事件分发流程 首先在android的事件分发流程中，通过调用Activity的dispatchTouchEvent，事件会首先被派发是先传递到最顶级的DecorView也就是ViewGroup，再由ViewGroup递归传递到View的。 在ViewGroup中可以通过设置onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。 下面我们继续看一下View的dispatchTouchEvent方法。 12345678910111213141516171819public boolean dispatchTouchEvent(MotionEvent event) { ... if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } ... return result; } View的dispatchTouchEvent方法的内容比较长，我们重点看一下View对触摸事件的处理逻辑，首先调用了onFilterTouchEventForSecurity(event)方法判断当前的View是否被遮盖，若没有的话，则判断View的mListenerInfo城边变量是否为空，而这里的mListenerInfo又是什么呢？通过分析源码我们知道这里的mListenerInfo是通过setOnClickListener方法设置的。 123456public void setOnClickListener(@Nullable OnClickListener l) { if (!isClickable()) { setClickable(true); } getListenerInfo().mOnClickListener = l; } 可以当前View一旦执行了setOnClickListener方法改View的mListenerInfo就不为空，若后有判断了该View是否可点击，最后是判断View的onTouchListener的onTouch方法的返回值。 所以当我们为当前View设置了OnTouchListener并且返回值为true的话，则直接执行其onTouch方法，若onTouch方法返回为true的话，则直接返回不在执行后续的View的onTouchEvent方法，否则继续执行View的onTouchEvent方法，而我们继续看一下View的onTouchEvent方法的实现逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); } } break; } return true; } return false; } 在ACTION为MotionEvent.ACTION_UP时，我们经过层层调用最终执行了performClick，方法而这个方法中我们回调了View的OnClickListener的onClick方法。。。 1234567891011121314public boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; } 所以View组件分发触摸事件的时候： View控件会首先执行dispatchTouchEvent方法。 View控件在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法。 View的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调运onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。 View控件不是enable的，那么即使设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。 如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。 参考：http://blog.csdn.net/xiaanming/article/details/21696315http://blog.csdn.net/guolin_blog/article/details/9097463http://blog.csdn.net/guolin_blog/article/details/9153747 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程android源码解析（二十九）–&gt;应用程序返回按键执行流程","link":"/2022/08/06/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"title":"oppo的面试题","text":"collection和collections的区别map遍历过程中删除数据会发生什么如何解决1，Android为什么使用Dalvik 不用JVM Dalvik和ART的演变2.双重锁单例 volitile关键字，sync锁3.binder通信流程，跨进成通信方式，binder的大小4.代理模式的实现5.热修复原理 （双亲委托）。 oppo的面试题1.tcp怎么保证数据传输的可靠性2.多进程的好处和缺点3.Service和Thread的区别4.Socket有什么优化点5.偏向锁的实现原理6.CAS的实现原理7.设计模式的设计原则8.jvm的多线程机制9.rsa加密原理10.hashmap和treemap有什么区别 HashMap：基于哈希表实现 .优化HashMap空间的使用，可以调优初始容量和负载因子。适用于在Map中插入、删除和定位元素。 TreeMap：基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。适用于按自然顺序或自定义顺序遍历键(key)。 1.为什么ThreadLocalMap使用弱引用存储ThreadLocal？ 假如使用强引用，当ThreadLocal不再使用需要回收时，发现某个线程中ThreadLocalMap存在该ThreadLocal的强引用，无法回收，造成内存泄漏。 因此，使用弱引用可以防止长期存在的线程（通常使用了线程池）导致ThreadLocal无法回收造成内存泄漏。 2.那通常说的ThreadLocal内存泄漏是如何引起的呢？ 我们注意到Entry对象中，虽然Key(ThreadLocal)是通过弱引用引入的，但是value即变量值本身是通过强引用引入。 这就导致，假如不作任何处理，由于ThreadLocalMap和线程的生命周期是一致的，当线程资源长期不释放，即使ThreadLocal本身由于弱引用机制已经回收掉了，但value还是驻留在线程的ThreadLocalMap的Entry中。即存在key为null，但value却有值的无效Entry。导致内存泄漏。 ANR导致原因？ cpu过载导致，全量logcat日志里会有相关的打印，各个进程cpu占用情况，这种一般不需要分析trace文件 频繁gc导致，全量日志anr之前会有频繁的gc打印，trace文件头部也会统计gc单次耗时，总次数和总耗时主线程也会进入wait状态，之后就是一系列的gc相关的线程 wait 死锁，这种我遇到的很少，就讲了下一般会打印资源is heldby xxx进程会形成互相持有的状态 Handler在源码中的使用场景你能举一两个例子吗 1.ANR的消息都是通过handler发送给AMS里的ServerThread来处理的2.长按事件的触发，在PhoneWindowManager里边， 也是handler发送的延时消息3.HandlerThread 继承thread run方法中Looper.prepare(); Looper.loop();调用quit或quitSafely停掉。 java方面 集合List,Map,Setarraylist linklist的区别MAP的原理Set原理android方面就是activity生命周期，启动方式的区别 service启动方式IPC的原理 Binder原理事件传递机制自定义VIEW的三个复写方法的作用android源码的了解程度 讲解HashMap的原理？HashMap的扩容过程，以及为什么扩容时必须是2的幂次方？HasmMap与ArrayMap有什么区别？数组和链表的区别？系统讲解一下Android端涉及到的性能优化？以及项目中有做过哪些性能优化？UI优化、内存优化、帧率及卡顿优化、APP启动优化等如何监控卡顿与帧率？讲解Handler消息机制讲解ViewGroup事件传递机制？讲解View的绘制流程APP的启动流程，从点击图标到应用启动都经历了哪些过程？Apk打包流程？JVM内存模型Java垃圾回收机制Java ClassLoader双亲委派机制？Java Volatile底层实现原理？如何构建线程池?newFixedThreadPool与newCachedThreadPool的区别？多线程中的死锁？AsyncTask内部维护了一个线程池是串行还是并行的？如何维护的？OSI网络模型与TCP/IP网络模型TCP和UDP的区别开发过程中遵循哪些设计原则？开发过程中都用过哪些设计模式，为了解决什么问题？做过哪些项目重构？重构的原因是什么，最后实现了怎样的效果？MVC/MVP/MVVM架构模式？策略模式与状态模式有什么不同？分别为了解决什么问题？ Serializable和Parcelable哪个性能高，为什么？Parcelable性能高Serializable IO流完成的。Parcelable C++对象指针 共享内存指针挪动保存数据。 内部类使用外部的变量 为什么要加final？内部类的生命周期长于方法。 方法弹栈就没了，但是匿名内部类还是活着的，这样在内部类修改局部变量时候，局部变量就不存在了 view的渲染机制，事件传递，卡顿检测的原理，常用的优化方法 字节面试题一个面试题，先从A界面跳转到B界面，当从B界面返回A界面时，什么情况，B界面的onStop和onDestroy不会回调 算法题 1.链表是否相交，找出相交节点 2.链表是否有环 ondraw里面打印log会打印几次，怎么让他随着屏幕刷新频率打印 插件化需要解决哪些问题，插件app怎么引用宿主资源 glide第一次加载一张网络图片的过程 怎么监测卡顿 leakcanary的原理 hashmap的内存结构和查找过程 什么时候Activity单独走onPause()不走onStop()?如果要调用onPause(),Activity必须leavesforeground，也就是离开前台或者离开栈顶，那么除非start一个设置为android:theme=”Theme.Dialog”的Activity，当前Activity才会直走onPause(). 什么时候Activity不执行onDestroy()?栈里面的第一个没有销毁的ativity会执行ondestroy方法，其他的不会执行。从mainActivity跳转到activityA，这时候，后台枪杀，只会执行mainActivity的onDestroy方法，activityA的onDestroy方法不会执行。 Jvm是基于栈，davik是基于寄存器的 SYN–SYN ACK-ACKSYN=1 seq=client_isnSYN=1 seq=server_isn ack=client_isn+1SYN=0 seq=client_isn+1 ack=server_isn+1seq 为自身序列ack 为对方序列+1 复制代码FIN–ACK–FIN-ACK【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？答：因为当Server 端收到Client 端的SYN 连接请求报文后，可以直接发送SYN+ACK 报文。其中ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当Server 端收到FIN 报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK 报文，告诉Client 端，”你发的FIN 报文我收到了”。只有等到我Server 端所有的报文都发送完了，我才能发送FIN 报文，因此不能一起发送。故需要四步握手。【问题2】为什么TIME_WAIT 状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE 状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK 丢失。所以TIME_WAIT 状态就是用来重发可能丢失的ACK 报文。","link":"/2022/08/10/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","link":"/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","link":"/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"基数排序","slug":"基数排序","link":"/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"AVL","slug":"AVL","link":"/tags/AVL/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"激活码","slug":"激活码","link":"/tags/%E6%BF%80%E6%B4%BB%E7%A0%81/"},{"name":"IntellJ","slug":"IntellJ","link":"/tags/IntellJ/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"ActivityManagerNative","slug":"ActivityManagerNative","link":"/tags/ActivityManagerNative/"},{"name":"Zygote","slug":"Zygote","link":"/tags/Zygote/"},{"name":"SystemServer","slug":"SystemServer","link":"/tags/SystemServer/"},{"name":"布局加载","slug":"布局加载","link":"/tags/%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"异常","slug":"异常","link":"/tags/%E5%BC%82%E5%B8%B8/"},{"name":"蓝牙开发","slug":"蓝牙开发","link":"/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"安装流程","slug":"安装流程","link":"/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"},{"name":"Dialog","slug":"Dialog","link":"/tags/Dialog/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Build","slug":"Build","link":"/tags/Build/"},{"name":"CoordinatorLayout","slug":"CoordinatorLayout","link":"/tags/CoordinatorLayout/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"分支","slug":"分支","link":"/tags/%E5%88%86%E6%94%AF/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"GC算法","slug":"GC算法","link":"/tags/GC%E7%AE%97%E6%B3%95/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"Launcher","slug":"Launcher","link":"/tags/Launcher/"},{"name":"MACOS","slug":"MACOS","link":"/tags/MACOS/"},{"name":"AndroidStudio","slug":"AndroidStudio","link":"/tags/AndroidStudio/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Charles","slug":"Charles","link":"/tags/Charles/"},{"name":"Mac应用","slug":"Mac应用","link":"/tags/Mac%E5%BA%94%E7%94%A8/"},{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"壁纸路径","slug":"壁纸路径","link":"/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"name":"Mac系统","slug":"Mac系统","link":"/tags/Mac%E7%B3%BB%E7%BB%9F/"},{"name":"MacOS快捷键","slug":"MacOS快捷键","link":"/tags/MacOS%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"谷歌云","slug":"谷歌云","link":"/tags/%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","link":"/tags/oh-my-zsh/"},{"name":"PopupWindow","slug":"PopupWindow","link":"/tags/PopupWindow/"},{"name":"init进程","slug":"init进程","link":"/tags/init%E8%BF%9B%E7%A8%8B/"},{"name":"so文件","slug":"so文件","link":"/tags/so%E6%96%87%E4%BB%B6/"},{"name":"ndk","slug":"ndk","link":"/tags/ndk/"},{"name":"ss","slug":"ss","link":"/tags/ss/"},{"name":"翻墙","slug":"翻墙","link":"/tags/%E7%BF%BB%E5%A2%99/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"串口通讯","slug":"串口通讯","link":"/tags/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"},{"name":"Serialport","slug":"Serialport","link":"/tags/Serialport/"},{"name":"霍比特人","slug":"霍比特人","link":"/tags/%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA/"},{"name":"意外之旅","slug":"意外之旅","link":"/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"},{"name":"bt","slug":"bt","link":"/tags/bt/"},{"name":"指环王","slug":"指环王","link":"/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"},{"name":"比尔博·巴金斯","slug":"比尔博·巴金斯","link":"/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"},{"name":"甘道夫","slug":"甘道夫","link":"/tags/%E7%94%98%E9%81%93%E5%A4%AB/"},{"name":"索伦","slug":"索伦","link":"/tags/%E7%B4%A2%E4%BC%A6/"},{"name":"魔苟斯","slug":"魔苟斯","link":"/tags/%E9%AD%94%E8%8B%9F%E6%96%AF/"},{"name":"戒灵","slug":"戒灵","link":"/tags/%E6%88%92%E7%81%B5/"},{"name":"炎魔","slug":"炎魔","link":"/tags/%E7%82%8E%E9%AD%94/"},{"name":"精灵","slug":"精灵","link":"/tags/%E7%B2%BE%E7%81%B5/"},{"name":"魔戒","slug":"魔戒","link":"/tags/%E9%AD%94%E6%88%92/"},{"name":"咕噜","slug":"咕噜","link":"/tags/%E5%92%95%E5%99%9C/"},{"name":"阿拉贡","slug":"阿拉贡","link":"/tags/%E9%98%BF%E6%8B%89%E8%B4%A1/"},{"name":"魔多","slug":"魔多","link":"/tags/%E9%AD%94%E5%A4%9A/"},{"name":"史茅革","slug":"史茅革","link":"/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"},{"name":"HandlerThread","slug":"HandlerThread","link":"/tags/HandlerThread/"},{"name":"AsyncTask","slug":"AsyncTask","link":"/tags/AsyncTask/"},{"name":"IntentService","slug":"IntentService","link":"/tags/IntentService/"},{"name":"logcat","slug":"logcat","link":"/tags/logcat/"},{"name":"LruCache","slug":"LruCache","link":"/tags/LruCache/"},{"name":"异步消息","slug":"异步消息","link":"/tags/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"构建流程","slug":"构建流程","link":"/tags/%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"name":"brew","slug":"brew","link":"/tags/brew/"},{"name":"PackageManagerService","slug":"PackageManagerService","link":"/tags/PackageManagerService/"},{"name":"onLowMemory","slug":"onLowMemory","link":"/tags/onLowMemory/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","link":"/tags/ActivityManagerService/"},{"name":"onSaveInstanceState","slug":"onSaveInstanceState","link":"/tags/onSaveInstanceState/"},{"name":"Windows 10","slug":"Windows-10","link":"/tags/Windows-10/"},{"name":"激活秘钥","slug":"激活秘钥","link":"/tags/%E6%BF%80%E6%B4%BB%E7%A7%98%E9%92%A5/"},{"name":"近代史","slug":"近代史","link":"/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"},{"name":"中国历史","slug":"中国历史","link":"/tags/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2/"},{"name":"自考","slug":"自考","link":"/tags/%E8%87%AA%E8%80%83/"},{"name":"短路与","slug":"短路与","link":"/tags/%E7%9F%AD%E8%B7%AF%E4%B8%8E/"},{"name":"或","slug":"或","link":"/tags/%E6%88%96/"},{"name":"与","slug":"与","link":"/tags/%E4%B8%8E/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"短路或","slug":"短路或","link":"/tags/%E7%9F%AD%E8%B7%AF%E6%88%96/"},{"name":"VPN","slug":"VPN","link":"/tags/VPN/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Tomact","slug":"Tomact","link":"/tags/Tomact/"},{"name":"Python3","slug":"Python3","link":"/tags/Python3/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"小游戏开发","slug":"小游戏开发","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"后台服务","slug":"后台服务","link":"/tags/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"},{"name":"adb","slug":"adb","link":"/tags/adb/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"启动流程","slug":"启动流程","link":"/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"name":"截屏","slug":"截屏","link":"/tags/%E6%88%AA%E5%B1%8F/"},{"name":"clash","slug":"clash","link":"/tags/clash/"},{"name":"托管配置","slug":"托管配置","link":"/tags/%E6%89%98%E7%AE%A1%E9%85%8D%E7%BD%AE/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"搬瓦工","slug":"搬瓦工","link":"/tags/%E6%90%AC%E7%93%A6%E5%B7%A5/"},{"name":"WordPress","slug":"WordPress","link":"/tags/WordPress/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"建站","slug":"建站","link":"/tags/%E5%BB%BA%E7%AB%99/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"数学公式","slug":"数学公式","link":"/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"name":"jvm内存划分","slug":"jvm内存划分","link":"/tags/jvm%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"},{"name":"垃圾回收","slug":"垃圾回收","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"组件化","slug":"组件化","link":"/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"热修复","slug":"热修复","link":"/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"Arouter","slug":"Arouter","link":"/tags/Arouter/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"底层","slug":"底层","link":"/tags/%E5%BA%95%E5%B1%82/"},{"name":"HOME按键","slug":"HOME按键","link":"/tags/HOME%E6%8C%89%E9%94%AE/"},{"name":"anr","slug":"anr","link":"/tags/anr/"},{"name":"DexClassLoader","slug":"DexClassLoader","link":"/tags/DexClassLoader/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"网络基础","slug":"网络基础","link":"/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"Telegram","slug":"Telegram","link":"/tags/Telegram/"},{"name":"Manifest","slug":"Manifest","link":"/tags/Manifest/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"ThreadLocalMap","slug":"ThreadLocalMap","link":"/tags/ThreadLocalMap/"},{"name":"CAS","slug":"CAS","link":"/tags/CAS/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"}],"categories":[{"name":"结构算法","slug":"结构算法","link":"/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"应用软件","slug":"应用软件","link":"/categories/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/"},{"name":"Android基础","slug":"Android基础","link":"/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"知识积累","slug":"知识积累","link":"/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"},{"name":"面试宝典","slug":"面试宝典","link":"/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"name":"科学上网","slug":"科学上网","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"经典电影","slug":"经典电影","link":"/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"},{"name":"自考资料","slug":"自考资料","link":"/categories/%E8%87%AA%E8%80%83%E8%B5%84%E6%96%99/"}]}
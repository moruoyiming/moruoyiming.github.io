<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: Android - 简则易从的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="简则易从的博客"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="简则易从的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="移动开发技术分享博客"><meta property="og:type" content="blog"><meta property="og:title" content="简则易从"><meta property="og:url" content="https://moruoyiming.github.io/"><meta property="og:site_name" content="简则易从"><meta property="og:description" content="移动开发技术分享博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moruoyiming.github.io/img/favicon.jpg"><meta property="article:author" content="Jian"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/favicon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"简则易从的博客","image":["http://yoursite.com/img/og_image.png"],"author":{"@type":"Person","name":"Brigitte Jian"},"description":"移动开发技术分享博客"}</script><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8241795889030186" crossOrigin="anonymous"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/media">电影</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Android</a></li></ul></nav></div></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/11/%E6%9F%A5%E7%9C%8B%20Android%20%E6%89%8B%E6%9C%BA%E7%9A%84%20CPU%20%E6%9E%B6%E6%9E%84/"><img class="fill" src="/gallery/thumbnails/sculpture.jpg" alt="查看 Android 手机的 CPU 架构"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-11  <a class="commentCountImg" href="/2022/08/11/%E6%9F%A5%E7%9C%8B%20Android%20%E6%89%8B%E6%9C%BA%E7%9A%84%20CPU%20%E6%9E%B6%E6%9E%84/#comment-container"><span class="display-none-class">23a2d0749085ed21c065e742b0ee931a</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="23a2d0749085ed21c065e742b0ee931a">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 分钟  <i class="fas fa-pencil-alt"> </i>0.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/11/%E6%9F%A5%E7%9C%8B%20Android%20%E6%89%8B%E6%9C%BA%E7%9A%84%20CPU%20%E6%9E%B6%E6%9E%84/">查看 Android 手机的 CPU 架构</a></h1><div class="content"><p>查看 Android 手机的 CPU 架构<br>Win + R 然后输入 cmd<br>执行：</p>
<ol>
<li>adb shell</li>
<li>cat &#x2F;proc&#x2F;cpuinfo</li>
</ol>
<p>PD1938:&#x2F; $ cat &#x2F;proc&#x2F;cpuinfo<br>processor	: 0<br>BogoMIPS	: 52.00<br>Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm lrcpc dcpop asimddp<br>CPU implementer	: 0x41<br>CPU architecture: 8   (7 表示arm-v7，8表示arm-v8)<br>CPU variant	: 0x1<br>CPU part	: 0xd05<br>CPU revision	: 0</p>
<p>processor	: 1<br>BogoMIPS	: 52.00<br>Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm lrcpc dcpop asimddp<br>CPU implementer	: 0x41<br>CPU architecture: 8<br>CPU variant	: 0x1<br>CPU part	: 0xd05<br>CPU revision	: 0</p>
<p>processor	: 2<br>BogoMIPS	: 52.00<br>Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm lrcpc dcpop asimddp<br>CPU implementer	: 0x41<br>CPU architecture: 8<br>CPU variant	: 0x1<br>CPU part	: 0xd05<br>CPU revision	: 0</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/ADB/">ADB</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/">命令行</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/shell/">shell</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/cpu%E6%9E%B6%E6%9E%84/">cpu架构</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/11/%E6%9F%A5%E7%9C%8B%20Android%20%E6%89%8B%E6%9C%BA%E7%9A%84%20CPU%20%E6%9E%B6%E6%9E%84/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-11T12:20:49.343Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-11</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/11/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/"><img class="fill" src="/gallery/thumbnails/sculpture.jpg" alt="Android 事件分发流程"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-11  <a class="commentCountImg" href="/2022/08/11/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">eb41bdf29d04bb536e082289c94dd626</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="eb41bdf29d04bb536e082289c94dd626">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>34 分钟  <i class="fas fa-pencil-alt"> </i>5.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/11/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/">Android 事件分发流程</a></h1><div class="content"><p>前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起返回按键的时候默认都是销毁当前Activity。而本文中我们主要介绍触摸事件的分发流程，从Native层到Activity层触摸事件的分发了流程和按键的分发事件都是类似的，这里我们可以根据异常堆栈信息看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">at com.example.aaron.helloworld.MainActivity.dispatchTouchEvent(MainActivity.java:103)</span><br><span class="line">at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2359)</span><br><span class="line">at android.view.View.dispatchPointerEvent(View.java:8698)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4530)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4388)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4053)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4110)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6345)</span><br><span class="line">at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6301)</span><br><span class="line">at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6254)</span><br><span class="line">at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6507)</span><br><span class="line">at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)</span><br></pre></td></tr></table></figure>
<p>这样经过一系列的方法调用之后最终调用了Activity的dispatchTouchEvent方法，而我们也是从Activiyt的dispatchTouchEvent方法开始对触摸事件的分发进行分析。</p>
<p>在具体查看Activity的dispatchTouchEvent方法之前我们先简单介绍一下触摸事件，触摸事件是由一个触摸按下事件、N个触摸滑动事件和一个触摸抬起事件组成的，通常的一个触摸事件中只能存在一个触摸按下和一个触摸抬起事件，但是触摸滑动事件可以有零个或者多个。好了，知道这个概念以后，下面我们就具体看一下Activity中的dispatchTouchEvent的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">事件分发</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/DocorView/">DocorView</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/dispatchTouchEvent/">dispatchTouchEvent</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/onInterceptTouchEvent/">onInterceptTouchEvent</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/11/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-11T12:00:54.805Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-11</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/"><img class="fill" src="/gallery/thumbnails/plant.jpg" alt="Android 基础知识总结"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-11  <a class="commentCountImg" href="/2022/08/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/#comment-container"><span class="display-none-class">b02f806e335755d050f19d76b2157f81</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b02f806e335755d050f19d76b2157f81">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>16 分钟  <i class="fas fa-pencil-alt"> </i>2.4 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/">Android 基础知识总结</a></h1><div class="content"><p><strong>Activity生命周期</strong>        </p>
<p><a target="_blank" rel="noopener" href="http://www.coderror.com/wp-content/uploads/2019/11/%E5%9B%BE%E7%89%87-1.png">img</a></p>
<p><strong>Fragment生命周期</strong></p>
<p><img src="http://www.coderror.com/wp-content/uploads/2019/11/%E5%9B%BE%E7%89%87-2.png" alt="img"></p>
<p><strong>Activity****四种启动模式</strong></p>
<ul>
<li><p><strong>standard :</strong> <strong>标准模式</strong>,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(<em>onCreate()-&gt;onStart()-&gt;onResume()</em>)都会执行。</p>
</li>
<li><p><strong>singleTop</strong> <strong>:</strong> <strong>栈顶复用模式</strong>.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用与<em>standard**模式</em>一样.</p>
</li>
<li><p><strong>singleTask:</strong> <strong>栈内复用模式</strong>.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.(clear top)</p>
</li>
<li><p><strong>singleInstance</strong> : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/">蓝牙开发</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-11T12:00:54.895Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-11</time></div></div></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/"><img class="fill" src="/gallery/thumbnails/plant.jpg" alt="Anroid开发艺术探究"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/#comment-container"><span class="display-none-class">210a42db6c618854d687f80f2855d9ab</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="210a42db6c618854d687f80f2855d9ab">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>15.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/">Anroid开发艺术探究</a></h1><div class="content"><p>1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？<br>  onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别</p>
<p>2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B 的onResume()和 A 的onPaus()哪个先执行呢？<br>  启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内的Activvity的状态，AMS通过<br>  ActivityThread去同步Activity的状态从而完成生命周期方法的调用。在ActivityStack中的resumeTopActivityInnerLocked方法中，在新Acctivity启动之前，<br>  栈顶的Activity需要先onPause()后，新Activity才能启动。最终在ActivityStackSupervisor中的realStartActivityLocked方法会调用scheduleLaunchActivity，<br>  接着完成新Activity的onCreate、onStart、onResume的调用过程。因此，可以得到结论，是旧Activity先onPause，然后新Activity再启动。</p>
<p>3.Activity被销毁并重建后，我们去获取之前的存储字符串，接受的位置可以是onRestoreInstanceState 或者 onCreate 方法，两者区别是？<br>  onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的拍断是否为空；<br>  但是onCreate不行，onCreate如果正常启动的话，其参数Bundle savedInstanceState为null, 所以必须要额外判断。</p>
<p>4.onSaveInstanceState和onRestoreInstanceState，在正常流程下会出发么？<br>  系统只在Activity异常种植的时候才会调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，其他情况不会出发这个过程。</p>
<p>5.比如目前任务栈S1中的情况为ABC，这个时候Activity D 以singleTask模式请求启动，其所需要的任务栈为 S2，由于S2和D的实例均不存在，所以系统会先创建<br>  任务栈S2，然后在创建D的实例并将其入栈到S2.</p>
<p>6.TaskAffinity任务相关性。<br>  这个参数标识一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。可以为每个Activity都单独制定TaskAffinity属性，<br>  这个属性必须不能和包名相同，否则就相当于没有制定。TaskAffinity属性主要和singleTask启动模式或者allTaskReparenting属性配对使用。当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity回运行在名字和TaskAffinity相同的任务栈中。<br>  当TaskAffinity和allowTaskReparenting结合的时候，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allTaskReparenting属性为true的话，那么当应用B被启动后，词Activity回直接从应用A的任务栈转移到应用B的任务栈中。</p>
<p>7.SharedPerences是否安全？<br>  SharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，因为SharedPreferences底层是通过读&#x2F;写XML文件来实现的，并发会出问题。<br>  每个应用的SharedPreferences文件都在当前包所在的data目录下查看到，目录位于 &#x2F;data&#x2F;data&#x2F;pacakage name&#x2F;shared_prefs目录下。<br>  SharedPreferences也属于文件的一种，但是由于系统对他的读&#x2F;写有一定的缓存策略，即在内存中有一份ShareePreferences文件的缓存，因此在多进程下，系统对它的读写诗不可靠的，当面对高并发的读&#x2F;写访问，有很大几率丢失文件。</p>
<p>8.Serializable接口的原理及serialVersionUID作用？<br>  想让一个对象实现序列化，只需要这个类实现Serializable接口并声明一个serialVersionUID即可。实际上，甚至连这个serialVersionUID也不是必须的。如何进行对象的序列化和反序列化也很简单，只需要采用ObjectOutputStream和ObjectInputStream，readObject()writeObject()函数。<br>  serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的数据中的serialVersionUID只有和当前累的serialVersionUID相同时才能够正常的被反序列化。<br>  serialVersionUID的详细工作机制时这样的：序列化的时候系统把当前类的serialVersionUID写入序列化文件中，当反序列化时候系统回去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本时相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候时无法正常反序列化的。</p>
<p>9.Parcelable接口原理？<br>  Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并通过Intent和Binder传递。<br>  Parcel内部包装了可序列化的数据，可以在Binder中自由传输。<br>  序列化的功能由writeToParcel方法来完成，最终时通过Parcel的一系列write方法来完成的；<br>  反序列化功能由CREATOR来完成，其内部表明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化过程。</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/ActivityManagerNative/">ActivityManagerNative</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/Zygote/">Zygote</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/SystemServer/">SystemServer</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-09T13:02:14.651Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-09</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"><img class="fill" src="/gallery/thumbnails/desert.jpg" alt="应用程序返回按键执行流程"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">a769695a81dbb1cbc81c3a7361faaf00</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="a769695a81dbb1cbc81c3a7361faaf00">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>20 分钟  <i class="fas fa-pencil-alt"> </i>3.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">应用程序返回按键执行流程</a></h1><div class="content"><p>从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。<br>android系统的事件分发流程分为很多部分：</p>
<ul>
<li>Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层</li>
</ul>
<p>所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。</p>
<p><strong>在Native层android系统的事件流程：</strong></p>
<ul>
<li><p>Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。</p>
</li>
<li><p>在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。</p>
</li>
<li><p>将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。</p>
</li>
<li><p>Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。</p>
</li>
<li><p>Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。</p>
</li>
</ul>
<p>可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。</p>
<p><strong>在ViewRootImpl层android系统的事件流程</strong></p>
<p>在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">        onInputEventFinished(seq, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中：</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/Zygote/">Zygote</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/SystemServer/">SystemServer</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/gradle/">gradle</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/Launcher/">Launcher</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-07T08:36:34.666Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-07</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"><img class="fill" src="/gallery/thumbnails/image1.jpg" alt="电源开关机按键事件流程"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">b5a9cea73bdbfdcbd59859d8b5abadaf</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b5a9cea73bdbfdcbd59859d8b5abadaf">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>29 分钟  <i class="fas fa-pencil-alt"> </i>4.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">电源开关机按键事件流程</a></h1><div class="content"><p>前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。</p>
<p>和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。</p>
<p>下面首先看一下dispatchUnhandledKey方法的实现逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent = null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm = event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode = event.getKeyCode();</span><br><span class="line">            final int metaState = event.getMetaState();</span><br><span class="line">            final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() == 0;</span><br><span class="line"></span><br><span class="line">            // Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction = kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction = mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction != null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent = KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过前面两篇文章的分析<br>（<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51474288"> android源码解析（二十六）–&gt;截屏事件流程</a>&amp;nbsp;&amp;nbsp;<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51475929">android源码解析（二十七）–&gt;HOME事件流程</a>）<br>我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">启动流程</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/HOME%E6%8C%89%E9%94%AE/">HOME按键</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-07T08:30:39.332Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-07</time></div></div></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"><img class="fill" src="/gallery/thumbnails/image1.jpg" alt="截屏事件流程"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">3078cb85df240220e316c35a972f5b12</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="3078cb85df240220e316c35a972f5b12">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>26 分钟  <i class="fas fa-pencil-alt"> </i>3.9 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">截屏事件流程</a></h1><div class="content"><p>今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。</p>
<p>我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。</p>
<p>在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/** &#123;@inheritDoc&#125; */</span><br><span class="line">    @Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent = null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm = event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode = event.getKeyCode();</span><br><span class="line">            final int metaState = event.getMetaState();</span><br><span class="line">            final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() == 0;</span><br><span class="line"></span><br><span class="line">            // Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction = kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction = mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent = KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">启动流程</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E6%88%AA%E5%B1%8F/">截屏</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-07T08:38:08.858Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-07</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"><img class="fill" src="/gallery/thumbnails/desert.jpg" alt="onLowMemory执行流程"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">f221a452938842ae0618814e7b6066c9</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f221a452938842ae0618814e7b6066c9">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>19 分钟  <i class="fas fa-pencil-alt"> </i>2.8 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">onLowMemory执行流程</a></h1><div class="content"><p>上篇文章中我们分析了Activity的onSaveInstanceState方法执行时机，知道了Activity在一般情况下，若只是执行onPause方法则不会执行onSaveInstanceState方法，而一旦执行了onStop方法就会执行onSaveInstanceState方法，具体的信息，可以参见onSaveInstanceState方法执行时机：<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51464535">android源码解析（二十四）–&gt;onSaveInstanceState执行时机</a> 这篇文章中同样的我们分析一下Actvity（当然不只是Activity，同样包含Servier，ContentProvider，Application等）的另一个内部方法：onLowMemory。该方法主要用于当前系统可用内存比较低的时候回调使用。</p>
<p>这里简单介绍一下Android系统的内存分配机制。Android系统中一个个的App都是一个个不同的应用进程，拥有各自的JVM与运行时，每个App的进程可使用的内存大小都是固定的，当系统中App打开数量过多时，就会使Android系统的可用内存降低，对于当前正在使用的App而言，可能还需要继续申请系统内存，而我们的剩余系统内存已经不足以被当前App所申请了，这时候系统会自动的清理那些后台进程，进而释放出可用内存用于前台进程的使用，当然这里系统清理后台进程的算法不是我们讨论的重点。这里我们只是大概的分析Android系统回调Activity的onLowMemory方法的流程。</p>
<p>通过前面关于Activity的启动流程分析我们知道ActivityManagerService是整个Android系统的管理中枢，负责Activity，Servier等四大组件的启动与销毁等工作，同样的对于应用进程的管理工作也是在ActivityMaangerServier中完成的，我们知道android系统中有两个比较重要的进程Zygote进程和SystemServer进程，其中Zygote进程是整个Android系统的根进程，其他所有的进程都是通过Zygote进程fork出来的。而SystemServer进程则用于运行各种服务，为其他的应用进程提供各种功能接口等，在前面我们分析过SystemServer进程的启动流程（参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51105171"> android源码解析之（九）–&gt;SystemServer进程启动流程</a>）其中在SystemServer的startBootService方法中我们调用了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Set up the Application instance for the system process and get started.</span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br></pre></td></tr></table></figure>
<p>方法，看其注释说明，说的是为System进程初始化Application实例，这里我们可以看一下该方法的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void setSystemProcess() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);</span><br><span class="line">            ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">            ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this));</span><br><span class="line">            ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));</span><br><span class="line">            ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));</span><br><span class="line">            if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">                ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this));</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));</span><br><span class="line">            ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));</span><br><span class="line"></span><br><span class="line">            ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                    &quot;android&quot;, STOCK_PM_FLAGS);</span><br><span class="line">            mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);</span><br><span class="line">                app.persistent = true;</span><br><span class="line">                app.pid = MY_PID;</span><br><span class="line">                app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">                app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">                synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                    mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">                &#125;</span><br><span class="line">                updateLruProcessLocked(app, false, null);</span><br><span class="line">                updateOomAdjLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find android system package&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里简单介绍一下ServierManager是一个管理服务的服务，而其addServier方法就是注册各种服务（服务注册到JNI层，具体的关于是如何注册到JNI层的这里暂不做过多的解释）。可以发现在方法体中我们注册了名称为：memInfo的服务MemBinder，MemBinder是一个Binder类型的服务，主要用于检测系统内存情况，这里可以看一下其具体的实现逻辑：</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/Zygote/">Zygote</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/gradle/">gradle</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/onLowMemory/">onLowMemory</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/ActivityManagerService/">ActivityManagerService</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-07T08:36:34.571Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-07</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"><img class="fill" src="/gallery/thumbnails/desert.jpg" alt="onSaveInstanceState执行时机"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/#comment-container"><span class="display-none-class">aa3d78ac9abc741c5c4ffc1b2690f5bf</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="aa3d78ac9abc741c5c4ffc1b2690f5bf">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>14 分钟  <i class="fas fa-pencil-alt"> </i>2.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/">onSaveInstanceState执行时机</a></h1><div class="content"><p>我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。<br>可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍：</p>
<blockquote>
<p>This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state.  For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}.</p>
</blockquote>
<p>可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。</p>
<p>通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。</p>
<p>Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考:<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51224992"> android源码解析之（十四）–&gt;Activity启动流程</a>，文章中有对Activity生命周期的详细讲解。</p>
<p>好吧，先具体看一下ActivityThread.handlePauseActivity的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            // Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        return r != null ? performPauseActivity(r, finished, saveState) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法：</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/Zygote/">Zygote</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/gradle/">gradle</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/init%E8%BF%9B%E7%A8%8B/">init进程</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/onSaveInstanceState/">onSaveInstanceState</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-07T08:36:34.644Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-07</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"><img class="fill" src="/gallery/thumbnails/plant.jpg" alt="Android异常处理流程"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">d4f0bdf0d2c031187c91523945de9f00</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d4f0bdf0d2c031187c91523945de9f00">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>25 分钟  <i class="fas fa-pencil-alt"> </i>3.7 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">Android异常处理流程</a></h1><div class="content"><p>前面的几篇文章都是讲解的android中的窗口显示机制，包括Activity窗口加载绘制流程，Dialog窗口加载绘制流程，PopupWindow窗口加载绘制流程，Toast窗口加载绘制流程等等。整个Android的界面显示的原理都是类似的，都是通过Window对象控制View组件，实现加载与绘制流程。</p>
<p>这篇文章休息一下，不在讲解Android的窗口绘制机制，穿插的讲解一下Android系统的异常处理流程。O(∩_∩)O哈哈~</p>
<p>开发过android项目的童鞋对android系统中错误弹窗，force close应该不陌生了，当我们的App异常崩溃时，就会弹出一个force close的弹窗，告诉我们App崩溃，以及一下简易的错误信息：<br><img src="http://img.blog.csdn.net/20160512110851449" alt="这里写图片描述"></p>
<p>那么这里的force close弹窗是如何弹出的呢？</p>
<p>还有我们在开发App的过程中，经常会自定义Application，自定义UncaughtExceptionHandler实现App的全局异常处理，那么这里的UncaughtExceptionHandler是如何实现对异常的全局处理的呢？（可参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/41725069"> 在Android中自定义捕获Application全局异常</a>）</p>
<p>带着这两个问题，我们开始今天的异常流程分析。</p>
<p>在android应用进程的启动流程中我们在经过一系列的操作之后会调用RuntimeInit.zygoteInit方法（可参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/6747696">Android应用程序进程启动过程的源代码分析</a>）</p>
<p>而我们也是从这里开始分析我们的Android系统异常处理流程，好了，让我们先来看一下zygoteInit方法的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</span><br><span class="line">        redirectLogStreams();</span><br><span class="line"></span><br><span class="line">        commonInit();</span><br><span class="line">        nativeZygoteInit();</span><br><span class="line">        applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中我们调用了commonInit方法，这个方法是用于初始化操作的，继续看一下commonInit方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final void commonInit() &#123;</span><br><span class="line">        ...</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这里我们调用了Thread.setDefaultUncaughtExceptionHandler方法，这样当我们的进程出现异常的时候，异常信息就会被我们新创建的UncaughtHandler所捕获。</p>
<p>看过我们前面写过的关于Android全局异常处理文章的童鞋应该知道，我们实现对Android异常全局处理的操作也是通过设置Thread.setDefaultUncaughtExceptionHandler来实现的，具体可参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/41725069"> 在Android中自定义捕获Application全局异常</a><br>所以Android系统默认的异常信息都会被这里的UncaughtHandler所捕获并被其uncaughtException方法回调，所以若我们不重写Thread.setDefaultUncaughtExceptionHandler方法，那么这里的UncaughtHandler就是我们默认的异常处理操作 这样我们看一下UncaughtHandler的具体实现：</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/Exception/">Exception</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%BC%82%E5%B8%B8/">异常</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-09T13:02:14.598Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-09</time></div></div></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/Android/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/Android/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/Android/">1</a></li><li><a class="pagination-link" href="/tags/Android/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/tags/Android/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/favicon.jpg" alt="简则易从"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">简则易从</p><p class="is-size-6 is-block">书山有路勤为径，学海无涯苦作舟</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">90</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">159</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/moruoyiming" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Youtube" href="https://www.youtube.com/channel/UCemLDs1nqPnjHN04JCNtmbg"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/accounts/login/?next=/jianzeyicong/"><i class="fab fa-instagram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="500px" href="https://500px.com/p/moruoyiming123?view=photos"><i class="fab fa-500px"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://zhs.center/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">狗急跳墙</span></span><span class="level-right"><span class="level-item tag">zhs.center</span></span></a></li><li><a class="level is-mobile" href="https://www.androiddevtools.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓工具</span></span><span class="level-right"><span class="level-item tag">www.androiddevtools.cn</span></span></a></li><li><a class="level is-mobile" href="http://androidxref.com/6.0.0_r1/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓源码</span></span><span class="level-right"><span class="level-item tag">androidxref.com</span></span></a></li><li><a class="level is-mobile" href="http://idea.lanyus.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">IDEA破解</span></span><span class="level-right"><span class="level-item tag">idea.lanyus.com</span></span></a></li><li><a class="level is-mobile" href="https://www.atool99.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线接口</span></span><span class="level-right"><span class="level-item tag">www.atool99.com</span></span></a></li><li><a class="level is-mobile" href="http://www.bejson.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线解析</span></span><span class="level-right"><span class="level-item tag">www.bejson.com</span></span></a></li><li><a class="level is-mobile" href="https://tinypng.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">图片压缩</span></span><span class="level-right"><span class="level-item tag">tinypng.com</span></span></a></li><li><a class="level is-mobile" href="https://wallpapershome.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">高清壁纸</span></span><span class="level-right"><span class="level-item tag">wallpapershome.com</span></span></a></li><li><a class="level is-mobile" href="https://www.nunuyy2.org/dianying/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线电影</span></span><span class="level-right"><span class="level-item tag">www.nunuyy2.org</span></span></a></li><li><a class="level is-mobile" href="https://www.4ksj.com/forum-2-1.html" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">4K电影</span></span><span class="level-right"><span class="level-item tag">www.4ksj.com</span></span></a></li><li><a class="level is-mobile" href="https://cli.im/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">草料二维码</span></span><span class="level-right"><span class="level-item tag">cli.im</span></span></a></li><li><a class="level is-mobile" href="https://www.waitsun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MAC应用</span></span><span class="level-right"><span class="level-item tag">www.waitsun.com</span></span></a></li><li><a class="level is-mobile" href="https://file.wikileaks.org/file/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">暗网</span></span><span class="level-right"><span class="level-item tag">file.wikileaks.org</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/08/11/%E6%9F%A5%E7%9C%8B%20Android%20%E6%89%8B%E6%9C%BA%E7%9A%84%20CPU%20%E6%9E%B6%E6%9E%84/"><img src="/gallery/thumbnails/sculpture.jpg" alt="查看 Android 手机的 CPU 架构"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-11T12:00:53.672Z">2022-08-11</time></p><p class="title"><a href="/2022/08/11/%E6%9F%A5%E7%9C%8B%20Android%20%E6%89%8B%E6%9C%BA%E7%9A%84%20CPU%20%E6%9E%B6%E6%9E%84/">查看 Android 手机的 CPU 架构</a></p><p class="categories"><a href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/08/11/%E6%98%93%E8%BD%A6%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%A2%98/"><img src="/gallery/thumbnails/plant.jpg" alt="易车一面面试题"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-11T12:00:53.669Z">2022-08-11</time></p><p class="title"><a href="/2022/08/11/%E6%98%93%E8%BD%A6%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%A2%98/">易车一面面试题</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><img src="/gallery/thumbnails/desert.jpg" alt="数据结构基础知识"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-11T12:00:53.665Z">2022-08-11</time></p><p class="title"><a href="/2022/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">数据结构基础知识</a></p><p class="categories"><a href="/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">结构算法</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/08/11/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83%E9%A2%98/"><img src="/gallery/thumbnails/sculpture.jpg" alt="算法思考题"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-11T12:00:53.661Z">2022-08-11</time></p><p class="title"><a href="/2022/08/11/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83%E9%A2%98/">算法思考题</a></p><p class="categories"><a href="/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">结构算法</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/08/11/oppo%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%A2%98/"><img src="/gallery/thumbnails/image1.jpg" alt="oppo的面试题"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-11T12:00:53.658Z">2022-08-11</time></p><p class="title"><a href="/2022/08/11/oppo%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%A2%98/">oppo的面试题</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Android基础</span></span><span class="level-end"><span class="level-item tag">42</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/"><span class="level-start"><span class="level-item">应用软件</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"><span class="level-start"><span class="level-item">知识积累</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"><span class="level-start"><span class="level-item">科学上网</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"><span class="level-start"><span class="level-item">经典电影</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">结构算法</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%87%AA%E8%80%83%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">自考资料</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"><span class="level-start"><span class="level-item">面试宝典</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">90</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">41</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zygote/"><span class="tag">Zygote</span><span class="tag is-grey-lightest">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gradle/"><span class="tag">gradle</span><span class="tag is-grey-lightest">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SystemServer/"><span class="tag">SystemServer</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"><span class="tag">冒泡排序</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ActivityManagerNative/"><span class="tag">ActivityManagerNative</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mac%E7%B3%BB%E7%BB%9F/"><span class="tag">Mac系统</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bt/"><span class="tag">bt</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"><span class="tag">史茅革</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%92%95%E5%99%9C/"><span class="tag">咕噜</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"><span class="tag">壁纸路径</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"><span class="tag">意外之旅</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%92%E7%81%B5/"><span class="tag">戒灵</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"><span class="tag">指环王</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"><span class="tag">比尔博·巴金斯</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%82%8E%E9%AD%94/"><span class="tag">炎魔</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%98%E9%81%93%E5%A4%AB/"><span class="tag">甘道夫</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E7%81%B5/"><span class="tag">精灵</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B4%A2%E4%BC%A6/"><span class="tag">索伦</span><span class="tag is-grey-lightest">6</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a><p class="size-small"><span>&copy; 2022 Brigitte Jian</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备681653568号-8</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2016/06/18 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a38ab32555c76be3797','7cb234d7b83231df989dd8eac82fadef6d150a7f','moruoyiming','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a38ab32555c76be3797','7cb234d7b83231df989dd8eac82fadef6d150a7f','moruoyiming','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>
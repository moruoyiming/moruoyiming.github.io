<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>简则易从的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="简则易从的博客"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="简则易从的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="移动开发技术分享博客"><meta property="og:type" content="blog"><meta property="og:title" content="简则易从"><meta property="og:url" content="https://moruoyiming.github.io/"><meta property="og:site_name" content="简则易从"><meta property="og:description" content="移动开发技术分享博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moruoyiming.github.io/img/favicon.jpg"><meta property="article:author" content="Jian"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/favicon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"简则易从的博客","image":["http://yoursite.com/img/og_image.png"],"author":{"@type":"Person","name":"Brigitte Jian"},"description":"移动开发技术分享博客"}</script><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/media">电影</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/mac%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%87%BA%E7%8E%B0brew%20command%20not%20found%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"><img class="fill" src="/gallery/thumbnails/desert.jpg" alt="mac环境下，出现brew command not found错误的解决方法"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/mac%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%87%BA%E7%8E%B0brew%20command%20not%20found%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/#comment-container"><span class="display-none-class">5ae6614da2460fb848c35b58004e95af</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="5ae6614da2460fb848c35b58004e95af">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>几秒  <i class="fas fa-pencil-alt"> </i>0.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/mac%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%87%BA%E7%8E%B0brew%20command%20not%20found%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">mac环境下，出现brew command not found错误的解决方法</a></h1><div class="content"><p>mac 终端下，执行以下命令，即可安装brew：</p>
<p>&#x2F;usr&#x2F;bin&#x2F;ruby -e “$(curl -fsSL <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p>
<p>在终端环境下，brew –version 查看brew的版本，也可以验证brew是否安装成功</p>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/MAC%E5%BA%94%E7%94%A8/">MAC应用</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%88%86%E6%94%AF/">分支</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/brew/">brew</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><img class="fill" src="/gallery/thumbnails/plant.jpg" alt="git常用命令"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#comment-container"><span class="display-none-class">7b403bc253bd62f11f716712733cb7d7</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="7b403bc253bd62f11f716712733cb7d7">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>4 分钟  <i class="fas fa-pencil-alt"> </i>0.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">git常用命令</a></h1><div class="content"><p>一、常用命令</p>
<p>切换到master分支：git checkout master</p>
<p>查看已有本地及远程分支：git branch -a（先git pull拉下全部数据）</p>
<p>查看远程分支：git branch -r</p>
<p>查看所有分支：git branch -a</p>
<p>查看本地分支：git branch</p>
<p>删除远程dev分支：git push origin –delete dev</p>
<p>删除本地dev分支：git branch -d dev</p>
<p>从远程的origin仓库的master分支下载到本地，并新建一个test分支：git fetch origin master:test</p>
<p>本地从当前所在分支上创建一个新分支： git checkout -b 新分支名</p>
<p>查看test分支与本地原有分支的不同：git diff test</p>
<p>将test分支和当前分支合并：git merge test</p>
<p>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）：git checkout -b 本地分支 origin&#x2F;远程分支，或者 git pull origin dev(remote):dev(local)</p>
<p>将本地master分支提交到远程dev分支：git push origin master:dev</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/git/">git</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/git/">git</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%88%86%E6%94%AF/">分支</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-06T14:36:30.668Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-06</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/"><img class="fill" src="/gallery/thumbnails/plant.jpg" alt="Anroid开发艺术探究"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/#comment-container"><span class="display-none-class">210a42db6c618854d687f80f2855d9ab</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="210a42db6c618854d687f80f2855d9ab">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>15.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/Anroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/">Anroid开发艺术探究</a></h1><div class="content"><p>1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？<br>  onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别</p>
<p>2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B 的onResume()和 A 的onPaus()哪个先执行呢？<br>  启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内的Activvity的状态，AMS通过<br>  ActivityThread去同步Activity的状态从而完成生命周期方法的调用。在ActivityStack中的resumeTopActivityInnerLocked方法中，在新Acctivity启动之前，<br>  栈顶的Activity需要先onPause()后，新Activity才能启动。最终在ActivityStackSupervisor中的realStartActivityLocked方法会调用scheduleLaunchActivity，<br>  接着完成新Activity的onCreate、onStart、onResume的调用过程。因此，可以得到结论，是旧Activity先onPause，然后新Activity再启动。</p>
<p>3.Activity被销毁并重建后，我们去获取之前的存储字符串，接受的位置可以是onRestoreInstanceState 或者 onCreate 方法，两者区别是？<br>  onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的拍断是否为空；<br>  但是onCreate不行，onCreate如果正常启动的话，其参数Bundle savedInstanceState为null, 所以必须要额外判断。</p>
<p>4.onSaveInstanceState和onRestoreInstanceState，在正常流程下会出发么？<br>  系统只在Activity异常种植的时候才会调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，其他情况不会出发这个过程。</p>
<p>5.比如目前任务栈S1中的情况为ABC，这个时候Activity D 以singleTask模式请求启动，其所需要的任务栈为 S2，由于S2和D的实例均不存在，所以系统会先创建<br>  任务栈S2，然后在创建D的实例并将其入栈到S2.</p>
<p>6.TaskAffinity任务相关性。<br>  这个参数标识一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。可以为每个Activity都单独制定TaskAffinity属性，<br>  这个属性必须不能和包名相同，否则就相当于没有制定。TaskAffinity属性主要和singleTask启动模式或者allTaskReparenting属性配对使用。当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity回运行在名字和TaskAffinity相同的任务栈中。<br>  当TaskAffinity和allowTaskReparenting结合的时候，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allTaskReparenting属性为true的话，那么当应用B被启动后，词Activity回直接从应用A的任务栈转移到应用B的任务栈中。</p>
<p>7.SharedPerences是否安全？<br>  SharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，因为SharedPreferences底层是通过读&#x2F;写XML文件来实现的，并发会出问题。<br>  每个应用的SharedPreferences文件都在当前包所在的data目录下查看到，目录位于 &#x2F;data&#x2F;data&#x2F;pacakage name&#x2F;shared_prefs目录下。<br>  SharedPreferences也属于文件的一种，但是由于系统对他的读&#x2F;写有一定的缓存策略，即在内存中有一份ShareePreferences文件的缓存，因此在多进程下，系统对它的读写诗不可靠的，当面对高并发的读&#x2F;写访问，有很大几率丢失文件。</p>
<p>8.Serializable接口的原理及serialVersionUID作用？<br>  想让一个对象实现序列化，只需要这个类实现Serializable接口并声明一个serialVersionUID即可。实际上，甚至连这个serialVersionUID也不是必须的。如何进行对象的序列化和反序列化也很简单，只需要采用ObjectOutputStream和ObjectInputStream，readObject()writeObject()函数。<br>  serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的数据中的serialVersionUID只有和当前累的serialVersionUID相同时才能够正常的被反序列化。<br>  serialVersionUID的详细工作机制时这样的：序列化的时候系统把当前类的serialVersionUID写入序列化文件中，当反序列化时候系统回去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本时相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候时无法正常反序列化的。</p>
<p>9.Parcelable接口原理？<br>  Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并通过Intent和Binder传递。<br>  Parcel内部包装了可序列化的数据，可以在Binder中自由传输。<br>  序列化的功能由writeToParcel方法来完成，最终时通过Parcel的一系列write方法来完成的；<br>  反序列化功能由CREATOR来完成，其内部表明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化过程。</p>
<p>10.Parcelable和Serializable的区别？<br>  Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I&#x2F;O操作。<br>  Parcelable是Android中的序列化方式，操作复杂，效率很高。<br>  Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但是<br>  这个过程会稍显复杂，因此这两种情况建议使用Serializable。</p>
<p>11.AIDL流程及原理<br>  1.创建aidl文件，声明函数及接口<br>  2.系统根据IBookManager.aidl生成IBookManager.jar类，继承了IInterface接口，本身也是接口。在Binder中传输的接口都需要继承<br>    IInterface接口。<br>  3.该类声明aidl中的方法，同时声明了两个正形的id分别用于标识这两个方法，这两个id用于表示在transact过程中客户端所追求的到底是哪个方法。它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成。<br>  核心实现就是它的内部类Stub和Stub的内部代理类Proxy。<br>  DESCRIPTOR：Binder的唯一标识，一半用单钱Binder的类名表示。<br>  asInterface(android.os.IBinder obj):用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的数据，这种转换过程是区分进程的，如果客户端和服务端位于统一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。<br>  asBindeeer：此方法用于返回当前Binder对象。<br>  onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层疯转后交由此方法处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值，onTransact方法执行过程是这样的。<br>  需要注意的是，如果此方法返回false，那么客户端的请求会失败。<br>  Proxy#geetBookList：这个方法运行在客户端，当客户端远程调用此方法时，，首先创建该方法所需要的输入型Parceel对象_data、输出型Parcel对象_reply和返回值对象List，然后把该方法的参数信息写入_data中；接着调用transact方法来发起RPC请求，同时当前线程刮起；然后服务端的onTransact方法会呗调用，知道RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_replay中的数据。<br>  Proxy#addBook:这个方法运行在客户端，它的执行过程和getBookList是一样的。<br>  注意点:1.当客户端发起远程请求时，由于当前线程会呗挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起此次远程请求<br>        2.由于服务端的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。</p>
<p>12.Binder包含两个重要的方法linkToDeath和unlinkToDeath。Binder运行在服务端进程，如果服务端进程由于某种原因异常终止，这时到服务<br>  端的Binder链接端礼，导致远程调用失败。为了解决这个问题，Binder中提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath可以给Binder设置一个死亡代理，当Linder死亡时，会收到通知，这时可以重新发起连接请求从而恢复连接。<br>  可通过isBinderAlive可以判断BInder是否死亡。<br>  1.声明DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法binderDied，我们需要实现这个方法，当Binder死亡的时候，系统就会毁掉binderDied方法</p>
<p>13.跨进程通讯Messenger原理？<br>  通过Messenger在不同进程中传递Message对象。Messenger底层是AIDL。<br>  1.服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回一个Messenger对象顶层的Binder即可<br>  2.客户端进程中，首先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger,通过这个Messenger就可以向服务端发送消息，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一样，还需要创建一个Handler并创建一个新的Messenger，并把这个Messengeer对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<p>14.AIDL中能够使用的List只有ArrayList，但是使用了CopyOnWriteArrayList(注意它不是继承自ArrayList)，为什么能够正常工作？<br>  因为AIDL中所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但是在Binder中会按照List的规范去访问数据并最终形成一个新的ArrayList传递给客户端。所以，在服务端采用CopyOnWriteArrayList是完全可以的。</p>
<p>15.RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口。RemoteCallbackList是一个范型，支持管理任意的AIDL接口，这点从它的生命可以看出，因为所有  的AIDL接口都继承自IInterface接口。原理是它的内部有一个Map结构专门用来保存所有的AIDL回调，这个Map的key是IBinder类型，value是Callback类型。<br>  RemoteCallbackList内部自动实现了线程同步的功能，所以使用它来注册和解注册时，不需要做额外的线程同步工作。</p>
<ol start="16">
<li></li>
</ol>
<p>17.Sockeet套接字，氛围流式套接字和用户数据套接字两种，分别对应于网络的传输控制层中的TCP和UDP。TCP时面向连接的协议，提供稳定的双向通讯功能，TCP连接的建立<br>   需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，具有很高的稳定性。而UDP时无连接的，提供不稳定的单向通讯功能，当然UDP也可以实现双向通讯功能。UDP具有更好的效率，确定是不保证数据一定能够正确传输，尤其在网络拥塞的情况下。</p>
<p>18.TouchSlop时系统所能识别出的被认为是滑动的最小距离，当手指在屏幕滑动时，如果两次滑动指尖的距离小于这个常量，系统就不认为是在进行滑动操作。<br>   ViewConfiguration.get(getContext()).getScaleedTouchSlop().</p>
<p>19.VelocityTracker速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。<br>   GestureDetector手势检测，用于辅助检测用护的点击、滑动、长安、双击等行为。创建GestrueDetector对象并实现OnGestureListener接口。<br>   Scroller弹性滑动对象，用于实现View的弹性滑动。</p>
<p>20.View的滑动方式<br>   1.通过View本身提供的scrollTo&#x2F;scrollBy方法来实现滑动<br>   2.通过动画给View施加平移效果实现滑动<br>   3.改变View的LayoutParams使得View重新布局从而实现滑动</p>
<p>21.scrollTo和scrollBy区别<br>   scrollBy实际上也是调用了scrollTo方法，它实现了基于当前位置的相对滑动，而scrollTo则实现了基于所传递参数的绝对滑动。</p>
<p>22.View滑动过程中，view内部的两个属性mScrollX和mScrollY的改变规则，这两个属性可以通过getScrollX和getScrollY方法分别得到。<br>   在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元呢在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在水平方向的距离。<br>   scrollTo和scrollBy只能改变View的内容的位置，而不能改变View在布局中的位置。</p>
<p>23.三种滑动对比<br>   1.scrollTo&#x2F;scrollBy:操作简单呢，适合对View内容的滑动。缺点只能滑动View的内容，不能滑动View本身。<br>   2.动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果。<br>   3.改变布局参数：操作稍微复杂，适用于有交互的View。</p>
<p>24.Scroller原理？<br>   首先构造一个Scroller对象并调用它的startScroll方法，内部其实什么也没做，只是保存了我们传递的几个参数startScroll(int startx,int starty,int dx,int dy ,in duration),滑动指View内容的滑动而非View本身位置的改变。startScroll方法下面的invalidate方法。invalidate方法会导致View重绘，在View的draw方法中又会去调用computeScroll方法，computeScroll方法在View中是一个空实现，因此需要我们去实现，上面的代码实现了computeScroll方法。<br>   当View冲毁后会在draw方法中调用computeScroll,而computeScroll又会去想Scroller获取当前的scrollX和scrollY，然后通过scrollTo方法实现滑动，接着又调用postInvalidate方法来进行第二次重绘。这一次重绘的过程和第一次重绘一样，还是会导致computeScroll方法被调用，然后继续向Scroller获取当前的scrollX和scrollY，并通过scrollTo方法滑动到最新的位置。<br>   概括：Scroller本身并不能实现View的滑动，它需要配合View的computeScroll方法才能完成弹性滑动的效果，他不断的让View重绘，二每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得到View当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成Vieew滑动。就这样，Vieew的每一次重绘都会导致View进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动。</p>
<p>25.点击事件的分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生之后，系统需要把这个事件传递给一个具体的View，这个传递的过程就是分发过程。<br>   分发过程主要由三个方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。<br>   1.dispatchToucherEveent(MotionEvent ev)<br>   用来进行事件的分发，如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。<br>   2.onInterceptTouchEvent(MotionEvent ev)<br>   在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。<br>   3.onTouchEvent(MotionEvent event)<br>   在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则同一事件序列中，当前View无法再次接收到事件。<br>   public boolean dispatchTouchEvent(MotionEvent ev){<br>        boolean consume &#x3D; false<br>        if(onInterceptTouchEvent(ev)){<br>             consume &#x3D; onTouchEvent(ev)<br>        }else{<br>             consume &#x3D; child.dispatchTouchEvent(ev)<br>        }<br>        return consume;<br>   }</p>
<p>26.事件传递规则<br>   对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法会被调用，如此反复知道事件被最终处理。</p>
<p>27.事件传递的优先级别 OnTouchListener &gt; onTouchEvent -&gt; OnCLickListener<br>   当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高.在onTouchEvent方法中，如果当前设置的有OnClickListeneer，那么它的onClick方法会被调用。可以看出，OnCLickListener，其优先级最低，即处于事件传递的尾端。</p>
<p>28.事件传递的顺序<br>   当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View，即事件总是先传递给Activity，Activity在传递给Window，最后Window在传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依次类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。</p>
<p>29.关于事件传递的机制，一些结论<br>   1.同一个事件序列是从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。<br>   2.正常情况下，一个序列事件只能被一个View拦截且消耗。因为一旦一个元素拦截了某个事件，那么同一事件序列内的所有事件都会直接全交给它处理，那么同一事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onToucheEvent强行传递给其他View处理。<br>   3.某个View一旦决定拦截，那么这一个事件序列都只能由它来处理(如果事件序列能够传递给它的话)，并且它的onInterceptTouchEveent不会再被调用。当一个View决定拦截一个事件后，那么系统会把同一事件序列内的其他方法都直接交给它来处理，那么就不用再调用这个View的onInterceptTouchEevent去询问它是否要拦截了。<br>   4.某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新由它的父元素去处理，即父元素的onTouchEvent会被调用，意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。<br>   5.如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。<br>   6.ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false。<br>   7.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。<br>   8.View的onTouchEvent默认都会消耗事件(返回true),除非它是不可点击的(clickable和longClickable同时为false)。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。<br>   9.View的enable属性不影响onTouchEvent的默认值。哪怕一个View是diable状态的，只要他的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。<br>   10.onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。<br>   11.事件传递过程是由外向内的，即时间总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以再子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
<p>30.事件分发源码解析<br>  1.Activity点击事件的分发过程<br>   点击事件用MotionEvent来表示，当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件派发，具体的工作是由Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow.getDecorView()可以获得。我们先从Activity的dispatchTouchEvent开始分析。<br>   public boolean dispatchTouchEvent(MotionEvent ev){<br>          if(ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN){<br>              onUserInteraction();<br>          }<br>          if(getView().superDispatchTouchEvent(ev)){<br>              return true;<br>          }</p>
<pre><code>      return onTouchEvent(ev);
</code></pre>
<p>   }<br>   首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。<br>   接下来看Window是如何将事件传递给ViewGroup的。Window是个抽象类，而Window的superDispatchTouchEEvent方法也是个抽象方法，因此我们必须找到Window的实现类才行。Window的实现类是PhoneWindow。window的superDispatchTouchEvent 最后调用的是mDecor.superDIspatchTouchEvent方法。通过((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0)这种方式就可以获取Activity所设置的View，这个mDecor显然就是getWindow().getDecorView（）返回的View，而我们通过setContentViewe设置的View是它的一个子View。目前事件传递到了DecorView这里，由于DecorView继承自FrameLayout且是父View，所以最终事件会传递给View。换句话说，事件肯定会传递到View,不然应用如何响应点击事件呢。从这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。</p>
<p>  3.顶级View对点击事件的分发过程<br>   点击事件达到顶级View以后，会调用ViewGroup的dispatchTouchEvent方法，如果顶级ViewGroup拦截事件即onInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的mOnTouchEvent被设置，则onTouch方法会被调用，否则onTouchEvent会呗调用。也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvent方法。在onTouchEvent中，如果设置了mOnClickListener，则onClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此为止，事件已经从顶级View传递到了下一层View，接下来的传递过程和顶级View是一致的，如此循环，完成整个事件的分发。<br>   首先看ViewGroup对点击事件的分发过程，其主要实现在ViewGroup的dispatchTouchEvent方法中，它描述的是当前View是否拦截点击事件这个逻辑。<br>   final boolean intercepted;<br>   if(actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN || mFirstTouchTarget !&#x3D;null){<br>      final boolean disallowIntercept &#x3D; (mGroupFlags &amp; FLAG_DISALLOWINTERCEPT !&#x3D; 0 )<br>      if(!disallowIntercept){<br>         intercepted &#x3D; onInterceptTouchEvent(ev);<br>         ev.setAction(action)<br>      }else{<br>         intercepted &#x3D; false;<br>      }<br>   }else{<br>         intercepted &#x3D; true;<br>   }</p>
<p>   从代码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类型为ACTION_DOWN或者mFirstTouchTarget！&#x3D;null。ACTION_DOWN事件好理解，那么mFirstTouchTarget！&#x3D;null是什么意思呢？当事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向子元素，当ViewGroup不拦截事件并将事件交给子元素处理时mFirstTouchTarget！&#x3D;null。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget！&#x3D;null就不成立。那么当ACTION_MOVE和ACTION_UP事件到来时，由于(actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN || mFirstTouchTarget！&#x3D;null)这个条件为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其他事件就会默认交给它处理。<br>   当然，这里有一种特殊情况，那就是FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceceptTouchEvent方法来设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN意外的恶其他点击事件。为什么说是除了ACTION_DOWN以外的其他事件呢？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会充值FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。因此，当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onIntercept方法来询问自己是否要拦截事件。<br>     if(actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN){<br>        cancelAndClearTouchTargets(ev);<br>        resetTouchState();<br>     }<br>   ViewGroup会在ACTION_DOWN事件到来时做重制状态的操作，而在resetTOuchState方法中会对FLAG_DISALLOW_INTERCEPT进行充值，因此子View调用request-DisallowInterceptTouchEvent方法并不影响ViewGroup对ACTION_DOWN事件的处理。<br>   得出结论:当ViewGroup决定拦截事件后，后续的点击事件将会默认交给它处理并且不在调用它的onInterceptTouchEvent方法。<br>           FLAG_DISALLOW_INTERCEPT这个标志的作用时让ViewGroup不在拦截事件，当然前提是ViewGroup不拦截ACTION_DOWN事件。<br>      价值:第一点，onInterceptToucheEvent不是每次事件都会被调用的，如果想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用，当然前提是事件能够传递到当前的ViewGroup；<br>          第二点，FLAG_DISALLOW_INTERCEPT标记位的作用给提供了一个思路，当面对滑动冲突时，我们可以考虑用这种方法解决问题。</p>
<p>  接着再看当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View进行处理<br>      final View[] children &#x3D; mChildren;<br>      for(int i &#x3D; childrenCount - 1; i &gt;&#x3D; 0 ; i –){<br>          final int childIndex &#x3D; customOrder ? getChildDrawingOrder(chilrenCount, i) : i ;<br>          final View child &#x3D; (preorderedList &#x3D;&#x3D; null) ? children[childIndex] : preorderedList.get(childIndex);<br>          if(!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)){<br>              continue;<br>          }<br>          newTouchTarget &#x3D; getTouchTarget(child);<br>          if(newTouchTarget !&#x3D; null){<br>              newTouchTarget.pointerIdBits !&#x3D; idBitsToAssign;<br>              break;<br>          }</p>
<pre><code>  &#125;
  resetCancelNextUpFlag(child);
  if(dispatchTransformedTouchEvent(ev,false,child,idBitsToAssign))&#123;
      mLastTouchDownTime = ev.getDownTime();
      if(preorderedList != null)&#123;
         for(int j=0;j&lt;childrenCOunt ; j++)&#123;
             if(children[childIndex]==mChildren[j])&#123;
                mLastTouchDownIndex = j ;
                break;
             &#125;
         &#125;
      &#125;else&#123;
          mLastTouchDownIndex = childIndex;
      &#125;
      mLastTouchDownX = ev.getX();
      mLastTouchDownY = ev.getY();
      newTouchTarget = addTouchTarget(child, idBitsToAssign);
      alreadyDispatchedToNewTouchTarget = true ;
      break;
  &#125;
</code></pre>
<p>  上方代码逻辑：首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接受到点击事件。是否能够接受点击事件主要由两点来衡量：子元素是否在播放动画和点击事件的坐标是否落在子元素的区域内。如果某个子元素满足这两个条件，那么事件就会传递给它来处理。dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，在它的内部有如下一段内容，而在上面的恶代码中传递的不是null，因此它会直接调用子元素的dispatchTouchEvent方法，这样事件就交由子元素处理，从而完成了一轮事件分发。</p>
<pre><code>      if(child == null)&#123;
          handled = super.dispatchTouchEvent(event);
      &#125;else&#123;
          handled = child.dispatchTouchEvent(event);
      &#125;
</code></pre>
<p>   如果子元素的dipatchTouchEvent返回true，这是我们暂时不用考虑事件在子元素内部时怎么分发的，那么mFirstTouchTarget就会被赋值同时跳出for循环，<br>          newTouchTarget &#x3D; addTouchTarget(child,idBitsToAssign);<br>          alreadyDispatchedToNewTouchTarget &#x3D; true;<br>          break;<br>   这几行代码完成了mFirstTouchTarget的肤质并终止对子元素的遍历。如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素(如果还有下一个子元素的话)。<br>   其实mFirstTouchTarget真正的赋值过程是在addTouchEvent内部完成的，从下面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截测恶略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件。<br>        private TouchTarget addTouchTarget(View child,int pointerIdBits){<br>            TouchTarget target &#x3D; TouchTarget.obtain(child,pointerIdBits);<br>            target.next &#x3D; mFirstTouchTargeet;<br>        }<br>  如果遍历所有的子元素后事件都没有被合适的处理，那包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。着两种情况下，ViewGroup会自己处理点击事件。<br>        if(mFirstTouchTarget &#x3D;&#x3D; null){<br>          handled &#x3D; dispatchTransformedTouchEvent(ev,canceled,null,TouchTarget.ALL_POINTER_IDS)<br>        }<br>  这里第三个参数child为null，他会调用super.dispatchTouchEvent(event),很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理。</p>
<p>  4.View对点击事件的处理过程<br>    View对点击事件的处理过程稍微简单，注意这里的View不包含ViewGroup。<br>    public boolean dispatchTouchEvent(MotionEvent event){<br>      boolean result &#x3D; false;<br>      if(onFilterTouchEventForSecurity(event)){<br>        ListeneerInfo li &#x3D; mListenerInfo;<br>        if(li !&#x3D; null &amp;&amp; li.mOnTouchListener !&#x3D; null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) &#x3D;&#x3D; ENABLED &amp;&amp; li.mOnTOuchListener.onTouch(this,event)){<br>          result &#x3D; true;<br>        }<br>      }<br>      if(!result &amp;&amp; onTouchEvent(event)){<br>          result &#x3D; true;<br>      }<br>      return result;<br>    }<br>   View对点击事件的处理过程比较简单，因为View是一个单独的元素，他没有子元素因此无法向下传递事件，所以它只能自己处理事件。View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可以OnTouchListener的优先级高于onTouchEevent，方便在外界处理点击事件。</p>
<p>   在分析OnTouchEEveent的实现。先看当View处于不可用状态下点击事件的处理过程。不可用状态下的View照样会消耗点击事件，接管它看起来不可用。<br>      if((viewFlags &amp; ENABLE_MASK) &#x3D;&#x3D; DISABLED){<br>          if(event.getAction() &#x3D;&#x3D; MotionEveent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) !&#x3D; 0){<br>              setPressed(false);<br>          }<br>          return (((vieewFlags &amp; CLICKABLEE) &#x3D;&#x3D; CLICKABLE || (viewFlags &amp; LONG_CLICKABLE)&#x3D;&#x3D; LONG_CLICKABLE));<br>      }<br>   如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个onTouchEvent的工作机制看起来和OnTouchListener类似。<br>      if(mTouchDelegate !&#x3D; null){<br>          if(mTouchDelegate.onTouchEvent(eevent)){<br>            return true;<br>          }<br>      } </p>
<p>   下面看一下onTouchEvent中对点击事件的具体处理<br>     if(((viewFlags &amp; CLICKABLE) &#x3D;&#x3D; CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) &#x3D;&#x3D; LONG_CLICKABLE)){<br>        switch(event.getAction()){<br>          case MotionEvent.ACTION_UP:<br>            boolean prepressed &#x3D; (mPrivateFlags &amp; PFLAG_PREPRESSED) !&#x3D; 0;<br>            if((mPrivateFlags &amp; PFLAG_PRESSED) !&#x3D; 0 || prepressed){<br>                if(!mHasPerformedLongPress){<br>                  removeLongPressCallback();<br>                }<br>                if(!focusTaken){<br>                  if(mPerformClick &#x3D;&#x3D; null){<br>                    mPerformClick &#x3D; new PerformClick();<br>                  }<br>                  if(!post(mPerformClick)){<br>                    performClick();<br>                  }<br>                }<br>            }<br>        }</p>
<pre><code> &#125;

 从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEEvent方法返回true，不管它是不是DISABLEE状态，然后就是当ACTION_UP事件发生时，会出发performClick方法，如果View设置了OnClickListener，那么performClick方法回调用它的onClick方法，如下所示。
 public boolean performClick()&#123;
    final boolean result;
    final ListeenerInfo li = mListenerInfo;
    if(li != null &amp;&amp; li.mOnClickListeener != null)&#123;
      playSoundEffect(SoundEffectConstants.CLICK);
      li.mOnClickListener.onClick(this);
      result = true;
    &#125;else&#123;
      result =false;
    &#125;
    sendAccessibilityEvent(Access)
    return result;
 &#125;

View的LONG_CLICKABLE属性默认认为false，而CLICKABLE属性是否为false和具体的View有关，确切来说是可点击的Viewe其CLICKABLE为true，不可点击的View其CLICKABLE为false，比如Button是可点击的，TextView是不可点击的。通过setClickable和setLongClickable可以分别改变View的恶CLICKABLE和LONG_CLICKABLE属性。另外，setOnClickListener会自动将View的CLICKABLE设为true，setOnLongClickListener则会自动将View的LONG_CLICKABLE设为true，如下所示：
public void setOnClickListener(OnClickListener l)&#123;
    if(!isClickable())&#123;
        setClickable(true);
    &#125;
    getListenerInfo().mOnClickListener = 1;
&#125;

public void setOnLongClickListenr(OnLongClickListener l)&#123;
    if(!isLongClickable)&#123;
      setLongClickable(true);
    &#125;
    getListenerInfo().mOnLongClickListener = l;
&#125;
</code></pre>
<p>31.滑动冲突时如何产生的呢？如何解决滑动冲突呢？<br>  其实在解饿面中只要内外两层同时可以滑动，这个时候就会产生滑动冲突。</p>
<p>32.常见的滑动冲突场景<br>场景1:外部滑动方向和内部滑动方向不一致<br>场景2:外部滑动方向和内部滑动方向一致<br>场景3:上面两种情况的嵌套。<br>解决场景1:当用户左右滑动时，需要让外部的View拦截点击事件，当用户上下滑动时，需要让内部View拦截点事件。这个事件我们就可以根据它们的特征来解决滑动冲突，具体来说时：根据滑动时水平滑动还是竖直滑动来判断到底由谁来拦截事件，根据滑动过程中两个点之间的坐标就可以得出到底时水平滑动还是竖直滑动。<br>解决场景2:无法根据滑动的角度、距离差以及速度差来做判断。可以从业务上规定：当处于某种状态时需要外部View响应用户的滑动，而处于另外一种状态时则需要内部View来响应View的滑动，根据这种业务上的需求我们也能得到响应的处理规则，有了处理规则同样可以进行下一步处理。<br>解决场景3:无法直接根据滑动角度、距离差以及速度差来做判断。</p>
<p>33.如果根据坐标来得到滑动的方向？<br>   可以依据滑动路径和水平方向所形成的夹角，也可以依据水平方向和竖直方向上的距离差来判断，某些特殊时候还可以依据水平和竖直方向的速度差来做判断。</p>
<p>34.两种解决滑动冲突的方式：外部拦截法和内部拦截法。<br>  1.外部拦截法：所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题，这种方法比较符合点击事件的分发机制。外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可。</p>
<p>  public boolean onInterceptTouchEvent(MotionEveent event){<br>      boolean intercepted &#x3D; false;<br>      int x &#x3D; (int) event.getX();<br>      int y &#x3D; (int) event.getY();<br>      switch(event.getAction()){<br>        case MotionEvent.ACTION_DOWN:{<br>          intercepted &#x3D; false;<br>          break;<br>        }<br>        case MotionEvent.ACTION_DOWN:{<br>          if(父容器需要当前点击事件){<br>            intercepted &#x3D; true;<br>          }else{<br>            intercepted &#x3D; false;<br>          }<br>          break;<br>        }<br>      }<br>      mLastXInterecept &#x3D; x;<br>      mLastYInterecept &#x3D; y;<br>      return intercepted;<br>  }<br>  上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不要做修改并且也不能修改。这里对上述代码再描述一下，在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件,设置因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件无法再次传递给子元素。其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false;最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。<br>  考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接受到ACTION_UP事件，这个时候子元素中的onClick事件就无法出发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。<br>    2.内部拦截法是指父容器不拦截任何事件，所有的时间都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，使用起来较外部拦截.稍显复杂。伪代码如下，需要重写子元素的dispatchTouchEvent方法：<br>   public boolean dispatchTouchEvent(){<br>      int x &#x3D; (int) event.getX();<br>      int y &#x3D; (int) event.getY();<br>      switch(event.getAction()){<br>          case MotionEvent.ACTION_DOWN:{<br>            parent.requestDisallowInterceptTouchEvent(true);<br>            break;<br>          }<br>          case MotinoEvent.ACTION_MOVE:{<br>            int deltaX &#x3D; x - mLastX;<br>            int deltaY &#x3D; y - mLastY;<br>            if(父容器需要此类点击事件){<br>              parent.requestDisallowInterceptTouchEvent(false);<br>            }<br>            break;<br>          }<br>          case MotionEvent.ACTION_UP:{<br>            break;<br>          }<br>      }<br>      mLastX &#x3D; x;<br>      mLastY &#x3D; y;<br>      return super.dispatchTouchEvent(event);<br>   }<br>   上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面的条件即可，其他不需要做改动而且也不能有改动。除了子元素需要做处理以外，父元素也要默认拦截了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。</p>
<p> 35.为什么父容器不能拦截ACTION_DOWN事件？<br>   因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截法就无法起作用了。<br>   父元素所作的修改如下：<br>   public boolean onInterceptTouchEvent(MotionEvent event){<br>      int action &#x3D; event.getAction();<br>      if(action &#x3D;&#x3D; MotionEvent.ACTION_DOWN){<br>        return false;<br>      }else{<br>        return true;<br>      }<br>   }</p>
<p> 36.ViewRoot和DecorView的概念<br>   ViewRoot对应于ViewRootImpl类，它是链接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，代码如下：<br>    root &#x3D; new ViewRootImpl(view.getContext(),display);<br>    root.setView(view,wparams,panelParentView);</p>
<p> 37.View的绘制流程？<br>   View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽度和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制到屏幕上。<br>                    performTraversals<br>                    ViewGroup                                             View<br>                    performMeasure -&gt; measure -&gt; onMeasure               measure<br>                    performLayout -&gt; layout -&gt; onLayout                  layout<br>                    performDraw -&gt; draw -&gt; onDraw                        draw<br>   performTraversals会一次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中在performMeasure中会调用measure方法，在measure方法中会调用onMeasure方法，在onMeasure方法中则会对所有子元素进行measure过程，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程。接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的。<br>   measure过程决定了View的宽高，Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight方法来获取到View测量后的宽高，在几乎所有的情况下它都等同于View最终的宽高，但是特殊情况除外。Layout过程决定了View的四个顶点的坐标和实际的View的宽高，完成以后，可以通过getTop、getBottom、getLeft和getRight来拿到View的四个顶点位置，并可以通过getWidth和getHeight方法来拿到View额最终宽高。Draw过程则决定View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。<br>   DecorView作为顶级View，一般情况下它内部会包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分，上面是标题栏，下面是内容栏。在Activity中通过setContextView所设置的布局文件被加到内容栏中，而内容栏的id是content，因此可以链接为Activity指定布局的方法不叫setView而叫setContentView,因此布局的确加到了id为content的FrameLayout中。通过ViewGroup content &#x3D; findViewById(R.android.id.content)。通过content.getChaildAt(0)可以获取到设置的View。DecorView是一个FrameLayout，View层的事件都先经过DecorView，然后才传递给我们的View。</p>
<p> 38.理解MeasureSpec<br>   MeasureSpec参与了View的mesasure过程，很大成都上决定了一个View的尺寸规格，这个过程还受父容器的影响，因此父容器影响View的MeasureSpec的创建过程。在测量过程中，系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec，然后在根据这个measureSpec来测量出View的宽高。<br>   MeasureSpec代表一个32位int值，高2为代表SpecMode，低30位代表SpecSize,SpecMode是值测量模式，而SpecSize是指在某种测量模式下的规格大小。<br>    private static final int MODE_SHIFT &#x3D; 30;<br>    private static final int MODE_MASK &#x3D; 0x3 &lt;&lt; MODE_SHIFT;<br>    public static final int UNSPECIFIED &#x3D; 0 &lt;&lt; MODE_SHIFT;<br>    public static final int EXACTLY &#x3D; 1 &lt;&lt; MODE_SHIFT;<br>    public static fianl int AT_MOST &#x3D; 2 &lt;&lt; MODE_SHIFT;</p>
<pre><code>public static int makeMeasureSpec(int size, int mode)&#123;
      if(sUseBrokenMakeMeasureSpec)&#123;
        return size + mode;
      &#125;else &#123;
        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);
      &#125;
&#125;

public static int getMode(int measureSpecc)&#123;
  return (measureSpec &amp; MODE_MASK);
&#125;

public static int getSize(int measureSpec)&#123;
  return (measureSpec &amp; ~MODE_MASK);
&#125;

MeasureSpec通过SpecMode 和 SpecSize打包成一个int值来避免过的多的对象内存分配，为了方便操作，其提供了打包和解包方法。SpecMode和SpecSize也是一个int值，一组SpecMode和SpecSize可以打包为一个MeasureSpec，而一个MeasureSpec可以通过解包的形式来得出其原始的SpecMode和SpecSize，需要注意的是这里提到的MeasureSpec是指MeasureSpec所代表的int值，而并非MeasureSpec本身。

UNSPECIFIED： 父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。
ExACTLY：父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。
AT_MOST：父容器指定了一个可用大小即SpecSize,View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。
</code></pre>
<p> 39.MeasureSpec和LayoutParams的对应关系<br>    系统内部是通过MeasureSpec来进行View的测量，但是正常情况下我们使用View指定MeasureSpec，尽管如此，但是我们可以给View设置LayoutParams。在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应额MeasureSpec，然后在根据这个MeasureSpec来确定View测量后的宽高。需注意，MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽高。对于顶级View(即DecorView)和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同决定，对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽高。<br>    对于DecorView来说，在ViewRootImpl中的measureHierarchy方法中有如下代码，它展示了DecorView的MeasureSpec的创建过程，其中desiredWindowWidth和desiredWindowHeight是屏幕的尺寸：<br>    childWidthMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowWidth, lp.width);<br>    childHeightMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowHeight, lp.height);<br>    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<br>    接着看一下getRootMeasureSpec方法的实现：<br>    private static int getRootMeasureSpec(int windowSize,int rootDimension){<br>      int measureSpec;<br>      switch(rootDimension){<br>        case ViewGroup.LayoutParams.MATCH_PARENT:<br>        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);<br>        case ViewGroup.LayoutParams.WRAP_CONTENT:<br>        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);<br>        default:<br>        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);<br>      }<br>      return measureSpec;<br>    }<br>    通过上述代码，DecorView的MeasureSpec的产生过程就很明确了，具体来说其遵守如下规则，根据它的LayoutParms中额宽高的参数来划分。<br>    LayoutParams.MATCH_PARENT:精确模式，大小就是窗口的大小。<br>    LayoutParams.WRAP_CONTENT:最大模式，大小不定，但是不能超过窗口的大小。<br>    固定大小:精确模式，大小为LayoutParams中指定的大小。<br>    对于普通View来说，这里是指我们布局中的View，View的measure过程由ViewGroup传递而来，看下ViewGroup的measureChildWithMargins方法：<br>    public static int getChildMeasureSpec(int spec, int padding, int chaildDimension){<br>        int specMode &#x3D; MeasureSpec.getMode(spec);<br>        int specSize &#x3D; MeasureSpec.getSize(spec);<br>        int size &#x3D; Math.max(0,specSize - padding);<br>        int resultSize &#x3D; 0 ;<br>        int resultMode &#x3D; 0 ;<br>        switch(specMode){<br>          case MeasureSpec.EXACTLY:<br>            if(childDimension &gt;&#x3D; 0){<br>              resultSize &#x3D; childDimension;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimensiong &#x3D;&#x3D; LayoutParams.MATCH_PARENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.AT_MOST;<br>            }<br>          break;<br>          case MeasureSpec.AT_MOST:<br>             if(childDimension &gt;&#x3D; 0){<br>              resultSize &#x3D; childDimension;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimensiong &#x3D;&#x3D; LayoutParams.MATCH_PARENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.AT_MOST;<br>            }else if(childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT){<br>              resultSize &#x3D; size;<br>              resultMode &#x3D; MeasureSpec.AT_MOST;<br>            }<br>          break;<br>          case MeasureSpec.UNSPECIFIED:<br>             if(childDimension &gt;&#x3D; 0){<br>              resultSize &#x3D; childDimension;<br>              resultMode &#x3D; MeasureSpec.EXACTLY;<br>            }else if(childDimensiong &#x3D;&#x3D; LayoutParams.MATCH_PARENT){<br>              resultSize &#x3D; 0;<br>              resultMode &#x3D; MeasureSpec.UNSPECIFIED;<br>            }else if(childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT){<br>              resultSize &#x3D; 0;<br>              resultMode &#x3D; MeasureSpec.UNSPECIFIED;<br>            }<br>          break;<br>        }<br>        return MeasureSpec.makeMeasureSpecc(resultSize, resultMode);<br>    }<br>    它的作用是根据父容器的MeasureSpec同时结合View本身的LayoutParams来确定子元素的MeasureSpec，此参数中的padding是指父容器中已占用的空间大小，因此子元素可用的大小为父容器的尺寸减去padding，代码如下：<br>    int specSize &#x3D; MeasureSpec.getSize(spec);<br>    int size &#x3D; Math.max(0, specSize - padding);</p>
<p>  40.View的工作流程？<br>     View的工作流程主要是指measure、layout、draw这三大的流程，即测量、布局和绘制，其中measure确定View的测量宽高，layout确定View的最终宽高的四个顶点的位置，而draw则将View绘制到屏幕上。<br>     measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子元素的measure方法，各个子元素在递归去执行这个流程。<br>     1.View的measure过程<br>       view的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这个方法子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，onMeasure方法如下：<br>       protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){<br>          setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec, getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)));<br>       }<br>       setMeasuredDimension方法会设置View宽高的测量值，因此需要看getDefaultSize这个方法即可：<br>       public static int getDefaultSize(int size, int measureSpec){<br>        int result &#x3D; size;<br>        int specMode &#x3D; MeasureSpec.getMode(measureSpec);<br>        int specSize &#x3D; MeasureSPec.getSize(measureSpec);<br>        switch(sspecMode){<br>            case MeasureSpec.UNSPECIFIED:<br>            result &#x3D; size;<br>            break;<br>            case MeasureSpec.AT_MOST:<br>            case MeasureSpec.EXACTLY:<br>            rersult &#x3D; specSize；<br>            break;<br>            rerturn result;<br>        }<br>       }<br>        可以看出，getDefaultSize这个方法逻辑很简单，我们只需要看AT_MOST和.EXACTLY这种情况。简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。<br>    View的宽高由specSize决定，所以我们可以得出如下结论，直接继承View的自定义空间需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。</p>
<p>  41.getSuggestedMinimumWidth大的逻辑？<br>     如果View没有设置背景那么返回android:minWidth这个属性所指定的值，这个值可以为0，如果View设置了背景，则返回android：minWidth和背景的最小宽度这两者中的最大值，getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值就是View的UNSPECIFIED情况下的测量宽高。   </p>
<p>  42.ViewGroup的measure过程<br>     对于ViewGroup来说，除了完成自己的measure过程外，还会遍历去调用所有子元素的measure方法，各个子元素在递归去执行这个过程。和View不同的时，ViewGroup时一个抽象类，因此它没有重写View的onMeasure方法，但是它提供了一个较measureChildren的方法<br>     protected void measureChildren(int widthMeasureSpec,int heightMeasureSpec){<br>      final int size &#x3D; mChildrenCount;<br>      final View[] children &#x3D; mChildren;<br>      for(int i &#x3D; 0; i &lt; size ; ++i){<br>         final View child &#x3D; children[i];<br>         if((child.mViewFilags &amp; VISIBILITY_MASK) !&#x3D; GONE){<br>            measureChild(child,widthMeasureSpec,heightMeasureSpec);<br>         }<br>      }<br>     }<br>     从上述代码来看，ViewGroup在measure时，会对每一个子元素进行measure，measureChild这个方法的实现也很好理解，<br>     protected void measureChild(View child,int parentWidthMeasureSpec, int parentHeightMeasureSpec){<br>      final LayoutParams lp &#x3D; child.getLayoutParams();<br>      final int childWidthMeasureSpec &#x3D; getChildMeasureSpec(parentWidth-MeasureSpec,mPaddingLeft+mPaddingRight,lp.width);<br>      final int childHeightMeasureSpec &#x3D; getChildMeasureSpec(parentHeight - MeasureSpec,mPaddingTop + mPaddingBottom , lp.height);<br>      child.measure(childWidthMeasureSpec , childHeightMeasureSpec);<br>     }<br>     measureChild 的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量。getChildMeasureSpec的工作已经再上面进行了详细分析。<br>     ViewGroup并没有定义其测量的具体过程，这是因为ViewGroup时一个抽象类，其测量过程的onMeasure方法需要哥哥子类去具体实现，比如LinearLayout、RelativeLayout等，为什么ViewGroup不像View一样对其onMeasure方法做同意的实现呢？那是因为不同的ViewGroup子类有不同的布局特征，这导致他们的测量细节各不相同，比如LinearLayout、RelativeLayout这两者布局特性显然不同，因此ViewGroup无法做统一实现。</p>
<p>  43.比如我们想再Activity已启动的时候做一件任务，但是这个一件任务需要获取某个View的宽高，再onCreate或者onResume里面获取这个View的宽高可以么？<br>     实际上onCreate、onStart、onResume中均无法正确得到某个View的宽高信息，这是因为View的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证Activity执行了onCreate、onStart、onResume时某个View已经测量完毕了，如果View还没有测量完毕，那么获取到的宽高就是0.<br>     1.Activity&#x2F;View#onWindowFocusChanged<br>       onWindowFocusChanged这个方法的含义是：View已经初始化完毕了，宽高已经准备好了，这个时候去获取宽高是没问题的。需要注意的是，onWindowFocusChanged会被调用多次，当Activity的窗口地道道焦点和失去焦点时均会被调用一次。具体来说，当Activity继续执行和暂停执行时，onWindowFocusChanged均会被调用，如果频繁的进行onResume和onPause，那么onWindowFousChanged也会被频繁地调用。<br>       public void onWindowFocusChanged(boolean hasFocus){<br>          super.onWindowFocusChanged(hasFocus);<br>          if(hasFous){<br>            int widht &#x3D; view.getMeasuredWidth();<br>            int height &#x3D; view.getMeasuredHeight();<br>          }<br>       }<br>     2.view.post(runnable)<br>      通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View也已经初始化好了。<br>       protected void onStart(){<br>         super.onStart();<br>         view.post(new Runnable(){</p>
<pre><code>          public void run()&#123;
            int widht = view.getMeasuredWidth();
            int height = view.getMeasureHeight();
          &#125;

      &#125;);
   &#125;
 3.ViewTreeObserver。
  使用ViewTreeObserver的众多回调可以完成这个功能，比如使用OnGlobalLayoutListener这个几口，当View树的状态发生改变或者View树内部的View的可见性发生改变时，onGlobalLayout方法将被回调，因此这是获取View的宽高一个很好的实际。需要注意的是，伴随着View树的状态改变等。onGlobalLayout会被调用多次。
   protected void onStart()&#123;
        super.onStart();
        ViewTreeObserver observer = view.getViewTreeObserver();
        observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener()&#123;
                  public void onGlobalLyout()&#123;
                    view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                    int width = view.getMeasuredWidht();
                    itn height = view.getMeasuredHeight();
                  &#125;
          &#125;);

   &#125;

 4.view.measeure(int widthMeasureSpec, int heightMeasureSpec).
   通过手动对View进行measure来得到View的宽高。这种方法比较复杂，这里要分情况处理，根据View的LayoutParams来分：
   match_parent:
    直接放弃，无法measure出具体的宽高。原因很简单，根据View的measure过程，构造此种MeasureSpec需要知道parentSize，即父容器的剩余空间，而这个时候我们无法知道parentSize的大小，所以理论上不可能测量出View的大小。
   具体的数值：
    比如宽高都是100px，如下measure：
    int widthMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);
    int heightMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);
    view.measure(widthMeasureSpec, heightMeasureSpec);
   wrap_content:
    int widthMeasureSpec = MeasureSpec.makeMeasureSpec((1&lt;&lt;30) - 1, MeasureSPec.AT_MOST);
    int heightMeasureSpec = MeasureSpec.makeMeasureSpec((1&lt;&lt;30) - 1, MeasureSPec.AT_MOST);
</code></pre>
<p>  44.layout过程<br>    Layout的作用时ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它再onLayout中会遍历所有的子元素并调用其layout方法，再layout方法中onLayout方法会被调用。Layout过程和measure过程相比就简单多了，layout方法确定View本省的位置，而onLayout方法则会确定所有子元素的位置，先看View的layout方法，如下所示：<br>      public void layout(int l, int t, int r ,int b){<br>          if((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0){<br>              onMeasure(mOldWidthMeasureSpec , mOldHeightMeasureSpec);<br>              mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>          }<br>        int oldL &#x3D; mLeft;<br>        int oldT &#x3D; mTop;<br>        int oldB &#x3D; mBotytom;<br>        int oldR &#x3D; mRight;<br>        boolean changed &#x3D; isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l,t,r,b);<br>        if(changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED)){<br>            onLayout(changed, l, t, r, b);</p>
<pre><code>    &#125;
  &#125;
layout方法的大致流程如下：时首先会通过setFrame方法来设定View的四个顶点的位置，即初始化mLeft、mRight、mTop和mBottom这四个值，View的四个顶点一旦确定，那么View在父容器中的位置也就确定了，接着会调用onLayout方法，这个方法的用途时父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正实现onLayout方法。
  protected void onLayout(boolean changed, int l,int t, int r, int b)&#123;
        if(mOrientation == VERTICAL)&#123;
          layoutVertical(l, t, r, b);
        &#125;else&#123;
          layoutHorizontal(l, t, r, b);
        &#125;
  &#125;
LinearLyout中onLayout的实现逻辑和onMeasure的实现逻辑类似，这里选择layoutVertical继续讲解
  void layoutVertical(int left, int top, int right, int bottom)&#123;
      final int count = getVirtualChildCount();
      for(int i = 0; i &lt; count; i++)&#123;
          final View child = getVirtualChildAt(i);
          if(child == null)&#123;
              childTop += measureNullChild(i);
          &#125;else if(child.getVisibility() != GONE)&#123;
              final int childWidth = child.getMeasuredWidth();
              final int childHeight = child.getMeasuredHeight();
              final LinearLayout.LayoutParams lp = (LinearLayout.LayoutPaarams) child.getLayoutParams();
              if(hasDividerBeforeChildAt(i))&#123;
                  childTop += mDividerHeight;
              &#125;
              childTop += lp.topMargin;
              setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);
              childTop += childHeight + lp.bottomMargin + getNextLocation - Offset(child);
              i += getChildrenSkipCount(child,i);
          &#125;
      &#125;
  &#125;
 这里分析一下layoutVertical的代码逻辑，可以看到，此方法会遍历所有子元素并调用setChildFrame方法来为子元素指定相应的位置，其中childTop会逐渐增大，这就意味着后面的子元素会被放置靠下的位置，这刚好符合竖直防线的LinearLayout的特性。至于setChildFrame，它仅仅时调用子元素的layout方法而已，这样父元素在layout方法中完成自己的定位以后，就通过onLayout方法去调用子元素的layout方法，子元素会通过自己的layout方法来确定自己的位置，这样一层一层地传递下去就完成了整个View树的layout过程。setChildFrame方法的实现如下所示。
  private void setChildFrame(View child, int left, int top, int width, int height)&#123;
      child.layout(left, top, width, height);
  &#125;
 setChildFrame中的width和height实际上就是子元素的测量宽高，从下面的代码可以看出这一点：
 final int childWidth = child.getMeasuredWidth();
 final int childHeight = child.getMeasuredHeight();
 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);
 而在layout方法中会通过setFrame去设置子元素的四个顶点的位置，在setFrame中有如下几句赋值语句，这样以来子元素的位置就确定了：
 mLeft = left;
 mTop = top;
 mRight = right;
 mBottom = bottom;
</code></pre>
<p>   45.View的测量宽高和最终宽高有什么区别？View的getMeasuredWidth 和 getWidth这两个方法有什么区别？<br>     看一下getWidth 和 getHeight 这两个方法的具体实现:</p>
<pre><code>   public final int getWidth()&#123;
      return mRight - mLeft;
   &#125;  

   public final int getHeight()&#123;
      return mBottom - mTop;
   &#125;
  从getWidth和getHeight的源码在结合mLeft、mRight、mTop和mBottom这四个变量的复制过程来看，getWidth方法的返回值刚好就是View的测量宽度，而getHeight方法的返回值也刚好就是View的测量高度。经过上述分析，在View的默认实现中，View的测量高度和最终的宽高时相等的，只不过测量宽高形成于View的measure过程，而最终的宽高形成于View的layout过程，即两者复制实际不同，测量宽高的复制时机稍微早一些。可以认为View的测量宽高就等于最终宽高，但是的却存在有些特殊情况下会导致两者不一致。
  如果重写View的layout方法，代码如下：
     public void layout(int l ,int t, int r, int b)&#123;
        supre.layout(l, t, r + 100, b + 100);
     &#125;
  上述代码会导致任何情况下View的最终宽高总是比测量宽高大100px，虽然这样做会导致View显示不正常并且也没有实际意义，但是这证明了测量宽高的确可以不等于最终宽高。另外一种情况是在某些情况下，View需要多次measure才能确定自己的测量宽高，在前几次的从测量过程中，其得到的测量宽高有可能和最终宽高不一致，但最终来说，测量宽高还是和最终宽高相同。

46.draw过程
  Draw过程就比较简单了，它的作用是将View会知道屏幕上面。View的绘制过程遵循如下几步：
  1.绘制背景background.draw(canvas)
  2.绘制自己onDraw
  3.绘制children(dispatchDraw)
  4.绘制装饰(onDrawScrollBars)
  这一点通过draw方法的源码可以明显看出来
  public void draw(Canvas canvas)&#123;
    final int privateFlags = mPrivateFlags ;
    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PGLAG_DRAWN;
    //Step1. draw the backgroud ,if needed
    int saveCount;
    if(!dirtyOpaque)&#123;
        drawBackgroud(canvas);
    &#125; 
    final int viewFlags = mViewFLags;
    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges =  (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
    if(!verticalEdges &amp;&amp; !horizontalEdges)&#123;
      //Step 3 draw the content
      if(!dirtyOpaque) onDraw(canvas);
      //Step 4 draw decorations(scrollbars)
      onDrawScrollBars(canvas);
      if(mOverlay != null &amp;&amp; !mOverlay.isEmpty())&#123;
          mOverlay.getOverlayView().dispatchDraw(canvas);
      &#125;
      return;
    &#125;

  &#125;
 View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会便利调用所有子元素的draw方法，如此draw时间就一层层地传递了下去。View有一个特殊地方法setWillNotDraw，如下：
 public void setWillNotDraw(boolean willNotDraw)&#123;
    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);
 &#125;
 从setWillNotDraw这个方法地注释中可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启动这个优化标记位。这个标记位对实际开发的意义是：当我们的自定义控制继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显示的关闭WILL_NOT_DRAW这个标记位。

47.自定义VIew的分类
  1.继承View重写onDraw方法
    这种方法主要用于实现一些不规则的效果，即这种效果不方便通过布局的组合方式来达到，往往需要静态或者动态的显示一些不规则的图形。很显然需要通过绘制的方式来实现，即重写onDraw方法。采用这种方式需要自己支持wrap_content，并且padding也需要自己处理。
  2.继承ViewGroup派生特殊的Layout
    这种方式主要用于实现自定义的布局，即除了LinearLayout、RelativeLayout、FrameLayout这种系统的布局之外，我们重新定义一种新布局，当某种效果看起来很像集中View组合在一起的时候，可以采用这种方法来实现。采用这种方式稍微复杂一些，需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。
  3.继承特定的View                                   
    一般时用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现。这种方法不需要自己支持wrap_content和padding等。
  4.继承特定的ViewGroup
    这种方法也比较常见，当某种效果看起来很像集中View组合在一起的时候，可以采用这种方法来实现。采用这种方法不需要自己处理ViewGroup的测量和布局这两个过程。需要注意这种方法和方法2的区别，一般来说方法2能实现的效果方法4也都能实现，两者的主要差别在于方法2更接近View的底层。

 48.自定义View过程中的一些注意事项
    1.让View支持wrap_content
      支持因为支持继承View或者ViewGroup的控制，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。
    2.如果有必要，让你的View支持padding
      这是因为支持继承View的控件，如果不在draw方法中处理padding，那么padding属性时无法起作用的。直接继承自ViewGroup的控制需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。
    3.尽量不要在View中使用Handler,没必要
      这是因为View内部本身就提供了post系列的方法，完全可以替代Hanlder的作用。
    4.View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow
      如果有线程或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。当包含此View的Activity退出或者当前View被remove 时，View的onDetachedFromWindow方法会被调用，和此方法对应的时onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄露。
    5.View带有华东嵌套情形时，需要处理好滑动冲突
      如果有滑动冲突的话，那么要合适的处理华东冲突，否则将会严重影响View的效果。 
  
</code></pre>
<p>  49.AppWidgetProvider是Android中提供的用于实现桌面小部件的类，其本质是一个广播，即BroadcastReceiver。</p>
<p>  50.PendingIntent和Intent的区别是什么？<br>     PendingIntent表示一种处于pending状态的意图，而pending状态表示的是一种待定、等待、即将发生的意思，就是说接下来有一个Intent将在某个待定时刻发生。PendingIntent和Intent的区别在于，PendingIntent是在将来的某个不确定的时刻发生，而Intent是立刻发生。</p>
<p>  51.PendingIntent匹配规则？<br>     如果两个PendingIntent他们内部的Intent相同并且requestCode也相同，那么这两个PendingIntent就是相同的。requestCode相同比较好理解，那么什么情况下Intent相同呢？Intent的匹配规则是：如果两个Intent的ComponentName和intent-filter都相同，那么这两个Intent就是相同的。需要注意的是Extras不参与Intent的匹配过程，只要Intent之间的ComponentName和intent-filter相同，即使他们的Extras不同，那么这两个Intent样式相同的。</p>
<p>  52.PendingIntent中flags参数的含义？<br>     1.FLAG_ONE_SHOT：当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel，如果后续还有相同的PendingIntent，那么他们的send方法就会调用失败。对于通知栏消息来说，如果采用此标记位，那么同类的通知只能使用一次，后续的通知点击后将无法打开。<br>     2.FLAG_NO_CREATE：当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity、getService和getBroadcast方法会直接返回null，即获取PendingIntent失败。这个标记位很少见，它无法单独使用。<br>     3.FLAG_CANCEL_CURRENT：当前描述的PendingIntent如果已经存在，那么他们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些被cancel的消息单机后 将无法打开。<br>     4.FLAG_UPDATE_CURRENT：当前描述的PendingIntent如果已经存在，那么他们都会被更新，即他们的Intent中的Extras会被替换成最新的。</p>
<p>  53.通知栏和桌面小部件分别由NotificationManager和AppWidgetManager管理，而NotificationManager和AppWidgetManager通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetService进行通讯。因此可见，通知栏和桌面小部件中的布局文件实际上是在NotificationManagerService以及AppWidgetService中被加载的，而他们运行在系统的SystemServer中，这就和我们的进程构成了跨进成通讯的场景。</p>
<p>  54.RemoteViews的apply以及reapply方法来家在活着更新界面的，apply和reApply的却别在与：apply会家在布局并更新界面，而reApply则只会更新界面。通知栏和桌面小插件在初始化界面时会调用apply方法，而在后续的更新界面时则会调用reapply方法。</p>
<p>WindowManager所提供的功能很简单，常用的只有三个方法，即添加View、更行View和删除View，这三个方法定义在ViewManager中，而WindowManager继承了ViewManager<br>public interfacce ViewManager{<br>  public void addView(View view, ViewGroup.LayoutParams params);<br>  public void updateViewLayout(View view,ViewGroup.LayoutParams params);<br>  public void removeView(View view);<br>}</p>
<p>Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此此Window并不是实际存在的，它是以View的形式存在。</p>
<p>Window的添加过程<br>  Window的添加过程需要通过WindowManager的addView来实现，WindowManager是一个接口，它的真正实现是WindowManagerImpl类。在WindowManagerImpl中Window的三大操作的实现如下：<br>  public void addView(View view, ViewGroup.LayoutParams params){<br>    mGlobal.addView(view, params, mDisplay, mParentWindow);<br>  }</p>
<p>  public void updateViewLayout(View view, ViewGroup.LayoutParams params){<br>    mGlobal.updateViewLayout(view, params);<br>  }</p>
<p>  public void remoteView(View view){<br>    mGlobal.removeView(view, false);<br>  }<br>  WindowManagerImpl并没有直接实现Window的三大操作，二十交割WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实力，在WindowManagerGlobal中有以下代码：private final WindowManagerGLobal mGlobal &#x3D; WindowManagerGlobal。getInstance()。WindowManagerImpl这种工作模式是典型的桥接模式，将所有的操作全部委托给WindowMangerGlobal来实现。WindowManagerGlobal的addView方法主要分为如下几步。<br>  1.检查参数是否合法，如果是子Window那么还需要调整一些布局参数<br>    if(view &#x3D;&#x3D; null){<br>      throw new IllegalArgumentException(“view must not be null”);<br>    }<br>    if(display &#x3D;&#x3D; null){<br>      throw new IllegalArgumentException(“display must not be null”);<br>    }<br>    if(!(params instanceof WindowManager.LayoutParams)){<br>      throw new IllegalArgumentException(“Params must be WindowManager.LayoutParams”);<br>    }<br>    final WindowManager.LayoutParams wparams &#x3D; (WindowManger.LayoutParams)params;<br>    if(parentWindow !&#x3D; null){<br>      parentWindow.adjustLayoutParamsForSubWindow(wparams);<br>    }<br>   2.创建ViewRootImpl并将View添加到列表中<br>   在WindowMangerGlobal内部有如下几个列表比较重要：<br>   private final ArrayList<View> mViews &#x3D; new ArrayList<View>();<br>   private final ArrayList<ViewRootImpl> mRoots &#x3D; new ArrayList<ViewRootImpl>();<br>   private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams &#x3D; new ArrayList&lt;WindowManager.LayoutParams&gt;();<br>   private final ArraySet<View> mDyingViews &#x3D; new ArraySet<View>();</p>
<p>   在上面生命中，mViews存储的是所有Window所对应的View，mRoots存储的是所有Window所对应的ViewRootImpol，mParams存储的是素有Window所对应的布局参数，而mDyingViews则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象。在addView中通过如下方式将Window的乙烯利列对象添加到列表中：<br>    root &#x3D; new ViewRootImpl(view.getContext(), display);<br>    view.setLayoutParams(wparams);<br>    mViews.add(view);<br>    mRoots.add(root);<br>    mParams.add(wparams);<br>   3.通过ViewRootImpl来更新界面并完成Window的添加过程<br>    这个步骤由ViewRootImpl的setView方法来完成，View的绘制过程是由ViewRootImpl来完成的。在setView内部会通过requestLayout来完成异步刷新请求。scheduleTraversals实际是View绘制的入口：<br>    public void requestLayout(){<br>      if(!mHandlingLayoutInLayoutRequest){<br>        checkThread();<br>        mLayoutRequested &#x3D; true;<br>        scheduleTraversals();<br>      }<br>    }</p>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/ActivityManagerNative/">ActivityManagerNative</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/Zygote/">Zygote</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/SystemServer/">SystemServer</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a></div><hr></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/08/06/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/"><img class="fill" src="/gallery/thumbnails/sculpture.jpg" alt="Android 基础知识总结"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">b02f806e335755d050f19d76b2157f81</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b02f806e335755d050f19d76b2157f81">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>34 分钟  <i class="fas fa-pencil-alt"> </i>5.1 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/">Android 基础知识总结</a></h1><div class="content"><p>前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起返回按键的时候默认都是销毁当前Activity。而本文中我们主要介绍触摸事件的分发流程，从Native层到Activity层触摸事件的分发了流程和按键的分发事件都是类似的，这里我们可以根据异常堆栈信息看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">at com.example.aaron.helloworld.MainActivity.dispatchTouchEvent(MainActivity.java:103)</span><br><span class="line">at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2359)</span><br><span class="line">at android.view.View.dispatchPointerEvent(View.java:8698)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4530)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4388)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4053)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4110)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6345)</span><br><span class="line">at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6301)</span><br><span class="line">at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6254)</span><br><span class="line">at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6507)</span><br><span class="line">at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)</span><br></pre></td></tr></table></figure>
<p>这样经过一系列的方法调用之后最终调用了Activity的dispatchTouchEvent方法，而我们也是从Activiyt的dispatchTouchEvent方法开始对触摸事件的分发进行分析。</p>
<p>在具体查看Activity的dispatchTouchEvent方法之前我们先简单介绍一下触摸事件，触摸事件是由一个触摸按下事件、N个触摸滑动事件和一个触摸抬起事件组成的，通常的一个触摸事件中只能存在一个触摸按下和一个触摸抬起事件，但是触摸滑动事件可以有零个或者多个。好了，知道这个概念以后，下面我们就具体看一下Activity中的dispatchTouchEvent的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在看一下dispatchTouchEvent方法之前我们首先需要解释一下MotionEvent的概念。MotionEvent是一个触摸动作的封装，里面包含了触摸动作的类型，以及操作等属性，我们具体的可以看一下MotionEvent的说明：</p>
<blockquote>
<p>Object used to report movement (mouse, pen, finger, trackball) events. Motion events may hold either absolute or relative movements and other data, depending on the type of device.</p>
</blockquote>
<p>然后在dispatchTouchEvent方法中，会首先判断MotionEvent的动作类型，也就是我们的触目动作的类型，判断其是否是“按下”操作，若是的湖泽，则执行onUserInteraction方法，这个方法又是实现了什么逻辑呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void onUserInteraction() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其在Activity中只是一个简单的空实现方法，同样的我们可以看一下该方法的介绍：</p>
<blockquote>
<p>Called whenever a key, touch, or trackball event is dispatched to the activity.  Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and {@link #onUserLeaveHint} are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication.</p>
</blockquote>
<p>理解上就是用户在触屏点击，按home，back，menu键都会触发此方法。</p>
<p>回到Activity的dispatchTouchEvent方法中，我们调用了getWindow().suerDispatchTouchEvent()方法，我们分析过Activity的加载绘制流程，而这里的getWindow()就是返回Activity中的mWindow对象，而我们知道Activity中的mWindow对象就是一个PhoneWindow的实例。并且这里的window.superDispatchTouchEvent若返回值为ture，则直接返回true，否则的话会执行Activity的onTouchEvent方法，继续我们看一下PhoneWindow的superDispatchTouchEvent方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在PhoneWindow中的superDispatchTouchEvent方法中调用的是mDecor.superDispatchTouchEvent方法，而这里的mDecor是我们Activity显示的ViewTree的根View，并且mDecor是一个FrameLayout的子类，所以这里我们看一下mDecor的superDispatchTouchEvent方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123;</span><br><span class="line">	...</span><br><span class="line">	public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">            return super.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DecorView的superDispatchTouchEvent方法中我们调用了super.dispatchTouchEvent方法，而我们的DecorView继承于FrameLayout，但是经过查看之后我们知道FrameLayout中并没有实现dispatchTouchEvent方法，而由于我们的FrameLayout继承于ViewGroup，所以这里的dispatchTouchEvent方法应该就是ViewGroup的dispatchTouchEvent方法。</p>
<p>好了，这里先暂时说一下Acitivty中的事件分发流程</p>
<ul>
<li><p>ViewRootImpl层的事件分发会首先调用Activity的dispatchTouchEvent方法；</p>
</li>
<li><p>Activity的dispatchTouchEvent方法中会通过Window.superDispatchTouchEvent方法将事件传递给DecorView即ViewGroup。</p>
</li>
<li><p>若window的superDispatchTouchEvent方法返回true，则事件分发完成，Activity的dispatchTouchEvent直接返回为true，否则的话调用Activity的onTouchEvent方法，并且Acitivty的dispatchTouchEvent返回值与Activity的onTouchEvent返回值一致。</p>
</li>
</ul>
<p>下面我们在继续看一下ViewGroup的dispatchTouchEvent方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If the event targets the accessibility focused view and this is it, start</span><br><span class="line">        // normal event dispatch. Maybe a descendant is what will handle the click.</span><br><span class="line">        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean handled = false;</span><br><span class="line">        if (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">            final int action = ev.getAction();</span><br><span class="line">            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">            // Handle an initial down.</span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                // Throw away all previous state when starting a new touch gesture.</span><br><span class="line">                // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">                // due to an app switch, ANR, or some other state change.</span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Check for interception.</span><br><span class="line">            final boolean intercepted;</span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != null) &#123;</span><br><span class="line">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">                if (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); // restore action in case it was changed</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    intercepted = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // There are no touch targets and this action is not an initial down</span><br><span class="line">                // so this view group continues to intercept touches.</span><br><span class="line">                intercepted = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If intercepted, start normal event dispatch. Also if there is already</span><br><span class="line">            // a view that is handling the gesture, do normal event dispatch.</span><br><span class="line">            if (intercepted || mFirstTouchTarget != null) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Check for cancelation.</span><br><span class="line">            final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">            // Update list of touch targets for pointer down, if needed.</span><br><span class="line">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class="line">            TouchTarget newTouchTarget = null;</span><br><span class="line">            boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class="line">            if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">                // If the event is targeting accessiiblity focus we give it to the</span><br><span class="line">                // view that has accessibility focus and if it does not handle it</span><br><span class="line">                // we clear the flag and dispatch the event to all children as usual.</span><br><span class="line">                // We are looking up the accessibility focused host to avoid keeping</span><br><span class="line">                // state since these events are very rare.</span><br><span class="line">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                        ? findChildWithAccessibilityFocus() : null;</span><br><span class="line"></span><br><span class="line">                if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                    final int actionIndex = ev.getActionIndex(); // always 0 for down</span><br><span class="line">                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                    // Clean up earlier touch targets for this pointer id in case they</span><br><span class="line">                    // have become out of sync.</span><br><span class="line">                    removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                    final int childrenCount = mChildrenCount;</span><br><span class="line">                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</span><br><span class="line">                        final float x = ev.getX(actionIndex);</span><br><span class="line">                        final float y = ev.getY(actionIndex);</span><br><span class="line">                        // Find a child that can receive the event.</span><br><span class="line">                        // Scan children from front to back.</span><br><span class="line">                        final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</span><br><span class="line">                        final boolean customOrder = preorderedList == null</span><br><span class="line">                                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                        final View[] children = mChildren;</span><br><span class="line">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                            final int childIndex = customOrder</span><br><span class="line">                                    ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                            final View child = (preorderedList == null)</span><br><span class="line">                                    ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">                            // If there is a view that has accessibility focus we want it</span><br><span class="line">                            // to get the event first and if not handled we will perform a</span><br><span class="line">                            // normal dispatch. We may do a double iteration but this is</span><br><span class="line">                            // safer given the timeframe.</span><br><span class="line">                            if (childWithAccessibilityFocus != null) &#123;</span><br><span class="line">                                if (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                    continue;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus = null;</span><br><span class="line">                                i = childrenCount - 1;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            if (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class="line">                                ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            newTouchTarget = getTouchTarget(child);</span><br><span class="line">                            if (newTouchTarget != null) &#123;</span><br><span class="line">                                // Child is already receiving touch within its bounds.</span><br><span class="line">                                // Give it the new pointer in addition to the ones it is handling.</span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                                // Child wants to receive touch within its bounds.</span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                                if (preorderedList != null) &#123;</span><br><span class="line">                                    // childIndex points into presorted list, find original index</span><br><span class="line">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        if (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                            mLastTouchDownIndex = j;</span><br><span class="line">                                            break;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX = ev.getX();</span><br><span class="line">                                mLastTouchDownY = ev.getY();</span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            // The accessibility focus didn&#x27;t handle the event, so clear</span><br><span class="line">                            // the flag and do a normal dispatch to all children.</span><br><span class="line">                            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (preorderedList != null) preorderedList.clear();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</span><br><span class="line">                        // Did not find a child to receive the event.</span><br><span class="line">                        // Assign the pointer to the least recently added target.</span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        while (newTouchTarget.next != null) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Dispatch to touch targets.</span><br><span class="line">            if (mFirstTouchTarget == null) &#123;</span><br><span class="line">                // No touch targets so treat this as an ordinary view.</span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Dispatch to touch targets, excluding the new touch target if we already</span><br><span class="line">                // dispatched to it.  Cancel touch targets if necessary.</span><br><span class="line">                TouchTarget predecessor = null;</span><br><span class="line">                TouchTarget target = mFirstTouchTarget;</span><br><span class="line">                while (target != null) &#123;</span><br><span class="line">                    final TouchTarget next = target.next;</span><br><span class="line">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                        handled = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;</span><br><span class="line">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                            handled = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (cancelChild) &#123;</span><br><span class="line">                            if (predecessor == null) &#123;</span><br><span class="line">                                mFirstTouchTarget = next;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                predecessor.next = next;</span><br><span class="line">                            &#125;</span><br><span class="line">                            target.recycle();</span><br><span class="line">                            target = next;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    predecessor = target;</span><br><span class="line">                    target = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Update list of touch targets for pointer up or cancel, if needed.</span><br><span class="line">            if (canceled</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">                final int actionIndex = ev.getActionIndex();</span><br><span class="line">                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">                removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>前面我们知道触摸事件是由一个触摸按下事件，一个触摸抬起事件和N个触摸滑动事件组成的，而这里的触摸按下事件就是这里的ACTION_DOWN，同时友谊ACTION_DOWN是一系列事件的开端，所以我们在ACTION_DOWN时进行一些初始化操作，从上面源码中注释也可以看出来，清除以往的Touch状态然后开始新的手势。并在在cancelAndClearTouchTargets(ev)方法中将mFirstTouchTarget设置为了null，接着在resetTouchState()方法中重置Touch状态标识。</p>
<p>然后标记ViewGroup是否拦截Touch事件的传递，if (actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN || mFirstTouchTarget !&#x3D; null)这一条判断语句说明当事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立，否则if不成立，然后将intercepted设置为true，也即拦截事件。这里说明一下ViewGroup中的onInterceptTouchEvent方法是ViewGroup中特有的方法用于表示是否拦截触摸事件，返回为true的话则表示拦截事件，事件不在向子View中分发，若范围为false的话，则表示不拦截事件，继续分发事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一般的我们可以在自定义的ViewGroup中重写该方法，用于拦截事件的分发。而当我们在父ViewGroup重写该方法返回为true执行事件拦截的逻辑的时候，可以在子View中通过调用requestDisallowInterceptTouchEvent方法，重新设置父ViewGroup的onInterceptTouchEvent方法为false，不拦截对事件的分发逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</span><br><span class="line">            // We&#x27;re already in this state, assume our ancestors are too</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Pass it up to our parent</span><br><span class="line">        if (mParent != null) &#123;</span><br><span class="line">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>比如常见的向我们的ViewPager中由于需要处理左右滑动事件从而在其onInterceptTouchEvent方法中重写了返回值，返回为true，拦截对事件的处理逻辑，但是若这时候ViewPager中嵌套了ListView，则listView也需要处理触摸事件的逻辑，但是ViewPager中已经重写了onInterceptTouchEvent方法，这时候怎么办呢？幸运的是ListView也在内部的实现中调用了requestDisallowInterceptTouchEvent方法，保证自身获得对触摸事件的处理。</p>
<p>然后在代码中我们判断childrenCount个数是否不为0，继续我们获取子View的list集合preorderedList；最后通过一个for循环倒序遍历所有的子view，这是因为preorderedList中的顺序是按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会因为Android的UI后刷新机制显示在上层；假如点击的地方有两个子View都包含的点击的坐标，那么后被添加到布局中的那个子view会先响应事件；也就是说后被添加的子view会浮在上层，点击的时候最上层的那个组件先去响应事件。</p>
<p>然后代码通过调用getTouchTarget去查找当前子View是否在mFirstTouchTarget.next这条target链中的某一个targe中，如果在则返回这个target，否则返回null。在这段代码的if判断通过说明找到了接收Touch事件的子View，即newTouchTarget，那么，既然已经找到了，所以执行break跳出for循环。如果没有break则继续向下执行，这里你可以看见一段if判断的代码if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))，那么这个方法又是执行什么逻辑的呢？</p>
<p>在该方法中为一个递归调用，会递归调用dispatchTouchEvent()方法。在dispatchTouchEvent()中如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()，如果子View为View那么就会调用其onTouchEvent()。dispatchTransformedTouchEvent方法如果返回true则表示子View消费掉该事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">            View child, int desiredPointerIdBits) &#123;</span><br><span class="line">        final boolean handled;</span><br><span class="line"></span><br><span class="line">        // Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span><br><span class="line">        // or filtering.  The important part is the action, not the contents.</span><br><span class="line">        final int oldAction = event.getAction();</span><br><span class="line">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                handled = super.dispatchTouchEvent(event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            return handled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Calculate the number of pointers to deliver.</span><br><span class="line">        final int oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">        // If for some reason we ended up in an inconsistent state where it looks like we</span><br><span class="line">        // might produce a motion event with no pointers in it, then drop the event.</span><br><span class="line">        if (newPointerIdBits == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If the number of pointers is the same and we don&#x27;t need to perform any fancy</span><br><span class="line">        // irreversible transformations, then we can reuse the motion event for this</span><br><span class="line">        // dispatch as long as we are careful to revert any changes we make.</span><br><span class="line">        // Otherwise we need to make a copy.</span><br><span class="line">        final MotionEvent transformedEvent;</span><br><span class="line">        if (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            if (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                if (child == null) &#123;</span><br><span class="line">                    handled = super.dispatchTouchEvent(event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">                    final float offsetY = mScrollY - child.mTop;</span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line">                return handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Perform any necessary transformations and dispatch.</span><br><span class="line">        if (child == null) &#123;</span><br><span class="line">            handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">            final float offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            if (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Done.</span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在在ViewGroup的dispatchTransformedTouchEvent方法中，调用了该ViewGroup的child View的dispatchTouchEvent方法，若其子View也是ViewGroup，则重复执行ViewGroup的dispatchTouchEvent方法，若其子View是View，则执行View的dispatchTouchEvent方法。</p>
<p>但这里大概分析了一下ViewGroup的事件分发流程</p>
<ul>
<li><p>首先在android的事件分发流程中，通过调用Activity的dispatchTouchEvent，事件会首先被派发是先传递到最顶级的DecorView也就是ViewGroup，再由ViewGroup递归传递到View的。</p>
</li>
<li><p>在ViewGroup中可以通过设置onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</p>
</li>
</ul>
<p>下面我们继续看一下View的dispatchTouchEvent方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            //noinspection SimplifiableIfStatement</span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>View的dispatchTouchEvent方法的内容比较长，我们重点看一下View对触摸事件的处理逻辑，首先调用了onFilterTouchEventForSecurity(event)方法判断当前的View是否被遮盖，若没有的话，则判断View的mListenerInfo城边变量是否为空，而这里的mListenerInfo又是什么呢？通过分析源码我们知道这里的mListenerInfo是通过setOnClickListener方法设置的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void setOnClickListener(@Nullable OnClickListener l) &#123;</span><br><span class="line">        if (!isClickable()) &#123;</span><br><span class="line">            setClickable(true);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener = l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以当前View一旦执行了setOnClickListener方法改View的mListenerInfo就不为空，若后有判断了该View是否可点击，最后是判断View的onTouchListener的onTouch方法的返回值。</p>
<p>所以当我们为当前View设置了OnTouchListener并且返回值为true的话，则直接执行其onTouch方法，若onTouch方法返回为true的话，则直接返回不在执行后续的View的onTouchEvent方法，否则继续执行View的onTouchEvent方法，而我们继续看一下View的onTouchEvent方法的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        final float x = event.getX();</span><br><span class="line">        final float y = event.getY();</span><br><span class="line">        final int viewFlags = mViewFlags;</span><br><span class="line">        final int action = event.getAction();</span><br><span class="line"></span><br><span class="line">        if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">                setPressed(false);</span><br><span class="line">            &#125;</span><br><span class="line">            // A disabled view that is clickable still consumes the touch</span><br><span class="line">            // events, it just doesn&#x27;t respond to them.</span><br><span class="line">            return (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mTouchDelegate != null) &#123;</span><br><span class="line">            if (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">            switch (action) &#123;</span><br><span class="line">                case MotionEvent.ACTION_UP:</span><br><span class="line">                    boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</span><br><span class="line">                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</span><br><span class="line">                        // take focus if we don&#x27;t have it already and we should in</span><br><span class="line">                        // touch mode.</span><br><span class="line">                        boolean focusTaken = false;</span><br><span class="line">                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            // The button is being released before we actually</span><br><span class="line">                            // showed it as pressed.  Make it show the pressed</span><br><span class="line">                            // state now (before scheduling the click) to ensure</span><br><span class="line">                            // the user sees it.</span><br><span class="line">                            setPressed(true, x, y);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            // This is a tap, so remove the longpress check</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            // Only perform take click actions if we were in the pressed state</span><br><span class="line">                            if (!focusTaken) &#123;</span><br><span class="line">                                // Use a Runnable and post this rather than calling</span><br><span class="line">                                // performClick directly. This lets other visual state</span><br><span class="line">                                // of the view update before click actions start.</span><br><span class="line">                                if (mPerformClick == null) &#123;</span><br><span class="line">                                    mPerformClick = new PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (!post(mPerformClick)) &#123;</span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (mUnsetPressedState == null) &#123;</span><br><span class="line">                            mUnsetPressedState = new UnsetPressedState();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            postDelayed(mUnsetPressedState,</span><br><span class="line">                                    ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                        &#125; else if (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                            // If the post failed, unpress right now</span><br><span class="line">                            mUnsetPressedState.run();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIgnoreNextUpEvent = false;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_DOWN:</span><br><span class="line">                    mHasPerformedLongPress = false;</span><br><span class="line"></span><br><span class="line">                    if (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Walk up the hierarchy to determine if we&#x27;re inside a scrolling container.</span><br><span class="line">                    boolean isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                    // For views inside a scrolling container, delay the pressed feedback for</span><br><span class="line">                    // a short period in case this is a scroll.</span><br><span class="line">                    if (isInScrollingContainer) &#123;</span><br><span class="line">                        mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                        if (mPendingCheckForTap == null) &#123;</span><br><span class="line">                            mPendingCheckForTap = new CheckForTap();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingCheckForTap.x = event.getX();</span><br><span class="line">                        mPendingCheckForTap.y = event.getY();</span><br><span class="line">                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Not inside a scrolling container, so show the feedback right away</span><br><span class="line">                        setPressed(true, x, y);</span><br><span class="line">                        checkForLongClick(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    setPressed(false);</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress = false;</span><br><span class="line">                    mHasPerformedLongPress = false;</span><br><span class="line">                    mIgnoreNextUpEvent = false;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_MOVE:</span><br><span class="line">                    drawableHotspotChanged(x, y);</span><br><span class="line"></span><br><span class="line">                    // Be lenient about moving outside of buttons</span><br><span class="line">                    if (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                        // Outside button</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">                            // Remove any future long press/tap checks</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            setPressed(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在ACTION为MotionEvent.ACTION_UP时，我们经过层层调用最终执行了performClick，方法而这个方法中我们回调了View的OnClickListener的onClick方法。。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean performClick() &#123;</span><br><span class="line">        final boolean result;</span><br><span class="line">        final ListenerInfo li = mListenerInfo;</span><br><span class="line">        if (li != null &amp;&amp; li.mOnClickListener != null) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            li.mOnClickListener.onClick(this);</span><br><span class="line">            result = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以View组件分发触摸事件的时候：</p>
<ul>
<li><p>View控件会首先执行dispatchTouchEvent方法。</p>
</li>
<li><p>View控件在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法。</p>
</li>
<li><p>View的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调运onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。</p>
</li>
<li><p>View控件不是enable的，那么即使设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。</p>
</li>
<li><p>如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。</p>
</li>
</ul>
<p>参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/xiaanming/article/details/21696315">http://blog.csdn.net/xiaanming/article/details/21696315</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9097463">http://blog.csdn.net/guolin_blog/article/details/9097463</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9153747">http://blog.csdn.net/guolin_blog/article/details/9153747</a></p>
<p>另外对android源码解析方法感兴趣的可参考我的：<br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50634435"> android源码解析之（一）–&gt;android项目构建过程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50751687">android源码解析之（二）–&gt;异步消息机制</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50803849">android源码解析之（三）–&gt;异步任务AsyncTask</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50936584">android源码解析之（四）–&gt;HandlerThread</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50958757">android源码解析之（五）–&gt;IntentService</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50963006">android源码解析之（六）–&gt;Log</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50971968">android源码解析之（七）–&gt;LruCache</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51104873">android源码解析之（八）–&gt;Zygote进程启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51105171">android源码解析之（九）–&gt;SystemServer进程启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51112031">android源码解析之（十）–&gt;Launcher启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51119333">android源码解析之（十一）–&gt;应用进程启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51203482">android源码解析之（十二）–&gt;系统启动并解析Manifest的流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51210682">android源码解析之（十三）–&gt;apk安装流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51224992">android源码解析之（十四）–&gt;Activity启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51232309">android源码解析之（十五）–&gt;Activity销毁流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51252082">android源码解析（十六）–&gt;应用进程Context创建流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51284556">android源码解析（十七）–&gt;Activity布局加载流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51285804">android源码解析（十八）–&gt;Activity布局绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51289456">android源码解析（十九）–&gt;Dialog加载绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51303072">android源码解析（二十）–&gt;Dialog取消绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51322574">android源码解析（二十一）–&gt;PopupWindow加载绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51374627">android源码解析（二十二）–&gt;Toast加载绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51382326">android源码解析（二十三）–&gt;Android异常处理流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51464535">android源码解析（二十四）–&gt;onSaveInstanceState执行时机</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51465071">android源码解析（二十五）–&gt;onLowMemory执行流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51474288">android源码解析（二十六）–&gt;截屏事件流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51475929">android源码解析（二十七）–&gt;HOME事件流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51487978">android源码解析（二十八）–&gt;电源开关机按键事件流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51513771">android源码解析（二十九）–&gt;应用程序返回按键执行流程</a></p>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Android%E5%9F%BA%E7%A1%80/">Android基础</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Android/">Android</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/">蓝牙开发</a><span> </span><a class="article-more button is-small link-muted index-tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>20 分钟  <i class="fas fa-pencil-alt"> </i>3.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"> </a></h1><div class="content"><p>从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。<br>android系统的事件分发流程分为很多部分：</p>
<ul>
<li>Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层</li>
</ul>
<p>所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。</p>
<p><strong>在Native层android系统的事件流程：</strong></p>
<ul>
<li><p>Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。</p>
</li>
<li><p>在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。</p>
</li>
<li><p>将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。</p>
</li>
<li><p>Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。</p>
</li>
<li><p>Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。</p>
</li>
</ul>
<p>可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。</p>
<p><strong>在ViewRootImpl层android系统的事件流程</strong></p>
<p>在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">        onInputEventFinished(seq, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final class ImeInputEventSender extends InputEventSender &#123;</span><br><span class="line">        public ImeInputEventSender(InputChannel inputChannel, Looper looper) &#123;</span><br><span class="line">            super(inputChannel, looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">            finishedInputEvent(seq, handled, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-06T14:20:03.793Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-06</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>29 分钟  <i class="fas fa-pencil-alt"> </i>4.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"> </a></h1><div class="content"><p>前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。</p>
<p>和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。</p>
<p>下面首先看一下dispatchUnhandledKey方法的实现逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent = null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm = event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode = event.getKeyCode();</span><br><span class="line">            final int metaState = event.getMetaState();</span><br><span class="line">            final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() == 0;</span><br><span class="line"></span><br><span class="line">            // Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction = kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction = mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction != null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent = KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过前面两篇文章的分析<br>（<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51474288"> android源码解析（二十六）–&gt;截屏事件流程</a>&amp;nbsp;&amp;nbsp;<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51475929">android源码解析（二十七）–&gt;HOME事件流程</a>）<br>我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) != 0) &#123;</span><br><span class="line">            long delayMillis = interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis == 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">            case KeyEvent.KEYCODE_POWER: &#123;</span><br><span class="line">                result &amp;= ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey = false; // wake-up will be handled separately</span><br><span class="line">                if (down) &#123;</span><br><span class="line">                    interceptPowerKeyDown(event, interactive);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    interceptPowerKeyUp(event, interactive, canceled);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private void interceptPowerKeyDown(KeyEvent event, boolean interactive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // Latch power key state to detect screenshot chord.</span><br><span class="line">        if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) &#123;</span><br><span class="line">            mScreenshotChordPowerKeyTriggered = true;</span><br><span class="line">            mScreenshotChordPowerKeyTime = event.getDownTime();</span><br><span class="line">            interceptScreenshotChord();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Stop ringing or end call if configured to do so when power is pressed.</span><br><span class="line">        TelecomManager telecomManager = getTelecommService();</span><br><span class="line">        boolean hungUp = false;</span><br><span class="line">        if (telecomManager != null) &#123;</span><br><span class="line">            if (telecomManager.isRinging()) &#123;</span><br><span class="line">                // Pressing Power while there&#x27;s a ringing incoming</span><br><span class="line">                // call should silence the ringer.</span><br><span class="line">                telecomManager.silenceRinger();</span><br><span class="line">            &#125; else if ((mIncallPowerBehavior</span><br><span class="line">                    &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0</span><br><span class="line">                    &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) &#123;</span><br><span class="line">                // Otherwise, if &quot;Power button ends call&quot; is enabled,</span><br><span class="line">                // the Power button will hang up any current active call.</span><br><span class="line">                hungUp = telecomManager.endCall();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If the power key has still not yet been handled, then detect short</span><br><span class="line">        // press, long press, or multi press and decide what to do.</span><br><span class="line">        mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                || mScreenshotChordVolumeUpKeyTriggered;</span><br><span class="line">        if (!mPowerKeyHandled) &#123;</span><br><span class="line">            if (interactive) &#123;</span><br><span class="line">                // When interactive, we&#x27;re already awake.</span><br><span class="line">                // Wait for a long press or for the button to be released to decide what to do.</span><br><span class="line">                if (hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                wakeUpFromPowerKey(event.getDownTime());</span><br><span class="line"></span><br><span class="line">                if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                    mBeganFromNonInteractive = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int maxCount = getMaxMultiPressPowerCount();</span><br><span class="line"></span><br><span class="line">                    if (maxCount &lt;= 1) &#123;</span><br><span class="line">                        mPowerKeyHandled = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBeganFromNonInteractive = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case MSG_POWER_LONG_PRESS:</span><br><span class="line">                    powerLongPress();</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void powerLongPress() &#123;</span><br><span class="line">        final int behavior = getResolvedLongPressOnPowerBehavior();</span><br><span class="line">        switch (behavior) &#123;</span><br><span class="line">        case LONG_PRESS_POWER_NOTHING:</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_GLOBAL_ACTIONS:</span><br><span class="line">            mPowerKeyHandled = true;</span><br><span class="line">            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) &#123;</span><br><span class="line">                performAuditoryFeedbackForAccessibilityIfNeed();</span><br><span class="line">            &#125;</span><br><span class="line">            showGlobalActionsInternal();</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF:</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:</span><br><span class="line">            mPowerKeyHandled = true;</span><br><span class="line">            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">            mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面：<br><img src="http://img.blog.csdn.net/20160524153125405" alt="这里写图片描述"></p>
<p>然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void showGlobalActionsInternal() &#123;</span><br><span class="line">        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">        if (mGlobalActions == null) &#123;</span><br><span class="line">            mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs);</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean keyguardShowing = isKeyguardShowingAndNotOccluded();</span><br><span class="line">        mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned());</span><br><span class="line">        if (keyguardShowing) &#123;</span><br><span class="line">            // since it took two seconds of long press to bring this up,</span><br><span class="line">            // poke the wake lock so they have some time to see the dialog.</span><br><span class="line">            mPowerManager.userActivity(SystemClock.uptimeMillis(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51475929">android源码解析（二十七）–&gt;HOME事件流程</a>）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mWindowManagerFuncs = windowManagerFuncs;</span><br><span class="line">        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">        mDreamManager = IDreamManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(DreamService.DREAM_SERVICE));</span><br><span class="line"></span><br><span class="line">        // receive broadcasts</span><br><span class="line">        IntentFilter filter = new IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);</span><br><span class="line">        context.registerReceiver(mBroadcastReceiver, filter);</span><br><span class="line"></span><br><span class="line">        ConnectivityManager cm = (ConnectivityManager)</span><br><span class="line">                context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        mHasTelephony = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);</span><br><span class="line"></span><br><span class="line">        // get notified of phone state changes</span><br><span class="line">        TelephonyManager telephonyManager =</span><br><span class="line">                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);</span><br><span class="line">        mContext.getContentResolver().registerContentObserver(</span><br><span class="line">                Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true,</span><br><span class="line">                mAirplaneModeObserver);</span><br><span class="line">        Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">        mHasVibrator = vibrator != null &amp;&amp; vibrator.hasVibrator();</span><br><span class="line"></span><br><span class="line">        mShowSilentToggle = SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_useFixedVolume);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) &#123;</span><br><span class="line">        mKeyguardShowing = keyguardShowing;</span><br><span class="line">        mDeviceProvisioned = isDeviceProvisioned;</span><br><span class="line">        if (mDialog != null) &#123;</span><br><span class="line">            mDialog.dismiss();</span><br><span class="line">            mDialog = null;</span><br><span class="line">            // Show delayed, so that the dismiss of the previous dialog completes</span><br><span class="line">            mHandler.sendEmptyMessage(MESSAGE_SHOW);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleShow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void handleShow() &#123;</span><br><span class="line">        awakenIfNecessary();</span><br><span class="line">        mDialog = createDialog();</span><br><span class="line">        prepareDialog();</span><br><span class="line"></span><br><span class="line">        // If we only have 1 item and it&#x27;s a simple press action, just do this action.</span><br><span class="line">        if (mAdapter.getCount() == 1</span><br><span class="line">                &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction</span><br><span class="line">                &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) &#123;</span><br><span class="line">            ((SinglePressAction) mAdapter.getItem(0)).onPress();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            WindowManager.LayoutParams attrs = mDialog.getWindow().getAttributes();</span><br><span class="line">            attrs.setTitle(&quot;GlobalActions&quot;);</span><br><span class="line">            mDialog.getWindow().setAttributes(attrs);</span><br><span class="line">            mDialog.show();</span><br><span class="line">            mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">private GlobalActionsDialog createDialog() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mAirplaneModeOn = new ToggleAction(</span><br><span class="line">                R.drawable.ic_lock_airplane_mode,</span><br><span class="line">                R.drawable.ic_lock_airplane_mode_off,</span><br><span class="line">                R.string.global_actions_toggle_airplane_mode,</span><br><span class="line">                R.string.global_actions_airplane_mode_on_status,</span><br><span class="line">                R.string.global_actions_airplane_mode_off_status) &#123;</span><br><span class="line"></span><br><span class="line">            void onToggle(boolean on) &#123;</span><br><span class="line">                if (mHasTelephony &amp;&amp; Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) &#123;</span><br><span class="line">                    mIsWaitingForEcmExit = true;</span><br><span class="line">                    // Launch ECM exit dialog</span><br><span class="line">                    Intent ecmDialogIntent =</span><br><span class="line">                            new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);</span><br><span class="line">                    ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                    mContext.startActivity(ecmDialogIntent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    changeAirplaneModeSystemSetting(on);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected void changeStateFromPress(boolean buttonOn) &#123;</span><br><span class="line">                if (!mHasTelephony) return;</span><br><span class="line"></span><br><span class="line">                // In ECM mode airplane state cannot be changed</span><br><span class="line">                if (!(Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) &#123;</span><br><span class="line">                    mState = buttonOn ? State.TurningOn : State.TurningOff;</span><br><span class="line">                    mAirplaneState = mState;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showDuringKeyguard() &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showBeforeProvisioning() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        onAirplaneModeChanged();</span><br><span class="line"></span><br><span class="line">        mItems = new ArrayList&lt;Action&gt;();</span><br><span class="line">        String[] defaultActions = mContext.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_globalActionsList);</span><br><span class="line"></span><br><span class="line">        ArraySet&lt;String&gt; addedKeys = new ArraySet&lt;String&gt;();</span><br><span class="line">        for (int i = 0; i &lt; defaultActions.length; i++) &#123;</span><br><span class="line">            String actionKey = defaultActions[i];</span><br><span class="line">            if (addedKeys.contains(actionKey)) &#123;</span><br><span class="line">                // If we already have added this, don&#x27;t add it again.</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(new PowerAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(mAirplaneModeOn);</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) &#123;</span><br><span class="line">                if (Settings.Global.getInt(mContext.getContentResolver(),</span><br><span class="line">                        Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 &amp;&amp; isCurrentUserOwner()) &#123;</span><br><span class="line">                    mItems.add(getBugReportAction());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) &#123;</span><br><span class="line">                if (mShowSilentToggle) &#123;</span><br><span class="line">                    mItems.add(mSilentModeAction);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) &#123;</span><br><span class="line">                if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) &#123;</span><br><span class="line">                    addUsersToMenu(mItems);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getSettingsAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getLockdownAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getVoiceAssistAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getAssistAction());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;Invalid global action key &quot; + actionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            // Add here so we don&#x27;t add more than one.</span><br><span class="line">            addedKeys.add(actionKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdapter = new MyAdapter();</span><br><span class="line"></span><br><span class="line">        AlertParams params = new AlertParams(mContext);</span><br><span class="line">        params.mAdapter = mAdapter;</span><br><span class="line">        params.mOnClickListener = this;</span><br><span class="line">        params.mForceInverseBackground = true;</span><br><span class="line"></span><br><span class="line">        GlobalActionsDialog dialog = new GlobalActionsDialog(mContext, params);</span><br><span class="line">        dialog.setCanceledOnTouchOutside(false); // Handled by the custom class.</span><br><span class="line"></span><br><span class="line">        dialog.getListView().setItemsCanFocus(true);</span><br><span class="line">        dialog.getListView().setLongClickable(true);</span><br><span class="line">        dialog.getListView().setOnItemLongClickListener(</span><br><span class="line">                new AdapterView.OnItemLongClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position,</span><br><span class="line">                            long id) &#123;</span><br><span class="line">                        final Action action = mAdapter.getItem(position);</span><br><span class="line">                        if (action instanceof LongPressAction) &#123;</span><br><span class="line">                            return ((LongPressAction) action).onLongPress();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        dialog.setOnDismissListener(this);</span><br><span class="line"></span><br><span class="line">        return dialog;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面：<br><img src="http://img.blog.csdn.net/20160525144307466" alt="这里写图片描述"></p>
<p>好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mItems.add(new PowerAction());</span><br></pre></td></tr></table></figure>
<p>这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final class PowerAction extends SinglePressAction implements LongPressAction &#123;</span><br><span class="line">        private PowerAction() &#123;</span><br><span class="line">            super(com.android.internal.R.drawable.ic_lock_power_off,</span><br><span class="line">                R.string.global_action_power_off);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onLongPress() &#123;</span><br><span class="line">            UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) &#123;</span><br><span class="line">                mWindowManagerFuncs.rebootSafeMode(true);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showDuringKeyguard() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showBeforeProvisioning() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onPress() &#123;</span><br><span class="line">            // shutdown by making sure radio and power are handled accordingly.</span><br><span class="line">            mWindowManagerFuncs.shutdown(false /* confirm */);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">		...</span><br><span class="line">        mWindowManagerFuncs = windowManagerFuncs;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。</p>
<p>经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initPolicy() &#123;</span><br><span class="line">        UiThread.getHandler().runWithScissors(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line"></span><br><span class="line">                mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。</p>
<p>然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false &#x2F;* confirm *&#x2F;);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void shutdown(boolean confirm) &#123;</span><br><span class="line">        ShutdownThread.shutdown(mContext, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void shutdown(final Context context, boolean confirm) &#123;</span><br><span class="line">        mReboot = false;</span><br><span class="line">        mRebootSafeMode = false;</span><br><span class="line">        shutdownInner(context, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void shutdownInner(final Context context, boolean confirm) &#123;</span><br><span class="line">        // ensure that only one thread is trying to power down.</span><br><span class="line">        // any additional calls are just returned</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int longPressBehavior = context.getResources().getInteger(</span><br><span class="line">                        com.android.internal.R.integer.config_longPressOnPowerBehavior);</span><br><span class="line">        final int resourceId = mRebootSafeMode</span><br><span class="line">                ? com.android.internal.R.string.reboot_safemode_confirm</span><br><span class="line">                : (longPressBehavior == 2</span><br><span class="line">                        ? com.android.internal.R.string.shutdown_confirm_question</span><br><span class="line">                        : com.android.internal.R.string.shutdown_confirm);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior);</span><br><span class="line"></span><br><span class="line">        if (confirm) &#123;</span><br><span class="line">            final CloseDialogReceiver closer = new CloseDialogReceiver(context);</span><br><span class="line">            if (sConfirmDialog != null) &#123;</span><br><span class="line">                sConfirmDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">            sConfirmDialog = new AlertDialog.Builder(context)</span><br><span class="line">                    .setTitle(mRebootSafeMode</span><br><span class="line">                            ? com.android.internal.R.string.reboot_safemode_title</span><br><span class="line">                            : com.android.internal.R.string.power_off)</span><br><span class="line">                    .setMessage(resourceId)</span><br><span class="line">                    .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            beginShutdownSequence(context);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(com.android.internal.R.string.no, null)</span><br><span class="line">                    .create();</span><br><span class="line">            closer.dialog = sConfirmDialog;</span><br><span class="line">            sConfirmDialog.setOnDismissListener(closer);</span><br><span class="line">            sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line">            sConfirmDialog.show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            beginShutdownSequence(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">private static void beginShutdownSequence(Context context) &#123;</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            sIsStarted = true;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) &#123;</span><br><span class="line">            mRebootUpdate = new File(UNCRYPT_PACKAGE_FILE).exists();</span><br><span class="line">            if (mRebootUpdate) &#123;</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_update_prepare));</span><br><span class="line">                pd.setMax(100);</span><br><span class="line">                pd.setProgressNumberFormat(null);</span><br><span class="line">                pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">                pd.setProgress(0);</span><br><span class="line">                pd.setIndeterminate(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Factory reset path. Set the dialog message accordingly.</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pd.setTitle(context.getText(com.android.internal.R.string.power_off));</span><br><span class="line">            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));</span><br><span class="line">            pd.setIndeterminate(true);</span><br><span class="line">        &#125;</span><br><span class="line">        pd.setCancelable(false);</span><br><span class="line">        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        pd.show();</span><br><span class="line"></span><br><span class="line">        sInstance.mProgressDialog = pd;</span><br><span class="line">        sInstance.mContext = context;</span><br><span class="line">        sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line"></span><br><span class="line">        // make sure we never fall asleep again</span><br><span class="line">        sInstance.mCpuWakeLock = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                    PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;);</span><br><span class="line">            sInstance.mCpuWakeLock.setReferenceCounted(false);</span><br><span class="line">            sInstance.mCpuWakeLock.acquire();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">            sInstance.mCpuWakeLock = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // also make sure the screen stays on for better user experience</span><br><span class="line">        sInstance.mScreenWakeLock = null;</span><br><span class="line">        if (sInstance.mPowerManager.isScreenOn()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                        PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;);</span><br><span class="line">                sInstance.mScreenWakeLock.setReferenceCounted(false);</span><br><span class="line">                sInstance.mScreenWakeLock.acquire();</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">                sInstance.mScreenWakeLock = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // start the thread that initiates shutdown</span><br><span class="line">        sInstance.mHandler = new Handler() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        sInstance.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。</p>
<p>总结：</p>
<ul>
<li><p>电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中；</p>
</li>
<li><p>在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等；</p>
</li>
<li><p>当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法；</p>
</li>
</ul>
<p>另外对android源码解析方法感兴趣的可参考我的：<br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50634435"> android源码解析之（一）–&gt;android项目构建过程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50751687">android源码解析之（二）–&gt;异步消息机制</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50803849">android源码解析之（三）–&gt;异步任务AsyncTask</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50936584">android源码解析之（四）–&gt;HandlerThread</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50958757">android源码解析之（五）–&gt;IntentService</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50963006">android源码解析之（六）–&gt;Log</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/50971968">android源码解析之（七）–&gt;LruCache</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51104873">android源码解析之（八）–&gt;Zygote进程启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51105171">android源码解析之（九）–&gt;SystemServer进程启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51112031">android源码解析之（十）–&gt;Launcher启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51119333">android源码解析之（十一）–&gt;应用进程启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51203482">android源码解析之（十二）–&gt;系统启动并解析Manifest的流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51210682">android源码解析之（十三）–&gt;apk安装流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51224992">android源码解析之（十四）–&gt;Activity启动流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51232309">android源码解析之（十五）–&gt;Activity销毁流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51252082">android源码解析（十六）–&gt;应用进程Context创建流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51284556">android源码解析（十七）–&gt;Activity布局加载流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51285804">android源码解析（十八）–&gt;Activity布局绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51289456">android源码解析（十九）–&gt;Dialog加载绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51303072">android源码解析（二十）–&gt;Dialog取消绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51322574">android源码解析（二十一）–&gt;PopupWindow加载绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51374627">android源码解析（二十二）–&gt;Toast加载绘制流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51382326">android源码解析（二十三）–&gt;Android异常处理流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51464535">android源码解析（二十四）–&gt;onSaveInstanceState执行时机</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51465071">android源码解析（二十五）–&gt;onLowMemory执行流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51474288">android源码解析（二十六）–&gt;截屏事件流程</a><br><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51475929">android源码解析（二十七）–&gt;HOME事件流程</a></p>
</div><div class="index-category-tag">  <hr></div></article></div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>13 分钟  <i class="fas fa-pencil-alt"> </i>2.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"> </a></h1><div class="content"><p>上一篇文章中我们介绍了android系统的截屏事件，由于截屏事件是一种系统全局处理事件，所以事件的处理逻辑不是在App中执行，而是在PhoneWindowManager中执行。而本文我们现在主要讲解android系统中HOME按键的事件处理，和截屏事件类似，这里的HOME按键也是系统级别的按键事件监听，所以其处理事件的逻辑也应该和截屏事件处理流程类似，从上一篇文章的分析过冲中我们不难发现，系统级别的按键处理逻辑其实都是在PhoneWindowManager中，所以HOME按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中执行，那么我们就从dispatchUnhandleKey方法开始分析HOME按键的处理流程。</p>
<p>好吧我们看一下PhoneWindowManager的dispatchUnhandleKey方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent = null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm = event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode = event.getKeyCode();</span><br><span class="line">            final int metaState = event.getMetaState();</span><br><span class="line">            final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() == 0;</span><br><span class="line"></span><br><span class="line">            // Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction = kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction = mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction != null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent = KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_INPUT) &#123;</span><br><span class="line">            if (fallbackEvent == null) &#123;</span><br><span class="line">                Slog.d(TAG, &quot;No fallback.&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.d(TAG, &quot;Performing fallback: &quot; + fallbackEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过查看源码，我们重点看一下dispatchUnhandledKey方法中调用的interceptFallback方法，关于HOME按键的处理逻辑也是在这个方法体中的，所以继续看一下interceptFallback方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) != 0) &#123;</span><br><span class="line">            long delayMillis = interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis == 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析源码我们知道关于HOME按键的处理逻辑主要是在interceptKeyBeforeDispatching方法的实现的，既然这样，我们看一下interceptKeyBeforeDispatching方法的实现：</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-06T14:14:50.969Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-06</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>26 分钟  <i class="fas fa-pencil-alt"> </i>3.9 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"> </a></h1><div class="content"><p>今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。</p>
<p>我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。</p>
<p>在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/** &#123;@inheritDoc&#125; */</span><br><span class="line">    @Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent = null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm = event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode = event.getKeyCode();</span><br><span class="line">            final int metaState = event.getMetaState();</span><br><span class="line">            final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() == 0;</span><br><span class="line"></span><br><span class="line">            // Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction = kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction = mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent = KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) != 0) &#123;</span><br><span class="line">            long delayMillis = interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis == 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理：</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-06T14:20:03.779Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-06</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>19 分钟  <i class="fas fa-pencil-alt"> </i>2.8 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"> </a></h1><div class="content"><p>上篇文章中我们分析了Activity的onSaveInstanceState方法执行时机，知道了Activity在一般情况下，若只是执行onPause方法则不会执行onSaveInstanceState方法，而一旦执行了onStop方法就会执行onSaveInstanceState方法，具体的信息，可以参见onSaveInstanceState方法执行时机：<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51464535">android源码解析（二十四）–&gt;onSaveInstanceState执行时机</a> 这篇文章中同样的我们分析一下Actvity（当然不只是Activity，同样包含Servier，ContentProvider，Application等）的另一个内部方法：onLowMemory。该方法主要用于当前系统可用内存比较低的时候回调使用。</p>
<p>这里简单介绍一下Android系统的内存分配机制。Android系统中一个个的App都是一个个不同的应用进程，拥有各自的JVM与运行时，每个App的进程可使用的内存大小都是固定的，当系统中App打开数量过多时，就会使Android系统的可用内存降低，对于当前正在使用的App而言，可能还需要继续申请系统内存，而我们的剩余系统内存已经不足以被当前App所申请了，这时候系统会自动的清理那些后台进程，进而释放出可用内存用于前台进程的使用，当然这里系统清理后台进程的算法不是我们讨论的重点。这里我们只是大概的分析Android系统回调Activity的onLowMemory方法的流程。</p>
<p>通过前面关于Activity的启动流程分析我们知道ActivityManagerService是整个Android系统的管理中枢，负责Activity，Servier等四大组件的启动与销毁等工作，同样的对于应用进程的管理工作也是在ActivityMaangerServier中完成的，我们知道android系统中有两个比较重要的进程Zygote进程和SystemServer进程，其中Zygote进程是整个Android系统的根进程，其他所有的进程都是通过Zygote进程fork出来的。而SystemServer进程则用于运行各种服务，为其他的应用进程提供各种功能接口等，在前面我们分析过SystemServer进程的启动流程（参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51105171"> android源码解析之（九）–&gt;SystemServer进程启动流程</a>）其中在SystemServer的startBootService方法中我们调用了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Set up the Application instance for the system process and get started.</span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br></pre></td></tr></table></figure>
<p>方法，看其注释说明，说的是为System进程初始化Application实例，这里我们可以看一下该方法的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void setSystemProcess() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);</span><br><span class="line">            ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">            ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this));</span><br><span class="line">            ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));</span><br><span class="line">            ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));</span><br><span class="line">            if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">                ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this));</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));</span><br><span class="line">            ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));</span><br><span class="line"></span><br><span class="line">            ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                    &quot;android&quot;, STOCK_PM_FLAGS);</span><br><span class="line">            mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);</span><br><span class="line">                app.persistent = true;</span><br><span class="line">                app.pid = MY_PID;</span><br><span class="line">                app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">                app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">                synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                    mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">                &#125;</span><br><span class="line">                updateLruProcessLocked(app, false, null);</span><br><span class="line">                updateOomAdjLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find android system package&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里简单介绍一下ServierManager是一个管理服务的服务，而其addServier方法就是注册各种服务（服务注册到JNI层，具体的关于是如何注册到JNI层的这里暂不做过多的解释）。可以发现在方法体中我们注册了名称为：memInfo的服务MemBinder，MemBinder是一个Binder类型的服务，主要用于检测系统内存情况，这里可以看一下其具体的实现逻辑：</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-06T14:20:03.822Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-06</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-08-06  <a class="commentCountImg" href="/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>14 分钟  <i class="fas fa-pencil-alt"> </i>2.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"> </a></h1><div class="content"><p>我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。<br>可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍：</p>
<blockquote>
<p>This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state.  For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}.</p>
</blockquote>
<p>可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。</p>
<p>通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。</p>
<p>Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考:<a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23547831/article/details/51224992"> android源码解析之（十四）–&gt;Activity启动流程</a>，文章中有对Activity生命周期的详细讲解。</p>
<p>好吧，先具体看一下ActivityThread.handlePauseActivity的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            // Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        return r != null ? performPauseActivity(r, finished, saveState) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法：</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/08/06/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/#more">阅读更多&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-08-06T14:20:03.858Z"><i class="far fa-calendar-check"> 最后修改: </i>2022-08-06</time></div></div></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/8/">8</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/favicon.jpg" alt="简则易从"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">简则易从</p><p class="is-size-6 is-block">书山有路勤为径，学海无涯苦作舟</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">72</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">78</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/moruoyiming" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Youtube" href="https://www.youtube.com/channel/UCemLDs1nqPnjHN04JCNtmbg"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/accounts/login/?next=/jianzeyicong/"><i class="fab fa-instagram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="500px" href="https://500px.com/p/moruoyiming123?view=photos"><i class="fab fa-500px"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://zhs.center/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">狗急跳墙</span></span><span class="level-right"><span class="level-item tag">zhs.center</span></span></a></li><li><a class="level is-mobile" href="https://www.androiddevtools.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓工具</span></span><span class="level-right"><span class="level-item tag">www.androiddevtools.cn</span></span></a></li><li><a class="level is-mobile" href="http://androidxref.com/6.0.0_r1/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓源码</span></span><span class="level-right"><span class="level-item tag">androidxref.com</span></span></a></li><li><a class="level is-mobile" href="http://idea.lanyus.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">IDEA破解</span></span><span class="level-right"><span class="level-item tag">idea.lanyus.com</span></span></a></li><li><a class="level is-mobile" href="https://www.atool99.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线接口</span></span><span class="level-right"><span class="level-item tag">www.atool99.com</span></span></a></li><li><a class="level is-mobile" href="http://www.bejson.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线解析</span></span><span class="level-right"><span class="level-item tag">www.bejson.com</span></span></a></li><li><a class="level is-mobile" href="https://tinypng.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">图片压缩</span></span><span class="level-right"><span class="level-item tag">tinypng.com</span></span></a></li><li><a class="level is-mobile" href="https://wallpapershome.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">高清壁纸</span></span><span class="level-right"><span class="level-item tag">wallpapershome.com</span></span></a></li><li><a class="level is-mobile" href="https://www.nunuyy2.org/dianying/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线电影</span></span><span class="level-right"><span class="level-item tag">www.nunuyy2.org</span></span></a></li><li><a class="level is-mobile" href="https://www.4ksj.com/forum-2-1.html" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">4K电影</span></span><span class="level-right"><span class="level-item tag">www.4ksj.com</span></span></a></li><li><a class="level is-mobile" href="https://cli.im/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">草料二维码</span></span><span class="level-right"><span class="level-item tag">cli.im</span></span></a></li><li><a class="level is-mobile" href="https://www.waitsun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MAC应用</span></span><span class="level-right"><span class="level-item tag">www.waitsun.com</span></span></a></li><li><a class="level is-mobile" href="https://sukebei.nyaa.si/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">sukebei(18禁)</span></span><span class="level-right"><span class="level-item tag">sukebei.nyaa.si</span></span></a></li><li><a class="level is-mobile" href="https://file.wikileaks.org/file/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">暗网</span></span><span class="level-right"><span class="level-item tag">file.wikileaks.org</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/08/06/%E5%9C%A8Mac%E4%B8%8B%E5%90%AF%E5%8A%A8Tomcat/"><img src="/gallery/thumbnails/8e383593gy1gjqadonhthj23sw2j41l0.jpg" alt="在Mac下启动Tomcat"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-06T14:31:49.958Z">2022-08-06</time></p><p class="title"><a href="/2022/08/06/%E5%9C%A8Mac%E4%B8%8B%E5%90%AF%E5%8A%A8Tomcat/">在Mac下启动Tomcat</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/08/06/%E5%AE%89%E8%A3%85apk%E6%8F%90%E7%A4%BAFailure%20%5BINSTALL_FAILED_TEST_ONLY%20%20installPackageL/"><img src="/gallery/thumbnails/plant.jpg" alt="安装apk提示Failure [INSTALL_FAILED_TEST_ONLY/ installPackageL"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-06T14:31:40.244Z">2022-08-06</time></p><p class="title"><a href="/2022/08/06/%E5%AE%89%E8%A3%85apk%E6%8F%90%E7%A4%BAFailure%20%5BINSTALL_FAILED_TEST_ONLY%20%20installPackageL/">安装apk提示Failure [INSTALL_FAILED_TEST_ONLY/ installPackageL</a></p><p class="categories"><a href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-06T14:31:40.226Z">2022-08-06</time></p><p class="title"><a href="/2022/08/06/window10/"> </a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/08/06/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB/"><img src="/gallery/thumbnails/desert.jpg" alt="网络状态码分类"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-06T14:31:40.213Z">2022-08-06</time></p><p class="title"><a href="/2022/08/06/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB/">网络状态码分类</a></p><p class="categories"><a href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/08/06/Java%E5%AD%A6%E4%B9%A0/"><img src="/gallery/thumbnails/8e383593gy1gjqadonhthj23sw2j41l0.jpg" alt="Java应该章五的知识"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-06T14:31:32.919Z">2022-08-06</time></p><p class="title"><a href="/2022/08/06/Java%E5%AD%A6%E4%B9%A0/">Java应该章五的知识</a></p><p class="categories"><a href="/categories/%E8%87%AA%E8%80%83/">自考</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Android基础</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Android开发</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Java基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MAC%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">MAC应用</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mac%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">Mac应用</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">学习资料</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"><span class="level-start"><span class="level-item">科学上网</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"><span class="level-start"><span class="level-item">经典电影</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%87%AA%E8%80%83/"><span class="level-start"><span class="level-item">自考</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">72</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">30</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SystemServer/"><span class="tag">SystemServer</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zygote/"><span class="tag">Zygote</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gradle/"><span class="tag">gradle</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"><span class="tag">蓝牙开发</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ActivityManagerNative/"><span class="tag">ActivityManagerNative</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bt/"><span class="tag">bt</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"><span class="tag">史茅革</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%92%95%E5%99%9C/"><span class="tag">咕噜</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"><span class="tag">意外之旅</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%92%E7%81%B5/"><span class="tag">戒灵</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"><span class="tag">指环王</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"><span class="tag">比尔博·巴金斯</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%82%8E%E9%AD%94/"><span class="tag">炎魔</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%98%E9%81%93%E5%A4%AB/"><span class="tag">甘道夫</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E7%81%B5/"><span class="tag">精灵</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B4%A2%E4%BC%A6/"><span class="tag">索伦</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%BF%E6%8B%89%E8%B4%A1/"><span class="tag">阿拉贡</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA/"><span class="tag">霍比特人</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AD%94%E5%A4%9A/"><span class="tag">魔多</span><span class="tag is-grey-lightest">6</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="简则易从的博客" height="28"></a><p class="size-small"><span>&copy; 2022 Brigitte Jian</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">川ICP备88888888号-8</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2014/11/11 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('c74535c8b6792d0361e5','c6c1fc25232ba02b4431a4d88fd48c58726d8d99','moruoyiming','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('c74535c8b6792d0361e5','c6c1fc25232ba02b4431a4d88fd48c58726d8d99','moruoyiming','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>